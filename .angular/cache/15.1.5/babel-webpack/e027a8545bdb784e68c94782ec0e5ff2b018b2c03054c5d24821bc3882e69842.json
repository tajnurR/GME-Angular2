{"ast":null,"code":"/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nexport var DataMaskValues;\n(function (DataMaskValues) {\n  DataMaskValues[DataMaskValues[\"DATA_MASK_000\"] = 0] = \"DATA_MASK_000\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_001\"] = 1] = \"DATA_MASK_001\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_010\"] = 2] = \"DATA_MASK_010\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_011\"] = 3] = \"DATA_MASK_011\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_100\"] = 4] = \"DATA_MASK_100\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_101\"] = 5] = \"DATA_MASK_101\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_110\"] = 6] = \"DATA_MASK_110\";\n  DataMaskValues[DataMaskValues[\"DATA_MASK_111\"] = 7] = \"DATA_MASK_111\";\n})(DataMaskValues || (DataMaskValues = {}));\n/**\r\n * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations\r\n * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,\r\n * including areas used for finder patterns, timing patterns, etc. These areas should be unused\r\n * after the point they are unmasked anyway.</p>\r\n *\r\n * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position\r\n * and j is row position. In fact, as the text says, i is row position and j is column position.</p>\r\n *\r\n * @author Sean Owen\r\n */\nvar DataMask = /** @class */function () {\n  // See ISO 18004:2006 6.8.1\n  function DataMask(value, isMasked) {\n    this.value = value;\n    this.isMasked = isMasked;\n  }\n  // End of enum constants.\n  /**\r\n   * <p>Implementations of this method reverse the data masking process applied to a QR Code and\r\n   * make its bits ready to read.</p>\r\n   *\r\n   * @param bits representation of QR Code bits\r\n   * @param dimension dimension of QR Code, represented by bits, being unmasked\r\n   */\n  DataMask.prototype.unmaskBitMatrix = function (bits, dimension /*int*/) {\n    for (var i = 0; i < dimension; i++) {\n      for (var j = 0; j < dimension; j++) {\n        if (this.isMasked(i, j)) {\n          bits.flip(j, i);\n        }\n      }\n    }\n  };\n  DataMask.values = new Map([\n  /**\r\n   * 000: mask bits for which (x + y) mod 2 == 0\r\n   */\n  [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, function (i /*int*/, j /*int*/) {\n    return (i + j & 0x01) === 0;\n  })],\n  /**\r\n   * 001: mask bits for which x mod 2 == 0\r\n   */\n  [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, function (i /*int*/, j /*int*/) {\n    return (i & 0x01) === 0;\n  })],\n  /**\r\n   * 010: mask bits for which y mod 3 == 0\r\n   */\n  [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, function (i /*int*/, j /*int*/) {\n    return j % 3 === 0;\n  })],\n  /**\r\n   * 011: mask bits for which (x + y) mod 3 == 0\r\n   */\n  [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, function (i /*int*/, j /*int*/) {\n    return (i + j) % 3 === 0;\n  })],\n  /**\r\n   * 100: mask bits for which (x/2 + y/3) mod 2 == 0\r\n   */\n  [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, function (i /*int*/, j /*int*/) {\n    return (Math.floor(i / 2) + Math.floor(j / 3) & 0x01) === 0;\n  })],\n  /**\r\n   * 101: mask bits for which xy mod 2 + xy mod 3 == 0\r\n   * equivalently, such that xy mod 6 == 0\r\n   */\n  [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, function (i /*int*/, j /*int*/) {\n    return i * j % 6 === 0;\n  })],\n  /**\r\n   * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0\r\n   * equivalently, such that xy mod 6 < 3\r\n   */\n  [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, function (i /*int*/, j /*int*/) {\n    return i * j % 6 < 3;\n  })],\n  /**\r\n   * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0\r\n   * equivalently, such that (x + y + xy mod 3) mod 2 == 0\r\n   */\n  [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, function (i /*int*/, j /*int*/) {\n    return (i + j + i * j % 3 & 0x01) === 0;\n  })]]);\n  return DataMask;\n}();\nexport default DataMask;","map":{"version":3,"names":["DataMaskValues","DataMask","value","isMasked","prototype","unmaskBitMatrix","bits","dimension","i","j","flip","values","Map","DATA_MASK_000","DATA_MASK_001","DATA_MASK_010","DATA_MASK_011","DATA_MASK_100","Math","floor","DATA_MASK_101","DATA_MASK_110","DATA_MASK_111"],"sources":["E:/angular/GME-Angular2/node_modules/@zxing/library/esm/core/qrcode/decoder/DataMask.js"],"sourcesContent":["/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nexport var DataMaskValues;\r\n(function (DataMaskValues) {\r\n    DataMaskValues[DataMaskValues[\"DATA_MASK_000\"] = 0] = \"DATA_MASK_000\";\r\n    DataMaskValues[DataMaskValues[\"DATA_MASK_001\"] = 1] = \"DATA_MASK_001\";\r\n    DataMaskValues[DataMaskValues[\"DATA_MASK_010\"] = 2] = \"DATA_MASK_010\";\r\n    DataMaskValues[DataMaskValues[\"DATA_MASK_011\"] = 3] = \"DATA_MASK_011\";\r\n    DataMaskValues[DataMaskValues[\"DATA_MASK_100\"] = 4] = \"DATA_MASK_100\";\r\n    DataMaskValues[DataMaskValues[\"DATA_MASK_101\"] = 5] = \"DATA_MASK_101\";\r\n    DataMaskValues[DataMaskValues[\"DATA_MASK_110\"] = 6] = \"DATA_MASK_110\";\r\n    DataMaskValues[DataMaskValues[\"DATA_MASK_111\"] = 7] = \"DATA_MASK_111\";\r\n})(DataMaskValues || (DataMaskValues = {}));\r\n/**\r\n * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations\r\n * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,\r\n * including areas used for finder patterns, timing patterns, etc. These areas should be unused\r\n * after the point they are unmasked anyway.</p>\r\n *\r\n * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position\r\n * and j is row position. In fact, as the text says, i is row position and j is column position.</p>\r\n *\r\n * @author Sean Owen\r\n */\r\nvar DataMask = /** @class */ (function () {\r\n    // See ISO 18004:2006 6.8.1\r\n    function DataMask(value, isMasked) {\r\n        this.value = value;\r\n        this.isMasked = isMasked;\r\n    }\r\n    // End of enum constants.\r\n    /**\r\n     * <p>Implementations of this method reverse the data masking process applied to a QR Code and\r\n     * make its bits ready to read.</p>\r\n     *\r\n     * @param bits representation of QR Code bits\r\n     * @param dimension dimension of QR Code, represented by bits, being unmasked\r\n     */\r\n    DataMask.prototype.unmaskBitMatrix = function (bits, dimension /*int*/) {\r\n        for (var i = 0; i < dimension; i++) {\r\n            for (var j = 0; j < dimension; j++) {\r\n                if (this.isMasked(i, j)) {\r\n                    bits.flip(j, i);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    DataMask.values = new Map([\r\n        /**\r\n         * 000: mask bits for which (x + y) mod 2 == 0\r\n         */\r\n        [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, function (i /*int*/, j /*int*/) { return ((i + j) & 0x01) === 0; })],\r\n        /**\r\n         * 001: mask bits for which x mod 2 == 0\r\n         */\r\n        [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, function (i /*int*/, j /*int*/) { return (i & 0x01) === 0; })],\r\n        /**\r\n         * 010: mask bits for which y mod 3 == 0\r\n         */\r\n        [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, function (i /*int*/, j /*int*/) { return j % 3 === 0; })],\r\n        /**\r\n         * 011: mask bits for which (x + y) mod 3 == 0\r\n         */\r\n        [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, function (i /*int*/, j /*int*/) { return (i + j) % 3 === 0; })],\r\n        /**\r\n         * 100: mask bits for which (x/2 + y/3) mod 2 == 0\r\n         */\r\n        [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, function (i /*int*/, j /*int*/) { return ((Math.floor(i / 2) + Math.floor(j / 3)) & 0x01) === 0; })],\r\n        /**\r\n         * 101: mask bits for which xy mod 2 + xy mod 3 == 0\r\n         * equivalently, such that xy mod 6 == 0\r\n         */\r\n        [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, function (i /*int*/, j /*int*/) { return (i * j) % 6 === 0; })],\r\n        /**\r\n         * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0\r\n         * equivalently, such that xy mod 6 < 3\r\n         */\r\n        [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, function (i /*int*/, j /*int*/) { return ((i * j) % 6) < 3; })],\r\n        /**\r\n         * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0\r\n         * equivalently, such that (x + y + xy mod 3) mod 2 == 0\r\n         */\r\n        [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, function (i /*int*/, j /*int*/) { return ((i + j + ((i * j) % 3)) & 0x01) === 0; })],\r\n    ]);\r\n    return DataMask;\r\n}());\r\nexport default DataMask;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}