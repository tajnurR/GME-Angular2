{"ast":null,"code":"import WhiteRectangleDetector from '../../common/detector/WhiteRectangleDetector';\nimport DetectorResult from '../../common/DetectorResult';\nimport GridSamplerInstance from '../../common/GridSamplerInstance';\nimport NotFoundException from '../../NotFoundException';\nimport ResultPoint from '../../ResultPoint';\n/*\r\n * Copyright 2008 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code\r\n * is rotated or skewed, or partially obscured.</p>\r\n *\r\n * @author Sean Owen\r\n */\nvar Detector = /** @class */function () {\n  function Detector(image) {\n    this.image = image;\n    this.rectangleDetector = new WhiteRectangleDetector(this.image);\n  }\n  /**\r\n   * <p>Detects a Data Matrix Code in an image.</p>\r\n   *\r\n   * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code\r\n   * @throws NotFoundException if no Data Matrix Code can be found\r\n   */\n  Detector.prototype.detect = function () {\n    var cornerPoints = this.rectangleDetector.detect();\n    var points = this.detectSolid1(cornerPoints);\n    points = this.detectSolid2(points);\n    points[3] = this.correctTopRight(points);\n    if (!points[3]) {\n      throw new NotFoundException();\n    }\n    points = this.shiftToModuleCenter(points);\n    var topLeft = points[0];\n    var bottomLeft = points[1];\n    var bottomRight = points[2];\n    var topRight = points[3];\n    var dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;\n    var dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;\n    if ((dimensionTop & 0x01) === 1) {\n      dimensionTop += 1;\n    }\n    if ((dimensionRight & 0x01) === 1) {\n      dimensionRight += 1;\n    }\n    if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {\n      // The matrix is square\n      dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);\n    }\n    var bits = Detector.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);\n    return new DetectorResult(bits, [topLeft, bottomLeft, bottomRight, topRight]);\n  };\n  Detector.shiftPoint = function (point, to, div) {\n    var x = (to.getX() - point.getX()) / (div + 1);\n    var y = (to.getY() - point.getY()) / (div + 1);\n    return new ResultPoint(point.getX() + x, point.getY() + y);\n  };\n  Detector.moveAway = function (point, fromX, fromY) {\n    var x = point.getX();\n    var y = point.getY();\n    if (x < fromX) {\n      x -= 1;\n    } else {\n      x += 1;\n    }\n    if (y < fromY) {\n      y -= 1;\n    } else {\n      y += 1;\n    }\n    return new ResultPoint(x, y);\n  };\n  /**\r\n   * Detect a solid side which has minimum transition.\r\n   */\n  Detector.prototype.detectSolid1 = function (cornerPoints) {\n    // 0  2\n    // 1  3\n    var pointA = cornerPoints[0];\n    var pointB = cornerPoints[1];\n    var pointC = cornerPoints[3];\n    var pointD = cornerPoints[2];\n    var trAB = this.transitionsBetween(pointA, pointB);\n    var trBC = this.transitionsBetween(pointB, pointC);\n    var trCD = this.transitionsBetween(pointC, pointD);\n    var trDA = this.transitionsBetween(pointD, pointA);\n    // 0..3\n    // :  :\n    // 1--2\n    var min = trAB;\n    var points = [pointD, pointA, pointB, pointC];\n    if (min > trBC) {\n      min = trBC;\n      points[0] = pointA;\n      points[1] = pointB;\n      points[2] = pointC;\n      points[3] = pointD;\n    }\n    if (min > trCD) {\n      min = trCD;\n      points[0] = pointB;\n      points[1] = pointC;\n      points[2] = pointD;\n      points[3] = pointA;\n    }\n    if (min > trDA) {\n      points[0] = pointC;\n      points[1] = pointD;\n      points[2] = pointA;\n      points[3] = pointB;\n    }\n    return points;\n  };\n  /**\r\n   * Detect a second solid side next to first solid side.\r\n   */\n  Detector.prototype.detectSolid2 = function (points) {\n    // A..D\n    // :  :\n    // B--C\n    var pointA = points[0];\n    var pointB = points[1];\n    var pointC = points[2];\n    var pointD = points[3];\n    // Transition detection on the edge is not stable.\n    // To safely detect, shift the points to the module center.\n    var tr = this.transitionsBetween(pointA, pointD);\n    var pointBs = Detector.shiftPoint(pointB, pointC, (tr + 1) * 4);\n    var pointCs = Detector.shiftPoint(pointC, pointB, (tr + 1) * 4);\n    var trBA = this.transitionsBetween(pointBs, pointA);\n    var trCD = this.transitionsBetween(pointCs, pointD);\n    // 0..3\n    // |  :\n    // 1--2\n    if (trBA < trCD) {\n      // solid sides: A-B-C\n      points[0] = pointA;\n      points[1] = pointB;\n      points[2] = pointC;\n      points[3] = pointD;\n    } else {\n      // solid sides: B-C-D\n      points[0] = pointB;\n      points[1] = pointC;\n      points[2] = pointD;\n      points[3] = pointA;\n    }\n    return points;\n  };\n  /**\r\n   * Calculates the corner position of the white top right module.\r\n   */\n  Detector.prototype.correctTopRight = function (points) {\n    // A..D\n    // |  :\n    // B--C\n    var pointA = points[0];\n    var pointB = points[1];\n    var pointC = points[2];\n    var pointD = points[3];\n    // shift points for safe transition detection.\n    var trTop = this.transitionsBetween(pointA, pointD);\n    var trRight = this.transitionsBetween(pointB, pointD);\n    var pointAs = Detector.shiftPoint(pointA, pointB, (trRight + 1) * 4);\n    var pointCs = Detector.shiftPoint(pointC, pointB, (trTop + 1) * 4);\n    trTop = this.transitionsBetween(pointAs, pointD);\n    trRight = this.transitionsBetween(pointCs, pointD);\n    var candidate1 = new ResultPoint(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));\n    var candidate2 = new ResultPoint(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));\n    if (!this.isValid(candidate1)) {\n      if (this.isValid(candidate2)) {\n        return candidate2;\n      }\n      return null;\n    }\n    if (!this.isValid(candidate2)) {\n      return candidate1;\n    }\n    var sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);\n    var sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);\n    if (sumc1 > sumc2) {\n      return candidate1;\n    } else {\n      return candidate2;\n    }\n  };\n  /**\r\n   * Shift the edge points to the module center.\r\n   */\n  Detector.prototype.shiftToModuleCenter = function (points) {\n    // A..D\n    // |  :\n    // B--C\n    var pointA = points[0];\n    var pointB = points[1];\n    var pointC = points[2];\n    var pointD = points[3];\n    // calculate pseudo dimensions\n    var dimH = this.transitionsBetween(pointA, pointD) + 1;\n    var dimV = this.transitionsBetween(pointC, pointD) + 1;\n    // shift points for safe dimension detection\n    var pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);\n    var pointCs = Detector.shiftPoint(pointC, pointB, dimH * 4);\n    //  calculate more precise dimensions\n    dimH = this.transitionsBetween(pointAs, pointD) + 1;\n    dimV = this.transitionsBetween(pointCs, pointD) + 1;\n    if ((dimH & 0x01) === 1) {\n      dimH += 1;\n    }\n    if ((dimV & 0x01) === 1) {\n      dimV += 1;\n    }\n    // WhiteRectangleDetector returns points inside of the rectangle.\n    // I want points on the edges.\n    var centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;\n    var centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;\n    pointA = Detector.moveAway(pointA, centerX, centerY);\n    pointB = Detector.moveAway(pointB, centerX, centerY);\n    pointC = Detector.moveAway(pointC, centerX, centerY);\n    pointD = Detector.moveAway(pointD, centerX, centerY);\n    var pointBs;\n    var pointDs;\n    // shift points to the center of each modules\n    pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);\n    pointAs = Detector.shiftPoint(pointAs, pointD, dimH * 4);\n    pointBs = Detector.shiftPoint(pointB, pointA, dimV * 4);\n    pointBs = Detector.shiftPoint(pointBs, pointC, dimH * 4);\n    pointCs = Detector.shiftPoint(pointC, pointD, dimV * 4);\n    pointCs = Detector.shiftPoint(pointCs, pointB, dimH * 4);\n    pointDs = Detector.shiftPoint(pointD, pointC, dimV * 4);\n    pointDs = Detector.shiftPoint(pointDs, pointA, dimH * 4);\n    return [pointAs, pointBs, pointCs, pointDs];\n  };\n  Detector.prototype.isValid = function (p) {\n    return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();\n  };\n  Detector.sampleGrid = function (image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {\n    var sampler = GridSamplerInstance.getInstance();\n    return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n  };\n  /**\r\n   * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.\r\n   */\n  Detector.prototype.transitionsBetween = function (from, to) {\n    // See QR Code Detector, sizeOfBlackWhiteBlackRun()\n    var fromX = Math.trunc(from.getX());\n    var fromY = Math.trunc(from.getY());\n    var toX = Math.trunc(to.getX());\n    var toY = Math.trunc(to.getY());\n    var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n    if (steep) {\n      var temp = fromX;\n      fromX = fromY;\n      fromY = temp;\n      temp = toX;\n      toX = toY;\n      toY = temp;\n    }\n    var dx = Math.abs(toX - fromX);\n    var dy = Math.abs(toY - fromY);\n    var error = -dx / 2;\n    var ystep = fromY < toY ? 1 : -1;\n    var xstep = fromX < toX ? 1 : -1;\n    var transitions = 0;\n    var inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);\n    for (var x = fromX, y = fromY; x !== toX; x += xstep) {\n      var isBlack = this.image.get(steep ? y : x, steep ? x : y);\n      if (isBlack !== inBlack) {\n        transitions++;\n        inBlack = isBlack;\n      }\n      error += dy;\n      if (error > 0) {\n        if (y === toY) {\n          break;\n        }\n        y += ystep;\n        error -= dx;\n      }\n    }\n    return transitions;\n  };\n  return Detector;\n}();\nexport default Detector;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}