{"ast":null,"code":"/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n/*namespace com.google.zxing.qrcode.decoder {*/\nimport ChecksumException from '../../ChecksumException';\nimport BitMatrix from '../../common/BitMatrix';\nimport GenericGF from '../../common/reedsolomon/GenericGF';\nimport ReedSolomonDecoder from '../../common/reedsolomon/ReedSolomonDecoder';\nimport BitMatrixParser from './BitMatrixParser';\nimport DataBlock from './DataBlock';\nimport DecodedBitStreamParser from './DecodedBitStreamParser';\nimport QRCodeDecoderMetaData from './QRCodeDecoderMetaData';\n/*import java.util.Map;*/\n/**\r\n * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting\r\n * the QR Code from an image.</p>\r\n *\r\n * @author Sean Owen\r\n */\nvar Decoder = /** @class */function () {\n  function Decoder() {\n    this.rsDecoder = new ReedSolomonDecoder(GenericGF.QR_CODE_FIELD_256);\n  }\n  // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {\n  //   return decode(image, null)\n  // }\n  /**\r\n   * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.\r\n   * \"true\" is taken to mean a black module.</p>\r\n   *\r\n   * @param image booleans representing white/black QR Code modules\r\n   * @param hints decoding hints that should be used to influence decoding\r\n   * @return text and bytes encoded within the QR Code\r\n   * @throws FormatException if the QR Code cannot be decoded\r\n   * @throws ChecksumException if error correction fails\r\n   */\n  Decoder.prototype.decodeBooleanArray = function (image, hints) {\n    return this.decodeBitMatrix(BitMatrix.parseFromBooleanArray(image), hints);\n  };\n  // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {\n  //   return decode(bits, null)\n  // }\n  /**\r\n   * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken to mean a black module.</p>\r\n   *\r\n   * @param bits booleans representing white/black QR Code modules\r\n   * @param hints decoding hints that should be used to influence decoding\r\n   * @return text and bytes encoded within the QR Code\r\n   * @throws FormatException if the QR Code cannot be decoded\r\n   * @throws ChecksumException if error correction fails\r\n   */\n  Decoder.prototype.decodeBitMatrix = function (bits, hints) {\n    // Construct a parser and read version, error-correction level\n    var parser = new BitMatrixParser(bits);\n    var ex = null;\n    try {\n      return this.decodeBitMatrixParser(parser, hints);\n    } catch (e /*: FormatException, ChecksumException*/) {\n      ex = e;\n    }\n    try {\n      // Revert the bit matrix\n      parser.remask();\n      // Will be attempting a mirrored reading of the version and format info.\n      parser.setMirror(true);\n      // Preemptively read the version.\n      parser.readVersion();\n      // Preemptively read the format information.\n      parser.readFormatInformation();\n      /*\r\n       * Since we're here, this means we have successfully detected some kind\r\n       * of version and format information when mirrored. This is a good sign,\r\n       * that the QR code may be mirrored, and we should try once more with a\r\n       * mirrored content.\r\n       */\n      // Prepare for a mirrored reading.\n      parser.mirror();\n      var result = this.decodeBitMatrixParser(parser, hints);\n      // Success! Notify the caller that the code was mirrored.\n      result.setOther(new QRCodeDecoderMetaData(true));\n      return result;\n    } catch (e /*FormatException | ChecksumException*/) {\n      // Throw the exception from the original reading\n      if (ex !== null) {\n        throw ex;\n      }\n      throw e;\n    }\n  };\n  Decoder.prototype.decodeBitMatrixParser = function (parser, hints) {\n    var e_1, _a, e_2, _b;\n    var version = parser.readVersion();\n    var ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();\n    // Read codewords\n    var codewords = parser.readCodewords();\n    // Separate into data blocks\n    var dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);\n    // Count total number of data bytes\n    var totalBytes = 0;\n    try {\n      for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {\n        var dataBlock = dataBlocks_1_1.value;\n        totalBytes += dataBlock.getNumDataCodewords();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    var resultBytes = new Uint8Array(totalBytes);\n    var resultOffset = 0;\n    try {\n      // Error-correct and copy data blocks together into a stream of bytes\n      for (var dataBlocks_2 = __values(dataBlocks), dataBlocks_2_1 = dataBlocks_2.next(); !dataBlocks_2_1.done; dataBlocks_2_1 = dataBlocks_2.next()) {\n        var dataBlock = dataBlocks_2_1.value;\n        var codewordBytes = dataBlock.getCodewords();\n        var numDataCodewords = dataBlock.getNumDataCodewords();\n        this.correctErrors(codewordBytes, numDataCodewords);\n        for (var i = 0; i < numDataCodewords; i++) {\n          resultBytes[resultOffset++] = codewordBytes[i];\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (dataBlocks_2_1 && !dataBlocks_2_1.done && (_b = dataBlocks_2.return)) _b.call(dataBlocks_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    // Decode the contents of that stream of bytes\n    return DecodedBitStreamParser.decode(resultBytes, version, ecLevel, hints);\n  };\n  /**\r\n   * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\r\n   * correct the errors in-place using Reed-Solomon error correction.</p>\r\n   *\r\n   * @param codewordBytes data and error correction codewords\r\n   * @param numDataCodewords number of codewords that are data bytes\r\n   * @throws ChecksumException if error correction fails\r\n   */\n  Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords /*int*/) {\n    // const numCodewords = codewordBytes.length;\n    // First read into an array of ints\n    var codewordsInts = new Int32Array(codewordBytes);\n    // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?\n    // const codewordsInts = new Int32Array(numCodewords)\n    // for (let i = 0; i < numCodewords; i++) {\n    //   codewordsInts[i] = codewordBytes[i] & 0xFF\n    // }\n    try {\n      this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n    } catch (ignored /*: ReedSolomonException*/) {\n      throw new ChecksumException();\n    }\n    // Copy back into array of bytes -- only need to worry about the bytes that were data\n    // We don't care about errors in the error-correction codewords\n    for (var i = 0; i < numDataCodewords; i++) {\n      codewordBytes[i] = /*(byte) */codewordsInts[i];\n    }\n  };\n  return Decoder;\n}();\nexport default Decoder;","map":{"version":3,"names":["__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","ChecksumException","BitMatrix","GenericGF","ReedSolomonDecoder","BitMatrixParser","DataBlock","DecodedBitStreamParser","QRCodeDecoderMetaData","Decoder","rsDecoder","QR_CODE_FIELD_256","prototype","decodeBooleanArray","image","hints","decodeBitMatrix","parseFromBooleanArray","bits","parser","ex","decodeBitMatrixParser","e","remask","setMirror","readVersion","readFormatInformation","mirror","result","setOther","e_1","_a","e_2","_b","version","ecLevel","getErrorCorrectionLevel","codewords","readCodewords","dataBlocks","getDataBlocks","totalBytes","dataBlocks_1","dataBlocks_1_1","dataBlock","getNumDataCodewords","e_1_1","error","return","resultBytes","Uint8Array","resultOffset","dataBlocks_2","dataBlocks_2_1","codewordBytes","getCodewords","numDataCodewords","correctErrors","e_2_1","decode","codewordsInts","Int32Array","ignored"],"sources":["E:/angular/GME-Angular2/node_modules/@zxing/library/esm/core/qrcode/decoder/Decoder.js"],"sourcesContent":["/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __values = (this && this.__values) || function(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n};\r\n/*namespace com.google.zxing.qrcode.decoder {*/\r\nimport ChecksumException from '../../ChecksumException';\r\nimport BitMatrix from '../../common/BitMatrix';\r\nimport GenericGF from '../../common/reedsolomon/GenericGF';\r\nimport ReedSolomonDecoder from '../../common/reedsolomon/ReedSolomonDecoder';\r\nimport BitMatrixParser from './BitMatrixParser';\r\nimport DataBlock from './DataBlock';\r\nimport DecodedBitStreamParser from './DecodedBitStreamParser';\r\nimport QRCodeDecoderMetaData from './QRCodeDecoderMetaData';\r\n/*import java.util.Map;*/\r\n/**\r\n * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting\r\n * the QR Code from an image.</p>\r\n *\r\n * @author Sean Owen\r\n */\r\nvar Decoder = /** @class */ (function () {\r\n    function Decoder() {\r\n        this.rsDecoder = new ReedSolomonDecoder(GenericGF.QR_CODE_FIELD_256);\r\n    }\r\n    // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {\r\n    //   return decode(image, null)\r\n    // }\r\n    /**\r\n     * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.\r\n     * \"true\" is taken to mean a black module.</p>\r\n     *\r\n     * @param image booleans representing white/black QR Code modules\r\n     * @param hints decoding hints that should be used to influence decoding\r\n     * @return text and bytes encoded within the QR Code\r\n     * @throws FormatException if the QR Code cannot be decoded\r\n     * @throws ChecksumException if error correction fails\r\n     */\r\n    Decoder.prototype.decodeBooleanArray = function (image, hints) {\r\n        return this.decodeBitMatrix(BitMatrix.parseFromBooleanArray(image), hints);\r\n    };\r\n    // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {\r\n    //   return decode(bits, null)\r\n    // }\r\n    /**\r\n     * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken to mean a black module.</p>\r\n     *\r\n     * @param bits booleans representing white/black QR Code modules\r\n     * @param hints decoding hints that should be used to influence decoding\r\n     * @return text and bytes encoded within the QR Code\r\n     * @throws FormatException if the QR Code cannot be decoded\r\n     * @throws ChecksumException if error correction fails\r\n     */\r\n    Decoder.prototype.decodeBitMatrix = function (bits, hints) {\r\n        // Construct a parser and read version, error-correction level\r\n        var parser = new BitMatrixParser(bits);\r\n        var ex = null;\r\n        try {\r\n            return this.decodeBitMatrixParser(parser, hints);\r\n        }\r\n        catch (e /*: FormatException, ChecksumException*/) {\r\n            ex = e;\r\n        }\r\n        try {\r\n            // Revert the bit matrix\r\n            parser.remask();\r\n            // Will be attempting a mirrored reading of the version and format info.\r\n            parser.setMirror(true);\r\n            // Preemptively read the version.\r\n            parser.readVersion();\r\n            // Preemptively read the format information.\r\n            parser.readFormatInformation();\r\n            /*\r\n             * Since we're here, this means we have successfully detected some kind\r\n             * of version and format information when mirrored. This is a good sign,\r\n             * that the QR code may be mirrored, and we should try once more with a\r\n             * mirrored content.\r\n             */\r\n            // Prepare for a mirrored reading.\r\n            parser.mirror();\r\n            var result = this.decodeBitMatrixParser(parser, hints);\r\n            // Success! Notify the caller that the code was mirrored.\r\n            result.setOther(new QRCodeDecoderMetaData(true));\r\n            return result;\r\n        }\r\n        catch (e /*FormatException | ChecksumException*/) {\r\n            // Throw the exception from the original reading\r\n            if (ex !== null) {\r\n                throw ex;\r\n            }\r\n            throw e;\r\n        }\r\n    };\r\n    Decoder.prototype.decodeBitMatrixParser = function (parser, hints) {\r\n        var e_1, _a, e_2, _b;\r\n        var version = parser.readVersion();\r\n        var ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();\r\n        // Read codewords\r\n        var codewords = parser.readCodewords();\r\n        // Separate into data blocks\r\n        var dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);\r\n        // Count total number of data bytes\r\n        var totalBytes = 0;\r\n        try {\r\n            for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {\r\n                var dataBlock = dataBlocks_1_1.value;\r\n                totalBytes += dataBlock.getNumDataCodewords();\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        var resultBytes = new Uint8Array(totalBytes);\r\n        var resultOffset = 0;\r\n        try {\r\n            // Error-correct and copy data blocks together into a stream of bytes\r\n            for (var dataBlocks_2 = __values(dataBlocks), dataBlocks_2_1 = dataBlocks_2.next(); !dataBlocks_2_1.done; dataBlocks_2_1 = dataBlocks_2.next()) {\r\n                var dataBlock = dataBlocks_2_1.value;\r\n                var codewordBytes = dataBlock.getCodewords();\r\n                var numDataCodewords = dataBlock.getNumDataCodewords();\r\n                this.correctErrors(codewordBytes, numDataCodewords);\r\n                for (var i = 0; i < numDataCodewords; i++) {\r\n                    resultBytes[resultOffset++] = codewordBytes[i];\r\n                }\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (dataBlocks_2_1 && !dataBlocks_2_1.done && (_b = dataBlocks_2.return)) _b.call(dataBlocks_2);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        // Decode the contents of that stream of bytes\r\n        return DecodedBitStreamParser.decode(resultBytes, version, ecLevel, hints);\r\n    };\r\n    /**\r\n     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\r\n     * correct the errors in-place using Reed-Solomon error correction.</p>\r\n     *\r\n     * @param codewordBytes data and error correction codewords\r\n     * @param numDataCodewords number of codewords that are data bytes\r\n     * @throws ChecksumException if error correction fails\r\n     */\r\n    Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords /*int*/) {\r\n        // const numCodewords = codewordBytes.length;\r\n        // First read into an array of ints\r\n        var codewordsInts = new Int32Array(codewordBytes);\r\n        // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?\r\n        // const codewordsInts = new Int32Array(numCodewords)\r\n        // for (let i = 0; i < numCodewords; i++) {\r\n        //   codewordsInts[i] = codewordBytes[i] & 0xFF\r\n        // }\r\n        try {\r\n            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\r\n        }\r\n        catch (ignored /*: ReedSolomonException*/) {\r\n            throw new ChecksumException();\r\n        }\r\n        // Copy back into array of bytes -- only need to worry about the bytes that were data\r\n        // We don't care about errors in the error-correction codewords\r\n        for (var i = 0; i < numDataCodewords; i++) {\r\n            codewordBytes[i] = /*(byte) */ codewordsInts[i];\r\n        }\r\n    };\r\n    return Decoder;\r\n}());\r\nexport default Decoder;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}