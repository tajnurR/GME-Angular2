{"ast":null,"code":"import BarcodeFormat from '../BarcodeFormat';\nimport BitMatrix from '../common/BitMatrix';\nimport DecodeHintType from '../DecodeHintType';\nimport NotFoundException from '../NotFoundException';\nimport Result from '../Result';\nimport ResultMetadataType from '../ResultMetadataType';\nimport System from '../util/System';\nimport Decoder from './decoder/Decoder';\nimport Detector from './detector/Detector';\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * This implementation can detect and decode Data Matrix codes in an image.\r\n *\r\n * @author bbrown@google.com (Brian Brown)\r\n */\nvar DataMatrixReader = /** @class */function () {\n  function DataMatrixReader() {\n    this.decoder = new Decoder();\n  }\n  /**\r\n   * Locates and decodes a Data Matrix code in an image.\r\n   *\r\n   * @return a String representing the content encoded by the Data Matrix code\r\n   * @throws NotFoundException if a Data Matrix code cannot be found\r\n   * @throws FormatException if a Data Matrix code cannot be decoded\r\n   * @throws ChecksumException if error correction fails\r\n   */\n  // @Override\n  // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n  //   return decode(image, null);\n  // }\n  // @Override\n  DataMatrixReader.prototype.decode = function (image, hints) {\n    if (hints === void 0) {\n      hints = null;\n    }\n    var decoderResult;\n    var points;\n    if (hints != null && hints.has(DecodeHintType.PURE_BARCODE)) {\n      var bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());\n      decoderResult = this.decoder.decode(bits);\n      points = DataMatrixReader.NO_POINTS;\n    } else {\n      var detectorResult = new Detector(image.getBlackMatrix()).detect();\n      decoderResult = this.decoder.decode(detectorResult.getBits());\n      points = detectorResult.getPoints();\n    }\n    var rawBytes = decoderResult.getRawBytes();\n    var result = new Result(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat.DATA_MATRIX, System.currentTimeMillis());\n    var byteSegments = decoderResult.getByteSegments();\n    if (byteSegments != null) {\n      result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);\n    }\n    var ecLevel = decoderResult.getECLevel();\n    if (ecLevel != null) {\n      result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);\n    }\n    return result;\n  };\n  // @Override\n  DataMatrixReader.prototype.reset = function () {\n    // do nothing\n  };\n  /**\r\n   * This method detects a code in a \"pure\" image -- that is, pure monochrome image\r\n   * which contains only an unrotated, unskewed, image of a code, with some white border\r\n   * around it. This is a specialized method that works exceptionally fast in this special\r\n   * case.\r\n   *\r\n   * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)\r\n   */\n  DataMatrixReader.extractPureBits = function (image) {\n    var leftTopBlack = image.getTopLeftOnBit();\n    var rightBottomBlack = image.getBottomRightOnBit();\n    if (leftTopBlack == null || rightBottomBlack == null) {\n      throw new NotFoundException();\n    }\n    var moduleSize = this.moduleSize(leftTopBlack, image);\n    var top = leftTopBlack[1];\n    var bottom = rightBottomBlack[1];\n    var left = leftTopBlack[0];\n    var right = rightBottomBlack[0];\n    var matrixWidth = (right - left + 1) / moduleSize;\n    var matrixHeight = (bottom - top + 1) / moduleSize;\n    if (matrixWidth <= 0 || matrixHeight <= 0) {\n      throw new NotFoundException();\n    }\n    // Push in the \"border\" by half the module width so that we start\n    // sampling in the middle of the module. Just in case the image is a\n    // little off, this will help recover.\n    var nudge = moduleSize / 2;\n    top += nudge;\n    left += nudge;\n    // Now just read off the bits\n    var bits = new BitMatrix(matrixWidth, matrixHeight);\n    for (var y = 0; y < matrixHeight; y++) {\n      var iOffset = top + y * moduleSize;\n      for (var x = 0; x < matrixWidth; x++) {\n        if (image.get(left + x * moduleSize, iOffset)) {\n          bits.set(x, y);\n        }\n      }\n    }\n    return bits;\n  };\n  DataMatrixReader.moduleSize = function (leftTopBlack, image) {\n    var width = image.getWidth();\n    var x = leftTopBlack[0];\n    var y = leftTopBlack[1];\n    while (x < width && image.get(x, y)) {\n      x++;\n    }\n    if (x === width) {\n      throw new NotFoundException();\n    }\n    var moduleSize = x - leftTopBlack[0];\n    if (moduleSize === 0) {\n      throw new NotFoundException();\n    }\n    return moduleSize;\n  };\n  DataMatrixReader.NO_POINTS = [];\n  return DataMatrixReader;\n}();\nexport default DataMatrixReader;","map":{"version":3,"names":["BarcodeFormat","BitMatrix","DecodeHintType","NotFoundException","Result","ResultMetadataType","System","Decoder","Detector","DataMatrixReader","decoder","prototype","decode","image","hints","decoderResult","points","has","PURE_BARCODE","bits","extractPureBits","getBlackMatrix","NO_POINTS","detectorResult","detect","getBits","getPoints","rawBytes","getRawBytes","result","getText","length","DATA_MATRIX","currentTimeMillis","byteSegments","getByteSegments","putMetadata","BYTE_SEGMENTS","ecLevel","getECLevel","ERROR_CORRECTION_LEVEL","reset","leftTopBlack","getTopLeftOnBit","rightBottomBlack","getBottomRightOnBit","moduleSize","top","bottom","left","right","matrixWidth","matrixHeight","nudge","y","iOffset","x","get","set","width","getWidth"],"sources":["D:/Git/GME-Angular2/node_modules/@zxing/library/esm/core/datamatrix/DataMatrixReader.js"],"sourcesContent":["import BarcodeFormat from '../BarcodeFormat';\r\nimport BitMatrix from '../common/BitMatrix';\r\nimport DecodeHintType from '../DecodeHintType';\r\nimport NotFoundException from '../NotFoundException';\r\nimport Result from '../Result';\r\nimport ResultMetadataType from '../ResultMetadataType';\r\nimport System from '../util/System';\r\nimport Decoder from './decoder/Decoder';\r\nimport Detector from './detector/Detector';\r\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * This implementation can detect and decode Data Matrix codes in an image.\r\n *\r\n * @author bbrown@google.com (Brian Brown)\r\n */\r\nvar DataMatrixReader = /** @class */ (function () {\r\n    function DataMatrixReader() {\r\n        this.decoder = new Decoder();\r\n    }\r\n    /**\r\n     * Locates and decodes a Data Matrix code in an image.\r\n     *\r\n     * @return a String representing the content encoded by the Data Matrix code\r\n     * @throws NotFoundException if a Data Matrix code cannot be found\r\n     * @throws FormatException if a Data Matrix code cannot be decoded\r\n     * @throws ChecksumException if error correction fails\r\n     */\r\n    // @Override\r\n    // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\r\n    //   return decode(image, null);\r\n    // }\r\n    // @Override\r\n    DataMatrixReader.prototype.decode = function (image, hints) {\r\n        if (hints === void 0) { hints = null; }\r\n        var decoderResult;\r\n        var points;\r\n        if (hints != null && hints.has(DecodeHintType.PURE_BARCODE)) {\r\n            var bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());\r\n            decoderResult = this.decoder.decode(bits);\r\n            points = DataMatrixReader.NO_POINTS;\r\n        }\r\n        else {\r\n            var detectorResult = new Detector(image.getBlackMatrix()).detect();\r\n            decoderResult = this.decoder.decode(detectorResult.getBits());\r\n            points = detectorResult.getPoints();\r\n        }\r\n        var rawBytes = decoderResult.getRawBytes();\r\n        var result = new Result(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat.DATA_MATRIX, System.currentTimeMillis());\r\n        var byteSegments = decoderResult.getByteSegments();\r\n        if (byteSegments != null) {\r\n            result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);\r\n        }\r\n        var ecLevel = decoderResult.getECLevel();\r\n        if (ecLevel != null) {\r\n            result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);\r\n        }\r\n        return result;\r\n    };\r\n    // @Override\r\n    DataMatrixReader.prototype.reset = function () {\r\n        // do nothing\r\n    };\r\n    /**\r\n     * This method detects a code in a \"pure\" image -- that is, pure monochrome image\r\n     * which contains only an unrotated, unskewed, image of a code, with some white border\r\n     * around it. This is a specialized method that works exceptionally fast in this special\r\n     * case.\r\n     *\r\n     * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)\r\n     */\r\n    DataMatrixReader.extractPureBits = function (image) {\r\n        var leftTopBlack = image.getTopLeftOnBit();\r\n        var rightBottomBlack = image.getBottomRightOnBit();\r\n        if (leftTopBlack == null || rightBottomBlack == null) {\r\n            throw new NotFoundException();\r\n        }\r\n        var moduleSize = this.moduleSize(leftTopBlack, image);\r\n        var top = leftTopBlack[1];\r\n        var bottom = rightBottomBlack[1];\r\n        var left = leftTopBlack[0];\r\n        var right = rightBottomBlack[0];\r\n        var matrixWidth = (right - left + 1) / moduleSize;\r\n        var matrixHeight = (bottom - top + 1) / moduleSize;\r\n        if (matrixWidth <= 0 || matrixHeight <= 0) {\r\n            throw new NotFoundException();\r\n        }\r\n        // Push in the \"border\" by half the module width so that we start\r\n        // sampling in the middle of the module. Just in case the image is a\r\n        // little off, this will help recover.\r\n        var nudge = moduleSize / 2;\r\n        top += nudge;\r\n        left += nudge;\r\n        // Now just read off the bits\r\n        var bits = new BitMatrix(matrixWidth, matrixHeight);\r\n        for (var y = 0; y < matrixHeight; y++) {\r\n            var iOffset = top + y * moduleSize;\r\n            for (var x = 0; x < matrixWidth; x++) {\r\n                if (image.get(left + x * moduleSize, iOffset)) {\r\n                    bits.set(x, y);\r\n                }\r\n            }\r\n        }\r\n        return bits;\r\n    };\r\n    DataMatrixReader.moduleSize = function (leftTopBlack, image) {\r\n        var width = image.getWidth();\r\n        var x = leftTopBlack[0];\r\n        var y = leftTopBlack[1];\r\n        while (x < width && image.get(x, y)) {\r\n            x++;\r\n        }\r\n        if (x === width) {\r\n            throw new NotFoundException();\r\n        }\r\n        var moduleSize = x - leftTopBlack[0];\r\n        if (moduleSize === 0) {\r\n            throw new NotFoundException();\r\n        }\r\n        return moduleSize;\r\n    };\r\n    DataMatrixReader.NO_POINTS = [];\r\n    return DataMatrixReader;\r\n}());\r\nexport default DataMatrixReader;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}