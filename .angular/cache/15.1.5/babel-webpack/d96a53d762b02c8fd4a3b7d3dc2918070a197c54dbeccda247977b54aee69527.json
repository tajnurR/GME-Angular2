{"ast":null,"code":"/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/*namespace com.google.zxing {*/\nimport MathUtils from './common/detector/MathUtils';\nimport Float from './util/Float';\n/**\r\n * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this\r\n * would be the location of a finder pattern or the corner of the barcode, for example.</p>\r\n *\r\n * @author Sean Owen\r\n */\nvar ResultPoint = /** @class */function () {\n  function ResultPoint(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  ResultPoint.prototype.getX = function () {\n    return this.x;\n  };\n  ResultPoint.prototype.getY = function () {\n    return this.y;\n  };\n  /*@Override*/\n  ResultPoint.prototype.equals = function (other) {\n    if (other instanceof ResultPoint) {\n      var otherPoint = other;\n      return this.x === otherPoint.x && this.y === otherPoint.y;\n    }\n    return false;\n  };\n  /*@Override*/\n  ResultPoint.prototype.hashCode = function () {\n    return 31 * Float.floatToIntBits(this.x) + Float.floatToIntBits(this.y);\n  };\n  /*@Override*/\n  ResultPoint.prototype.toString = function () {\n    return '(' + this.x + ',' + this.y + ')';\n  };\n  /**\r\n   * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC\r\n   * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.\r\n   *\r\n   * @param patterns array of three {@code ResultPoint} to order\r\n   */\n  ResultPoint.orderBestPatterns = function (patterns) {\n    // Find distances between pattern centers\n    var zeroOneDistance = this.distance(patterns[0], patterns[1]);\n    var oneTwoDistance = this.distance(patterns[1], patterns[2]);\n    var zeroTwoDistance = this.distance(patterns[0], patterns[2]);\n    var pointA;\n    var pointB;\n    var pointC;\n    // Assume one closest to other two is B; A and C will just be guesses at first\n    if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {\n      pointB = patterns[0];\n      pointA = patterns[1];\n      pointC = patterns[2];\n    } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {\n      pointB = patterns[1];\n      pointA = patterns[0];\n      pointC = patterns[2];\n    } else {\n      pointB = patterns[2];\n      pointA = patterns[0];\n      pointC = patterns[1];\n    }\n    // Use cross product to figure out whether A and C are correct or flipped.\n    // This asks whether BC x BA has a positive z component, which is the arrangement\n    // we want for A, B, C. If it's negative, then we've got it flipped around and\n    // should swap A and C.\n    if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {\n      var temp = pointA;\n      pointA = pointC;\n      pointC = temp;\n    }\n    patterns[0] = pointA;\n    patterns[1] = pointB;\n    patterns[2] = pointC;\n  };\n  /**\r\n   * @param pattern1 first pattern\r\n   * @param pattern2 second pattern\r\n   * @return distance between two points\r\n   */\n  ResultPoint.distance = function (pattern1, pattern2) {\n    return MathUtils.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);\n  };\n  /**\r\n   * Returns the z component of the cross product between vectors BC and BA.\r\n   */\n  ResultPoint.crossProductZ = function (pointA, pointB, pointC) {\n    var bX = pointB.x;\n    var bY = pointB.y;\n    return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);\n  };\n  return ResultPoint;\n}();\nexport default ResultPoint;","map":{"version":3,"names":["MathUtils","Float","ResultPoint","x","y","prototype","getX","getY","equals","other","otherPoint","hashCode","floatToIntBits","toString","orderBestPatterns","patterns","zeroOneDistance","distance","oneTwoDistance","zeroTwoDistance","pointA","pointB","pointC","crossProductZ","temp","pattern1","pattern2","bX","bY"],"sources":["D:/Git/GME-Angular2/node_modules/@zxing/library/esm/core/ResultPoint.js"],"sourcesContent":["/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/*namespace com.google.zxing {*/\r\nimport MathUtils from './common/detector/MathUtils';\r\nimport Float from './util/Float';\r\n/**\r\n * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this\r\n * would be the location of a finder pattern or the corner of the barcode, for example.</p>\r\n *\r\n * @author Sean Owen\r\n */\r\nvar ResultPoint = /** @class */ (function () {\r\n    function ResultPoint(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    ResultPoint.prototype.getX = function () {\r\n        return this.x;\r\n    };\r\n    ResultPoint.prototype.getY = function () {\r\n        return this.y;\r\n    };\r\n    /*@Override*/\r\n    ResultPoint.prototype.equals = function (other) {\r\n        if (other instanceof ResultPoint) {\r\n            var otherPoint = other;\r\n            return this.x === otherPoint.x && this.y === otherPoint.y;\r\n        }\r\n        return false;\r\n    };\r\n    /*@Override*/\r\n    ResultPoint.prototype.hashCode = function () {\r\n        return 31 * Float.floatToIntBits(this.x) + Float.floatToIntBits(this.y);\r\n    };\r\n    /*@Override*/\r\n    ResultPoint.prototype.toString = function () {\r\n        return '(' + this.x + ',' + this.y + ')';\r\n    };\r\n    /**\r\n     * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC\r\n     * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.\r\n     *\r\n     * @param patterns array of three {@code ResultPoint} to order\r\n     */\r\n    ResultPoint.orderBestPatterns = function (patterns) {\r\n        // Find distances between pattern centers\r\n        var zeroOneDistance = this.distance(patterns[0], patterns[1]);\r\n        var oneTwoDistance = this.distance(patterns[1], patterns[2]);\r\n        var zeroTwoDistance = this.distance(patterns[0], patterns[2]);\r\n        var pointA;\r\n        var pointB;\r\n        var pointC;\r\n        // Assume one closest to other two is B; A and C will just be guesses at first\r\n        if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {\r\n            pointB = patterns[0];\r\n            pointA = patterns[1];\r\n            pointC = patterns[2];\r\n        }\r\n        else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {\r\n            pointB = patterns[1];\r\n            pointA = patterns[0];\r\n            pointC = patterns[2];\r\n        }\r\n        else {\r\n            pointB = patterns[2];\r\n            pointA = patterns[0];\r\n            pointC = patterns[1];\r\n        }\r\n        // Use cross product to figure out whether A and C are correct or flipped.\r\n        // This asks whether BC x BA has a positive z component, which is the arrangement\r\n        // we want for A, B, C. If it's negative, then we've got it flipped around and\r\n        // should swap A and C.\r\n        if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {\r\n            var temp = pointA;\r\n            pointA = pointC;\r\n            pointC = temp;\r\n        }\r\n        patterns[0] = pointA;\r\n        patterns[1] = pointB;\r\n        patterns[2] = pointC;\r\n    };\r\n    /**\r\n     * @param pattern1 first pattern\r\n     * @param pattern2 second pattern\r\n     * @return distance between two points\r\n     */\r\n    ResultPoint.distance = function (pattern1, pattern2) {\r\n        return MathUtils.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);\r\n    };\r\n    /**\r\n     * Returns the z component of the cross product between vectors BC and BA.\r\n     */\r\n    ResultPoint.crossProductZ = function (pointA, pointB, pointC) {\r\n        var bX = pointB.x;\r\n        var bY = pointB.y;\r\n        return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));\r\n    };\r\n    return ResultPoint;\r\n}());\r\nexport default ResultPoint;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}