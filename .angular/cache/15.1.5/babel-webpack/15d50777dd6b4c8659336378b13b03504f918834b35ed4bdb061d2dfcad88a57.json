{"ast":null,"code":"/*\r\n * Copyright 2010 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nimport ResultPoint from '../../ResultPoint';\nimport AztecDetectorResult from '../AztecDetectorResult';\nimport MathUtils from '../../common/detector/MathUtils';\nimport WhiteRectangleDetector from '../../common/detector/WhiteRectangleDetector';\nimport GenericGF from '../../common/reedsolomon/GenericGF';\nimport ReedSolomonDecoder from '../../common/reedsolomon/ReedSolomonDecoder';\nimport NotFoundException from '../../NotFoundException';\nimport GridSamplerInstance from '../../common/GridSamplerInstance';\nimport Integer from '../../util/Integer';\nvar Point = /** @class */function () {\n  function Point(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  Point.prototype.toResultPoint = function () {\n    return new ResultPoint(this.getX(), this.getY());\n  };\n  Point.prototype.getX = function () {\n    return this.x;\n  };\n  Point.prototype.getY = function () {\n    return this.y;\n  };\n  return Point;\n}();\nexport { Point };\n/**\r\n * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code\r\n * is rotated or skewed, or partially obscured.\r\n *\r\n * @author David Olivier\r\n * @author Frank Yellin\r\n */\nvar Detector = /** @class */function () {\n  function Detector(image) {\n    this.EXPECTED_CORNER_BITS = new Int32Array([0xee0, 0x1dc, 0x83b, 0x707]);\n    this.image = image;\n  }\n  Detector.prototype.detect = function () {\n    return this.detectMirror(false);\n  };\n  /**\r\n   * Detects an Aztec Code in an image.\r\n   *\r\n   * @param isMirror if true, image is a mirror-image of original\r\n   * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code\r\n   * @throws NotFoundException if no Aztec Code can be found\r\n   */\n  Detector.prototype.detectMirror = function (isMirror) {\n    // 1. Get the center of the aztec matrix\n    var pCenter = this.getMatrixCenter();\n    // 2. Get the center points of the four diagonal points just outside the bull's eye\n    //  [topRight, bottomRight, bottomLeft, topLeft]\n    var bullsEyeCorners = this.getBullsEyeCorners(pCenter);\n    if (isMirror) {\n      var temp = bullsEyeCorners[0];\n      bullsEyeCorners[0] = bullsEyeCorners[2];\n      bullsEyeCorners[2] = temp;\n    }\n    // 3. Get the size of the matrix and other parameters from the bull's eye\n    this.extractParameters(bullsEyeCorners);\n    // 4. Sample the grid\n    var bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);\n    // 5. Get the corners of the matrix.\n    var corners = this.getMatrixCornerPoints(bullsEyeCorners);\n    return new AztecDetectorResult(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);\n  };\n  /**\r\n   * Extracts the number of data layers and data blocks from the layer around the bull's eye.\r\n   *\r\n   * @param bullsEyeCorners the array of bull's eye corners\r\n   * @throws NotFoundException in case of too many errors or invalid parameters\r\n   */\n  Detector.prototype.extractParameters = function (bullsEyeCorners) {\n    if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) || !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {\n      throw new NotFoundException();\n    }\n    var length = 2 * this.nbCenterLayers;\n    // Get the bits around the bull's eye\n    var sides = new Int32Array([this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length), this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length), this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length), this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) // Top\n    ]);\n    // bullsEyeCorners[shift] is the corner of the bulls'eye that has three\n    // orientation marks.\n    // sides[shift] is the row/column that goes from the corner with three\n    // orientation marks to the corner with two.\n    this.shift = this.getRotation(sides, length);\n    // Flatten the parameter bits into a single 28- or 40-bit long\n    var parameterData = 0;\n    for (var i = 0; i < 4; i++) {\n      var side = sides[(this.shift + i) % 4];\n      if (this.compact) {\n        // Each side of the form ..XXXXXXX. where Xs are parameter data\n        parameterData <<= 7;\n        parameterData += side >> 1 & 0x7F;\n      } else {\n        // Each side of the form ..XXXXX.XXXXX. where Xs are parameter data\n        parameterData <<= 10;\n        parameterData += (side >> 2 & 0x1f << 5) + (side >> 1 & 0x1F);\n      }\n    }\n    // Corrects parameter data using RS.  Returns just the data portion\n    // without the error correction.\n    var correctedData = this.getCorrectedParameterData(parameterData, this.compact);\n    if (this.compact) {\n      // 8 bits:  2 bits layers and 6 bits data blocks\n      this.nbLayers = (correctedData >> 6) + 1;\n      this.nbDataBlocks = (correctedData & 0x3F) + 1;\n    } else {\n      // 16 bits:  5 bits layers and 11 bits data blocks\n      this.nbLayers = (correctedData >> 11) + 1;\n      this.nbDataBlocks = (correctedData & 0x7FF) + 1;\n    }\n  };\n  Detector.prototype.getRotation = function (sides, length) {\n    // In a normal pattern, we expect to See\n    //   **    .*             D       A\n    //   *      *\n    //\n    //   .      *\n    //   ..    ..             C       B\n    //\n    // Grab the 3 bits from each of the sides the form the locator pattern and concatenate\n    // into a 12-bit integer.  Start with the bit at A\n    var cornerBits = 0;\n    sides.forEach(function (side, idx, arr) {\n      // XX......X where X's are orientation marks\n      var t = (side >> length - 2 << 1) + (side & 1);\n      cornerBits = (cornerBits << 3) + t;\n    });\n    // for (var side in sides) {\n    //     // XX......X where X's are orientation marks\n    //     var t = ((side >> (length - 2)) << 1) + (side & 1);\n    //     cornerBits = (cornerBits << 3) + t;\n    // }\n    // Mov the bottom bit to the top, so that the three bits of the locator pattern at A are\n    // together.  cornerBits is now:\n    //  3 orientation bits at A || 3 orientation bits at B || ... || 3 orientation bits at D\n    cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);\n    // The result shift indicates which element of BullsEyeCorners[] goes into the top-left\n    // corner. Since the four rotation values have a Hamming distance of 8, we\n    // can easily tolerate two errors.\n    for (var shift = 0; shift < 4; shift++) {\n      if (Integer.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {\n        return shift;\n      }\n    }\n    throw new NotFoundException();\n  };\n  /**\r\n   * Corrects the parameter bits using Reed-Solomon algorithm.\r\n   *\r\n   * @param parameterData parameter bits\r\n   * @param compact true if this is a compact Aztec code\r\n   * @throws NotFoundException if the array contains too many errors\r\n   */\n  Detector.prototype.getCorrectedParameterData = function (parameterData, compact) {\n    var numCodewords;\n    var numDataCodewords;\n    if (compact) {\n      numCodewords = 7;\n      numDataCodewords = 2;\n    } else {\n      numCodewords = 10;\n      numDataCodewords = 4;\n    }\n    var numECCodewords = numCodewords - numDataCodewords;\n    var parameterWords = new Int32Array(numCodewords);\n    for (var i = numCodewords - 1; i >= 0; --i) {\n      parameterWords[i] = parameterData & 0xF;\n      parameterData >>= 4;\n    }\n    try {\n      var rsDecoder = new ReedSolomonDecoder(GenericGF.AZTEC_PARAM);\n      rsDecoder.decode(parameterWords, numECCodewords);\n    } catch (ignored) {\n      throw new NotFoundException();\n    }\n    // Toss the error correction.  Just return the data as an integer\n    var result = 0;\n    for (var i = 0; i < numDataCodewords; i++) {\n      result = (result << 4) + parameterWords[i];\n    }\n    return result;\n  };\n  /**\r\n   * Finds the corners of a bull-eye centered on the passed point.\r\n   * This returns the centers of the diagonal points just outside the bull's eye\r\n   * Returns [topRight, bottomRight, bottomLeft, topLeft]\r\n   *\r\n   * @param pCenter Center point\r\n   * @return The corners of the bull-eye\r\n   * @throws NotFoundException If no valid bull-eye can be found\r\n   */\n  Detector.prototype.getBullsEyeCorners = function (pCenter) {\n    var pina = pCenter;\n    var pinb = pCenter;\n    var pinc = pCenter;\n    var pind = pCenter;\n    var color = true;\n    for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {\n      var pouta = this.getFirstDifferent(pina, color, 1, -1);\n      var poutb = this.getFirstDifferent(pinb, color, 1, 1);\n      var poutc = this.getFirstDifferent(pinc, color, -1, 1);\n      var poutd = this.getFirstDifferent(pind, color, -1, -1);\n      // d      a\n      //\n      // c      b\n      if (this.nbCenterLayers > 2) {\n        var q = this.distancePoint(poutd, pouta) * this.nbCenterLayers / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));\n        if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {\n          break;\n        }\n      }\n      pina = pouta;\n      pinb = poutb;\n      pinc = poutc;\n      pind = poutd;\n      color = !color;\n    }\n    if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {\n      throw new NotFoundException();\n    }\n    this.compact = this.nbCenterLayers === 5;\n    // Expand the square by .5 pixel in each direction so that we're on the border\n    // between the white square and the black square\n    var pinax = new ResultPoint(pina.getX() + 0.5, pina.getY() - 0.5);\n    var pinbx = new ResultPoint(pinb.getX() + 0.5, pinb.getY() + 0.5);\n    var pincx = new ResultPoint(pinc.getX() - 0.5, pinc.getY() + 0.5);\n    var pindx = new ResultPoint(pind.getX() - 0.5, pind.getY() - 0.5);\n    // Expand the square so that its corners are the centers of the points\n    // just outside the bull's eye.\n    return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);\n  };\n  /**\r\n   * Finds a candidate center point of an Aztec code from an image\r\n   *\r\n   * @return the center point\r\n   */\n  Detector.prototype.getMatrixCenter = function () {\n    var pointA;\n    var pointB;\n    var pointC;\n    var pointD;\n    // Get a white rectangle that can be the border of the matrix in center bull's eye or\n    try {\n      var cornerPoints = new WhiteRectangleDetector(this.image).detect();\n      pointA = cornerPoints[0];\n      pointB = cornerPoints[1];\n      pointC = cornerPoints[2];\n      pointD = cornerPoints[3];\n    } catch (e) {\n      // This exception can be in case the initial rectangle is white\n      // In that case, surely in the bull's eye, we try to expand the rectangle.\n      var cx_1 = this.image.getWidth() / 2;\n      var cy_1 = this.image.getHeight() / 2;\n      pointA = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 - 7), false, 1, -1).toResultPoint();\n      pointB = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 + 7), false, 1, 1).toResultPoint();\n      pointC = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 + 7), false, -1, 1).toResultPoint();\n      pointD = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 - 7), false, -1, -1).toResultPoint();\n    }\n    // Compute the center of the rectangle\n    var cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n    var cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n    // Redetermine the white rectangle starting from previously computed center.\n    // This will ensure that we end up with a white rectangle in center bull's eye\n    // in order to compute a more accurate center.\n    try {\n      var cornerPoints = new WhiteRectangleDetector(this.image, 15, cx, cy).detect();\n      pointA = cornerPoints[0];\n      pointB = cornerPoints[1];\n      pointC = cornerPoints[2];\n      pointD = cornerPoints[3];\n    } catch (e) {\n      // This exception can be in case the initial rectangle is white\n      // In that case we try to expand the rectangle.\n      pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n      pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n      pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n      pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n    }\n    // Recompute the center of the rectangle\n    cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n    cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n    return new Point(cx, cy);\n  };\n  /**\r\n   * Gets the Aztec code corners from the bull's eye corners and the parameters.\r\n   *\r\n   * @param bullsEyeCorners the array of bull's eye corners\r\n   * @return the array of aztec code corners\r\n   */\n  Detector.prototype.getMatrixCornerPoints = function (bullsEyeCorners) {\n    return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());\n  };\n  /**\r\n   * Creates a BitMatrix by sampling the provided image.\r\n   * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the\r\n   * diagonal just outside the bull's eye.\r\n   */\n  Detector.prototype.sampleGrid = function (image, topLeft, topRight, bottomRight, bottomLeft) {\n    var sampler = GridSamplerInstance.getInstance();\n    var dimension = this.getDimension();\n    var low = dimension / 2 - this.nbCenterLayers;\n    var high = dimension / 2 + this.nbCenterLayers;\n    return sampler.sampleGrid(image, dimension, dimension, low, low,\n    // topleft\n    high, low,\n    // topright\n    high, high,\n    // bottomright\n    low, high,\n    // bottomleft\n    topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n  };\n  /**\r\n   * Samples a line.\r\n   *\r\n   * @param p1   start point (inclusive)\r\n   * @param p2   end point (exclusive)\r\n   * @param size number of bits\r\n   * @return the array of bits as an int (first bit is high-order bit of result)\r\n   */\n  Detector.prototype.sampleLine = function (p1, p2, size) {\n    var result = 0;\n    var d = this.distanceResultPoint(p1, p2);\n    var moduleSize = d / size;\n    var px = p1.getX();\n    var py = p1.getY();\n    var dx = moduleSize * (p2.getX() - p1.getX()) / d;\n    var dy = moduleSize * (p2.getY() - p1.getY()) / d;\n    for (var i = 0; i < size; i++) {\n      if (this.image.get(MathUtils.round(px + i * dx), MathUtils.round(py + i * dy))) {\n        result |= 1 << size - i - 1;\n      }\n    }\n    return result;\n  };\n  /**\r\n   * @return true if the border of the rectangle passed in parameter is compound of white points only\r\n   *         or black points only\r\n   */\n  Detector.prototype.isWhiteOrBlackRectangle = function (p1, p2, p3, p4) {\n    var corr = 3;\n    p1 = new Point(p1.getX() - corr, p1.getY() + corr);\n    p2 = new Point(p2.getX() - corr, p2.getY() - corr);\n    p3 = new Point(p3.getX() + corr, p3.getY() - corr);\n    p4 = new Point(p4.getX() + corr, p4.getY() + corr);\n    var cInit = this.getColor(p4, p1);\n    if (cInit === 0) {\n      return false;\n    }\n    var c = this.getColor(p1, p2);\n    if (c !== cInit) {\n      return false;\n    }\n    c = this.getColor(p2, p3);\n    if (c !== cInit) {\n      return false;\n    }\n    c = this.getColor(p3, p4);\n    return c === cInit;\n  };\n  /**\r\n   * Gets the color of a segment\r\n   *\r\n   * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else\r\n   */\n  Detector.prototype.getColor = function (p1, p2) {\n    var d = this.distancePoint(p1, p2);\n    var dx = (p2.getX() - p1.getX()) / d;\n    var dy = (p2.getY() - p1.getY()) / d;\n    var error = 0;\n    var px = p1.getX();\n    var py = p1.getY();\n    var colorModel = this.image.get(p1.getX(), p1.getY());\n    var iMax = Math.ceil(d);\n    for (var i = 0; i < iMax; i++) {\n      px += dx;\n      py += dy;\n      if (this.image.get(MathUtils.round(px), MathUtils.round(py)) !== colorModel) {\n        error++;\n      }\n    }\n    var errRatio = error / d;\n    if (errRatio > 0.1 && errRatio < 0.9) {\n      return 0;\n    }\n    return errRatio <= 0.1 === colorModel ? 1 : -1;\n  };\n  /**\r\n   * Gets the coordinate of the first point with a different color in the given direction\r\n   */\n  Detector.prototype.getFirstDifferent = function (init, color, dx, dy) {\n    var x = init.getX() + dx;\n    var y = init.getY() + dy;\n    while (this.isValid(x, y) && this.image.get(x, y) === color) {\n      x += dx;\n      y += dy;\n    }\n    x -= dx;\n    y -= dy;\n    while (this.isValid(x, y) && this.image.get(x, y) === color) {\n      x += dx;\n    }\n    x -= dx;\n    while (this.isValid(x, y) && this.image.get(x, y) === color) {\n      y += dy;\n    }\n    y -= dy;\n    return new Point(x, y);\n  };\n  /**\r\n   * Expand the square represented by the corner points by pushing out equally in all directions\r\n   *\r\n   * @param cornerPoints the corners of the square, which has the bull's eye at its center\r\n   * @param oldSide the original length of the side of the square in the target bit matrix\r\n   * @param newSide the new length of the size of the square in the target bit matrix\r\n   * @return the corners of the expanded square\r\n   */\n  Detector.prototype.expandSquare = function (cornerPoints, oldSide, newSide) {\n    var ratio = newSide / (2.0 * oldSide);\n    var dx = cornerPoints[0].getX() - cornerPoints[2].getX();\n    var dy = cornerPoints[0].getY() - cornerPoints[2].getY();\n    var centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0;\n    var centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0;\n    var result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);\n    var result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);\n    dx = cornerPoints[1].getX() - cornerPoints[3].getX();\n    dy = cornerPoints[1].getY() - cornerPoints[3].getY();\n    centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0;\n    centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0;\n    var result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);\n    var result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);\n    var results = [result0, result1, result2, result3];\n    return results;\n  };\n  Detector.prototype.isValid = function (x, y) {\n    return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();\n  };\n  Detector.prototype.isValidPoint = function (point) {\n    var x = MathUtils.round(point.getX());\n    var y = MathUtils.round(point.getY());\n    return this.isValid(x, y);\n  };\n  Detector.prototype.distancePoint = function (a, b) {\n    return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());\n  };\n  Detector.prototype.distanceResultPoint = function (a, b) {\n    return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());\n  };\n  Detector.prototype.getDimension = function () {\n    if (this.compact) {\n      return 4 * this.nbLayers + 11;\n    }\n    if (this.nbLayers <= 4) {\n      return 4 * this.nbLayers + 15;\n    }\n    return 4 * this.nbLayers + 2 * (Integer.truncDivision(this.nbLayers - 4, 8) + 1) + 15;\n  };\n  return Detector;\n}();\nexport default Detector;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}