{"ast":null,"code":"import _asyncToGenerator from \"E:/GME/Angular/GME-Angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewChild, Input, Output, NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { BrowserMultiFormatReader, BrowserCodeReader } from '@zxing/browser';\nimport { NotFoundException, ChecksumException, FormatException, BarcodeFormat, DecodeHintType } from '@zxing/library';\nimport { BehaviorSubject } from 'rxjs';\n\n/**\n * Based on zxing-typescript BrowserCodeReader\n */\nconst _c0 = [\"preview\"];\nclass BrowserMultiFormatContinuousReader extends BrowserMultiFormatReader {\n  /**\n   * Returns the code reader scanner controls.\n   */\n  getScannerControls() {\n    if (!this.scannerControls) {\n      throw new Error('No scanning is running at the time.');\n    }\n    return this.scannerControls;\n  }\n  /**\n   * Starts the decoding from the current or a new video element.\n   *\n   * @param deviceId The device's to be used Id\n   * @param previewEl A new video element\n   */\n  scanFromDeviceObservable(deviceId, previewEl) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const scan$ = new BehaviorSubject({});\n      let ctrls;\n      try {\n        ctrls = yield _this.decodeFromVideoDevice(deviceId, previewEl, (result, error) => {\n          if (!error) {\n            scan$.next({\n              result\n            });\n            return;\n          }\n          const errorName = error.name;\n          // stream cannot stop on fails.\n          if (\n          // scan Failure - found nothing, no error\n          errorName === NotFoundException.name ||\n          // scan Error - found the QR but got error on decoding\n          errorName === ChecksumException.name || errorName === FormatException.name || error.message.includes('No MultiFormat Readers were able to detect the code.')) {\n            scan$.next({\n              error\n            });\n            return;\n          }\n          // probably fatal error\n          scan$.error(error);\n          _this.scannerControls.stop();\n          _this.scannerControls = undefined;\n          return;\n        });\n        _this.scannerControls = {\n          ...ctrls,\n          stop() {\n            ctrls.stop();\n            scan$.complete();\n          }\n        };\n      } catch (e) {\n        scan$.error(e);\n        _this.scannerControls?.stop();\n        _this.scannerControls = undefined;\n      }\n      return scan$.asObservable();\n    })();\n  }\n}\nclass ZXingScannerComponent {\n  /**\n   * Constructor to build the object and do some DI.\n   */\n  constructor() {\n    /**\n     * Delay between attempts to decode (default is 500ms)\n     */\n    this.timeBetweenScans = 500;\n    /**\n     * Delay between successful decode (default is 500ms)\n     */\n    this.delayBetweenScanSuccess = 500;\n    /**\n     * How the preview element should be fit inside the :host container.\n     */\n    this.previewFitMode = 'cover';\n    this._ready = false;\n    // instance based emitters\n    this.autostarted = new EventEmitter();\n    this.autostarting = new EventEmitter();\n    this.torchCompatible = new EventEmitter(false);\n    this.scanSuccess = new EventEmitter();\n    this.scanFailure = new EventEmitter();\n    this.scanError = new EventEmitter();\n    this.scanComplete = new EventEmitter();\n    this.camerasFound = new EventEmitter();\n    this.camerasNotFound = new EventEmitter();\n    this.permissionResponse = new EventEmitter(true);\n    this.hasDevices = new EventEmitter();\n    this.deviceChange = new EventEmitter();\n    this._enabled = true;\n    this._hints = new Map();\n    this.autofocusEnabled = true;\n    this.autostart = true;\n    this.formats = [BarcodeFormat.QR_CODE];\n    // computed data\n    this.hasNavigator = typeof navigator !== 'undefined';\n    this.isMediaDevicesSupported = this.hasNavigator && !!navigator.mediaDevices;\n  }\n  /**\n   * Exposes the current code reader, so the user can use it's APIs.\n   */\n  get codeReader() {\n    return this._codeReader;\n  }\n  /**\n   * User device input\n   */\n  set device(device) {\n    if (!this._ready) {\n      this._devicePreStart = device;\n      // let's ignore silently, users don't like logs\n      return;\n    }\n    if (this.isAutostarting) {\n      // do not allow setting devices during auto-start, since it will set one and emit it.\n      console.warn('Avoid setting a device during auto-start.');\n      return;\n    }\n    if (this.isCurrentDevice(device)) {\n      console.warn('Setting the same device is not allowed.');\n      return;\n    }\n    if (!this.hasPermission) {\n      console.warn('Permissions not set yet, waiting for them to be set to apply device change.');\n      // this.permissionResponse\n      //   .pipe(\n      //     take(1),\n      //     tap(() => console.log(`Permissions set, applying device change${device ? ` (${device.deviceId})` : ''}.`))\n      //   )\n      //   .subscribe(() => this.device = device);\n      return;\n    }\n    this.setDevice(device);\n  }\n  /**\n   * User device accessor.\n   */\n  get device() {\n    return this._device;\n  }\n  /**\n   * Returns all the registered formats.\n   */\n  get formats() {\n    return this.hints.get(DecodeHintType.POSSIBLE_FORMATS);\n  }\n  /**\n   * Registers formats the scanner should support.\n   *\n   * @param input BarcodeFormat or case-insensitive string array.\n   */\n  set formats(input) {\n    if (typeof input === 'string') {\n      throw new Error('Invalid formats, make sure the [formats] input is a binding.');\n    }\n    // formats may be set from html template as BarcodeFormat or string array\n    const formats = input.map(f => this.getBarcodeFormatOrFail(f));\n    const hints = this.hints;\n    // updates the hints\n    hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);\n    // handles updating the codeReader\n    this.hints = hints;\n  }\n  /**\n   * Returns all the registered hints.\n   */\n  get hints() {\n    return this._hints;\n  }\n  /**\n   * Does what it takes to set the hints.\n   */\n  set hints(hints) {\n    this._hints = hints;\n    // new instance with new hints.\n    this.codeReader?.setHints(this._hints);\n  }\n  /**\n   * Sets the desired constraints in all video tracks.\n   * @experimental\n   */\n  set videoConstraints(constraints) {\n    // new instance with new hints.\n    const controls = this.codeReader?.getScannerControls();\n    if (!controls) {\n      // fails silently\n      return;\n    }\n    controls?.streamVideoConstraintsApply(constraints);\n  }\n  /**\n   *\n   */\n  set isAutostarting(state) {\n    this._isAutostarting = state;\n    this.autostarting.next(state);\n  }\n  /**\n   *\n   */\n  get isAutostarting() {\n    return this._isAutostarting;\n  }\n  /**\n   * Can turn on/off the device flashlight.\n   *\n   * @experimental Torch/Flash APIs are not stable in all browsers, it may be buggy!\n   */\n  set torch(onOff) {\n    try {\n      const controls = this.getCodeReader().getScannerControls();\n      controls.switchTorch(onOff);\n    } catch (error) {\n      // ignore error\n    }\n  }\n  /**\n   * Starts and Stops the scanning.\n   */\n  set enable(enabled) {\n    this._enabled = Boolean(enabled);\n    if (!this._enabled) {\n      this.reset();\n      BrowserMultiFormatContinuousReader.releaseAllStreams();\n    } else {\n      if (this.device) {\n        this.scanFromDevice(this.device.deviceId);\n      } else {\n        this.init();\n      }\n    }\n  }\n  /**\n   * Tells if the scanner is enabled or not.\n   */\n  get enabled() {\n    return this._enabled;\n  }\n  /**\n   * If is `tryHarder` enabled.\n   */\n  get tryHarder() {\n    return this.hints.get(DecodeHintType.TRY_HARDER);\n  }\n  /**\n   * Enable/disable tryHarder hint.\n   */\n  set tryHarder(enable) {\n    const hints = this.hints;\n    if (enable) {\n      hints.set(DecodeHintType.TRY_HARDER, true);\n    } else {\n      hints.delete(DecodeHintType.TRY_HARDER);\n    }\n    this.hints = hints;\n  }\n  /**\n   * Gets and registers all cameras.\n   */\n  askForPermission() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this2.hasNavigator) {\n        console.error('@zxing/ngx-scanner', 'Can\\'t ask permission, navigator is not present.');\n        _this2.setPermission(null);\n        return _this2.hasPermission;\n      }\n      if (!_this2.isMediaDevicesSupported) {\n        console.error('@zxing/ngx-scanner', 'Can\\'t get user media, this is not supported.');\n        _this2.setPermission(null);\n        return _this2.hasPermission;\n      }\n      let stream;\n      let permission;\n      try {\n        // Will try to ask for permission\n        stream = yield _this2.getAnyVideoDevice();\n        permission = !!stream;\n      } catch (err) {\n        return _this2.handlePermissionException(err);\n      } finally {\n        _this2.terminateStream(stream);\n      }\n      _this2.setPermission(permission);\n      // Returns the permission\n      return permission;\n    })();\n  }\n  /**\n   *\n   */\n  getAnyVideoDevice() {\n    return navigator.mediaDevices.getUserMedia({\n      video: true\n    });\n  }\n  /**\n   * Terminates a stream and it's tracks.\n   */\n  terminateStream(stream) {\n    if (stream) {\n      stream.getTracks().forEach(t => t.stop());\n    }\n    stream = undefined;\n  }\n  init() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this3.autostart) {\n        console.warn('Feature \\'autostart\\' disabled. Permissions and devices recovery has to be run manually.');\n        // does the necessary configuration without autostarting\n        _this3.initAutostartOff();\n        _this3._ready = true;\n        return;\n      }\n      // configures the component and starts the scanner\n      yield _this3.initAutostartOn();\n      _this3._ready = true;\n    })();\n  }\n  /**\n   * Initializes the component without starting the scanner.\n   */\n  initAutostartOff() {\n    // do not ask for permission when autostart is off\n    this.isAutostarting = false;\n    // just update devices information\n    this.updateVideoInputDevices();\n    if (this._device && this._devicePreStart) {\n      this.setDevice(this._devicePreStart);\n    }\n  }\n  /**\n   * Initializes the component and starts the scanner.\n   * Permissions are asked to accomplish that.\n   */\n  initAutostartOn() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      _this4.isAutostarting = true;\n      let hasPermission;\n      try {\n        // Asks for permission before enumerating devices so it can get all the device's info\n        hasPermission = yield _this4.askForPermission();\n      } catch (e) {\n        console.error('Exception occurred while asking for permission:', e);\n        return;\n      }\n      // from this point, things gonna need permissions\n      if (hasPermission) {\n        const devices = yield _this4.updateVideoInputDevices();\n        yield _this4.autostartScanner([...devices]);\n      }\n      _this4.isAutostarting = false;\n      _this4.autostarted.next();\n    })();\n  }\n  /**\n   * Checks if the given device is the current defined one.\n   */\n  isCurrentDevice(device) {\n    return device?.deviceId === this._device?.deviceId;\n  }\n  /**\n   * Executes some actions before destroy the component.\n   */\n  ngOnDestroy() {\n    this.reset();\n    BrowserMultiFormatContinuousReader.releaseAllStreams();\n  }\n  /**\n   *\n   */\n  ngOnInit() {\n    this.init();\n  }\n  /**\n   * Stops the scanning, if any.\n   */\n  scanStop() {\n    if (this._scanSubscription) {\n      this.codeReader?.getScannerControls().stop();\n      this._scanSubscription?.unsubscribe();\n      this._scanSubscription = undefined;\n    }\n    this.torchCompatible.next(false);\n  }\n  /**\n   * Stops the scanning, if any.\n   */\n  scanStart() {\n    if (this._scanSubscription) {\n      throw new Error('There is already a scan process running.');\n    }\n    if (!this._device) {\n      throw new Error('No device defined, cannot start scan, please define a device.');\n    }\n    this.scanFromDevice(this._device.deviceId);\n  }\n  /**\n   * Stops old `codeReader` and starts scanning in a new one.\n   */\n  restart() {\n    // note only necessary for now because of the Torch\n    this._codeReader = undefined;\n    const prevDevice = this._reset();\n    if (!prevDevice) {\n      return;\n    }\n    this.device = prevDevice;\n  }\n  /**\n   * Discovers and updates known video input devices.\n   */\n  updateVideoInputDevices() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      // permissions aren't needed to get devices, but to access them and their info\n      const devices = (yield BrowserCodeReader.listVideoInputDevices()) || [];\n      const hasDevices = devices && devices.length > 0;\n      // stores discovered devices and updates information\n      _this5.hasDevices.next(hasDevices);\n      _this5.camerasFound.next([...devices]);\n      if (!hasDevices) {\n        _this5.camerasNotFound.next(null);\n      }\n      return devices;\n    })();\n  }\n  /**\n   * Starts the scanner with the back camera otherwise take the last\n   * available device.\n   */\n  autostartScanner(devices) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const matcher = ({\n        label\n      }) => /back|trás|rear|traseira|environment|ambiente/gi.test(label);\n      // select the rear camera by default, otherwise take the last camera.\n      const device = devices.find(matcher) || devices.pop();\n      if (!device) {\n        throw new Error('Impossible to autostart, no input devices available.');\n      }\n      yield _this6.setDevice(device);\n      _this6.deviceChange.next(device);\n    })();\n  }\n  /**\n   * Dispatches the scan success event.\n   *\n   * @param result the scan result.\n   */\n  dispatchScanSuccess(result) {\n    this.scanSuccess.next(result.getText());\n  }\n  /**\n   * Dispatches the scan failure event.\n   */\n  dispatchScanFailure(reason) {\n    this.scanFailure.next(reason);\n  }\n  /**\n   * Dispatches the scan error event.\n   *\n   * @param error the error thing.\n   */\n  dispatchScanError(error) {\n    if (!this.scanError.observed) {\n      console.error(`zxing scanner component: ${error.name}`, error);\n      console.warn('Use the `(scanError)` property to handle errors like this!');\n    }\n    this.scanError.next(error);\n  }\n  /**\n   * Dispatches the scan event.\n   *\n   * @param result the scan result.\n   */\n  dispatchScanComplete(result) {\n    this.scanComplete.next(result);\n  }\n  /**\n   * Returns the filtered permission.\n   */\n  handlePermissionException(err) {\n    // failed to grant permission to video input\n    console.error('@zxing/ngx-scanner', 'Error when asking for permission.', err);\n    let permission;\n    switch (err.name) {\n      // usually caused by not secure origins\n      case 'NotSupportedError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // could not claim\n        permission = null;\n        // can't check devices\n        this.hasDevices.next(null);\n        break;\n      // user denied permission\n      case 'NotAllowedError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // claimed and denied permission\n        permission = false;\n        // this means that input devices exists\n        this.hasDevices.next(true);\n        break;\n      // the device has no attached input devices\n      case 'NotFoundError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // no permissions claimed\n        permission = null;\n        // because there was no devices\n        this.hasDevices.next(false);\n        // tells the listener about the error\n        this.camerasNotFound.next(err);\n        break;\n      case 'NotReadableError':\n        console.warn('@zxing/ngx-scanner', 'Couldn\\'t read the device(s)\\'s stream, it\\'s probably in use by another app.');\n        // no permissions claimed\n        permission = null;\n        // there are devices, which I couldn't use\n        this.hasDevices.next(false);\n        // tells the listener about the error\n        this.camerasNotFound.next(err);\n        break;\n      default:\n        console.warn('@zxing/ngx-scanner', 'I was not able to define if I have permissions for camera or not.', err);\n        // unknown\n        permission = null;\n        // this.hasDevices.next(undefined;\n        break;\n    }\n    this.setPermission(permission);\n    // tells the listener about the error\n    this.permissionResponse.error(err);\n    return permission;\n  }\n  /**\n   * Returns a valid BarcodeFormat or fails.\n   */\n  getBarcodeFormatOrFail(format) {\n    return typeof format === 'string' ? BarcodeFormat[format.trim().toUpperCase()] : format;\n  }\n  /**\n   * Return a code reader, create one if non exist\n   */\n  getCodeReader() {\n    if (!this._codeReader) {\n      const options = {\n        delayBetweenScanAttempts: this.timeBetweenScans,\n        delayBetweenScanSuccess: this.delayBetweenScanSuccess\n      };\n      this._codeReader = new BrowserMultiFormatContinuousReader(this.hints, options);\n    }\n    return this._codeReader;\n  }\n  /**\n   * Starts the continuous scanning for the given device.\n   *\n   * @param deviceId The deviceId from the device.\n   */\n  scanFromDevice(deviceId) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const videoElement = _this7.previewElemRef.nativeElement;\n      const codeReader = _this7.getCodeReader();\n      const scanStream = yield codeReader.scanFromDeviceObservable(deviceId, videoElement);\n      if (!scanStream) {\n        throw new Error('Undefined decoding stream, aborting.');\n      }\n      const next = x => _this7._onDecodeResult(x.result, x.error);\n      const error = err => _this7._onDecodeError(err);\n      const complete = () => {};\n      _this7._scanSubscription = scanStream.subscribe(next, error, complete);\n      if (_this7._scanSubscription.closed) {\n        return;\n      }\n      const controls = codeReader.getScannerControls();\n      const hasTorchControl = typeof controls.switchTorch !== 'undefined';\n      _this7.torchCompatible.next(hasTorchControl);\n    })();\n  }\n  /**\n   * Handles decode errors.\n   */\n  _onDecodeError(err) {\n    this.dispatchScanError(err);\n    // this.reset();\n  }\n  /**\n   * Handles decode results.\n   */\n  _onDecodeResult(result, error) {\n    if (result) {\n      this.dispatchScanSuccess(result);\n    } else {\n      this.dispatchScanFailure(error);\n    }\n    this.dispatchScanComplete(result);\n  }\n  /**\n   * Stops the code reader and returns the previous selected device.\n   */\n  _reset() {\n    if (!this._codeReader) {\n      return;\n    }\n    const device = this._device;\n    // do not set this.device inside this method, it would create a recursive loop\n    this.device = undefined;\n    this._codeReader = undefined;\n    return device;\n  }\n  /**\n   * Resets the scanner and emits device change.\n   */\n  reset() {\n    this._reset();\n    this.deviceChange.emit(null);\n  }\n  /**\n   * Sets the current device.\n   */\n  setDevice(device) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      // instantly stops the scan before changing devices\n      _this8.scanStop();\n      // correctly sets the new (or none) device\n      _this8._device = device || undefined;\n      if (!_this8._device) {\n        // cleans the video because user removed the device\n        BrowserCodeReader.cleanVideoSource(_this8.previewElemRef.nativeElement);\n      }\n      // if enabled, starts scanning\n      if (_this8._enabled && device) {\n        yield _this8.scanFromDevice(device.deviceId);\n      }\n    })();\n  }\n  /**\n   * Sets the permission value and emits the event.\n   */\n  setPermission(hasPermission) {\n    this.hasPermission = hasPermission;\n    this.permissionResponse.next(hasPermission);\n  }\n}\nZXingScannerComponent.ɵfac = function ZXingScannerComponent_Factory(t) {\n  return new (t || ZXingScannerComponent)();\n};\nZXingScannerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: ZXingScannerComponent,\n  selectors: [[\"zxing-scanner\"]],\n  viewQuery: function ZXingScannerComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 7);\n    }\n    if (rf & 2) {\n      let _t;\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.previewElemRef = _t.first);\n    }\n  },\n  inputs: {\n    autofocusEnabled: \"autofocusEnabled\",\n    timeBetweenScans: \"timeBetweenScans\",\n    delayBetweenScanSuccess: \"delayBetweenScanSuccess\",\n    autostart: \"autostart\",\n    previewFitMode: \"previewFitMode\",\n    device: \"device\",\n    formats: \"formats\",\n    videoConstraints: \"videoConstraints\",\n    torch: \"torch\",\n    enable: \"enable\",\n    tryHarder: \"tryHarder\"\n  },\n  outputs: {\n    autostarted: \"autostarted\",\n    autostarting: \"autostarting\",\n    torchCompatible: \"torchCompatible\",\n    scanSuccess: \"scanSuccess\",\n    scanFailure: \"scanFailure\",\n    scanError: \"scanError\",\n    scanComplete: \"scanComplete\",\n    camerasFound: \"camerasFound\",\n    camerasNotFound: \"camerasNotFound\",\n    permissionResponse: \"permissionResponse\",\n    hasDevices: \"hasDevices\",\n    deviceChange: \"deviceChange\"\n  },\n  decls: 6,\n  vars: 2,\n  consts: [[\"preview\", \"\"]],\n  template: function ZXingScannerComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"video\", null, 0)(2, \"p\");\n      i0.ɵɵtext(3, \" Your browser does not support this feature, please try to upgrade it. \");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(4, \"p\");\n      i0.ɵɵtext(5, \" Seu navegador n\\xE3o suporta este recurso, por favor tente atualiz\\xE1-lo. \");\n      i0.ɵɵelementEnd()();\n    }\n    if (rf & 2) {\n      i0.ɵɵstyleProp(\"object-fit\", ctx.previewFitMode);\n    }\n  },\n  styles: [\"[_nghost-%COMP%]{display:block}video[_ngcontent-%COMP%]{width:100%;height:auto;object-fit:contain}\"],\n  changeDetection: 0\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ZXingScannerComponent, [{\n    type: Component,\n    args: [{\n      selector: 'zxing-scanner',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: \"<video #preview [style.object-fit]=\\\"previewFitMode\\\">\\n  <p>\\n    Your browser does not support this feature, please try to upgrade it.\\n  </p>\\n  <p>\\n    Seu navegador n\\u00E3o suporta este recurso, por favor tente atualiz\\u00E1-lo.\\n  </p>\\n</video>\\n\",\n      styles: [\":host{display:block}video{width:100%;height:auto;object-fit:contain}\\n\"]\n    }]\n  }], function () {\n    return [];\n  }, {\n    previewElemRef: [{\n      type: ViewChild,\n      args: ['preview', {\n        static: true\n      }]\n    }],\n    autofocusEnabled: [{\n      type: Input\n    }],\n    timeBetweenScans: [{\n      type: Input\n    }],\n    delayBetweenScanSuccess: [{\n      type: Input\n    }],\n    autostarted: [{\n      type: Output\n    }],\n    autostarting: [{\n      type: Output\n    }],\n    autostart: [{\n      type: Input\n    }],\n    previewFitMode: [{\n      type: Input\n    }],\n    torchCompatible: [{\n      type: Output\n    }],\n    scanSuccess: [{\n      type: Output\n    }],\n    scanFailure: [{\n      type: Output\n    }],\n    scanError: [{\n      type: Output\n    }],\n    scanComplete: [{\n      type: Output\n    }],\n    camerasFound: [{\n      type: Output\n    }],\n    camerasNotFound: [{\n      type: Output\n    }],\n    permissionResponse: [{\n      type: Output\n    }],\n    hasDevices: [{\n      type: Output\n    }],\n    device: [{\n      type: Input\n    }],\n    deviceChange: [{\n      type: Output\n    }],\n    formats: [{\n      type: Input\n    }],\n    videoConstraints: [{\n      type: Input\n    }],\n    torch: [{\n      type: Input\n    }],\n    enable: [{\n      type: Input\n    }],\n    tryHarder: [{\n      type: Input\n    }]\n  });\n})();\nclass ZXingScannerModule {}\nZXingScannerModule.ɵfac = function ZXingScannerModule_Factory(t) {\n  return new (t || ZXingScannerModule)();\n};\nZXingScannerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: ZXingScannerModule\n});\nZXingScannerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [CommonModule, FormsModule]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ZXingScannerModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, FormsModule],\n      declarations: [ZXingScannerComponent],\n      exports: [ZXingScannerComponent]\n    }]\n  }], null, null);\n})();\n\n/*\n * Public API Surface of zxing-scanner\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ZXingScannerComponent, ZXingScannerModule };","map":{"version":3,"names":["CommonModule","i0","EventEmitter","Component","ChangeDetectionStrategy","ViewChild","Input","Output","NgModule","FormsModule","BrowserMultiFormatReader","BrowserCodeReader","NotFoundException","ChecksumException","FormatException","BarcodeFormat","DecodeHintType","BehaviorSubject","BrowserMultiFormatContinuousReader","getScannerControls","scannerControls","Error","scanFromDeviceObservable","deviceId","previewEl","scan$","ctrls","decodeFromVideoDevice","result","error","next","errorName","name","message","includes","stop","undefined","complete","e","asObservable","ZXingScannerComponent","constructor","timeBetweenScans","delayBetweenScanSuccess","previewFitMode","_ready","autostarted","autostarting","torchCompatible","scanSuccess","scanFailure","scanError","scanComplete","camerasFound","camerasNotFound","permissionResponse","hasDevices","deviceChange","_enabled","_hints","Map","autofocusEnabled","autostart","formats","QR_CODE","hasNavigator","navigator","isMediaDevicesSupported","mediaDevices","codeReader","_codeReader","device","_devicePreStart","isAutostarting","console","warn","isCurrentDevice","hasPermission","setDevice","_device","hints","get","POSSIBLE_FORMATS","input","map","f","getBarcodeFormatOrFail","set","setHints","videoConstraints","constraints","controls","streamVideoConstraintsApply","state","_isAutostarting","torch","onOff","getCodeReader","switchTorch","enable","enabled","Boolean","reset","releaseAllStreams","scanFromDevice","init","tryHarder","TRY_HARDER","delete","askForPermission","setPermission","stream","permission","getAnyVideoDevice","err","handlePermissionException","terminateStream","getUserMedia","video","getTracks","forEach","t","initAutostartOff","initAutostartOn","updateVideoInputDevices","devices","autostartScanner","ngOnDestroy","ngOnInit","scanStop","_scanSubscription","unsubscribe","scanStart","restart","prevDevice","_reset","listVideoInputDevices","length","matcher","label","test","find","pop","dispatchScanSuccess","getText","dispatchScanFailure","reason","dispatchScanError","observed","dispatchScanComplete","format","trim","toUpperCase","options","delayBetweenScanAttempts","videoElement","previewElemRef","nativeElement","scanStream","x","_onDecodeResult","_onDecodeError","subscribe","closed","hasTorchControl","emit","cleanVideoSource","ɵfac","ɵcmp","type","args","selector","changeDetection","OnPush","template","styles","static","ZXingScannerModule","ɵmod","ɵinj","imports","declarations","exports"],"sources":["E:/GME/Angular/GME-Angular/node_modules/@zxing/ngx-scanner/fesm2020/zxing-ngx-scanner.mjs"],"sourcesContent":["import { CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewChild, Input, Output, NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { BrowserMultiFormatReader, BrowserCodeReader } from '@zxing/browser';\nimport { NotFoundException, ChecksumException, FormatException, BarcodeFormat, DecodeHintType } from '@zxing/library';\nimport { BehaviorSubject } from 'rxjs';\n\n/**\n * Based on zxing-typescript BrowserCodeReader\n */\nclass BrowserMultiFormatContinuousReader extends BrowserMultiFormatReader {\n    /**\n     * Returns the code reader scanner controls.\n     */\n    getScannerControls() {\n        if (!this.scannerControls) {\n            throw new Error('No scanning is running at the time.');\n        }\n        return this.scannerControls;\n    }\n    /**\n     * Starts the decoding from the current or a new video element.\n     *\n     * @param deviceId The device's to be used Id\n     * @param previewEl A new video element\n     */\n    async scanFromDeviceObservable(deviceId, previewEl) {\n        const scan$ = new BehaviorSubject({});\n        let ctrls;\n        try {\n            ctrls = await this.decodeFromVideoDevice(deviceId, previewEl, (result, error) => {\n                if (!error) {\n                    scan$.next({ result });\n                    return;\n                }\n                const errorName = error.name;\n                // stream cannot stop on fails.\n                if (\n                // scan Failure - found nothing, no error\n                errorName === NotFoundException.name ||\n                    // scan Error - found the QR but got error on decoding\n                    errorName === ChecksumException.name ||\n                    errorName === FormatException.name ||\n                    error.message.includes('No MultiFormat Readers were able to detect the code.')) {\n                    scan$.next({ error });\n                    return;\n                }\n                // probably fatal error\n                scan$.error(error);\n                this.scannerControls.stop();\n                this.scannerControls = undefined;\n                return;\n            });\n            this.scannerControls = {\n                ...ctrls,\n                stop() {\n                    ctrls.stop();\n                    scan$.complete();\n                },\n            };\n        }\n        catch (e) {\n            scan$.error(e);\n            this.scannerControls?.stop();\n            this.scannerControls = undefined;\n        }\n        return scan$.asObservable();\n    }\n}\n\nclass ZXingScannerComponent {\n    /**\n     * Constructor to build the object and do some DI.\n     */\n    constructor() {\n        /**\n         * Delay between attempts to decode (default is 500ms)\n         */\n        this.timeBetweenScans = 500;\n        /**\n         * Delay between successful decode (default is 500ms)\n         */\n        this.delayBetweenScanSuccess = 500;\n        /**\n         * How the preview element should be fit inside the :host container.\n         */\n        this.previewFitMode = 'cover';\n        this._ready = false;\n        // instance based emitters\n        this.autostarted = new EventEmitter();\n        this.autostarting = new EventEmitter();\n        this.torchCompatible = new EventEmitter(false);\n        this.scanSuccess = new EventEmitter();\n        this.scanFailure = new EventEmitter();\n        this.scanError = new EventEmitter();\n        this.scanComplete = new EventEmitter();\n        this.camerasFound = new EventEmitter();\n        this.camerasNotFound = new EventEmitter();\n        this.permissionResponse = new EventEmitter(true);\n        this.hasDevices = new EventEmitter();\n        this.deviceChange = new EventEmitter();\n        this._enabled = true;\n        this._hints = new Map();\n        this.autofocusEnabled = true;\n        this.autostart = true;\n        this.formats = [BarcodeFormat.QR_CODE];\n        // computed data\n        this.hasNavigator = typeof navigator !== 'undefined';\n        this.isMediaDevicesSupported = this.hasNavigator && !!navigator.mediaDevices;\n    }\n    /**\n     * Exposes the current code reader, so the user can use it's APIs.\n     */\n    get codeReader() {\n        return this._codeReader;\n    }\n    /**\n     * User device input\n     */\n    set device(device) {\n        if (!this._ready) {\n            this._devicePreStart = device;\n            // let's ignore silently, users don't like logs\n            return;\n        }\n        if (this.isAutostarting) {\n            // do not allow setting devices during auto-start, since it will set one and emit it.\n            console.warn('Avoid setting a device during auto-start.');\n            return;\n        }\n        if (this.isCurrentDevice(device)) {\n            console.warn('Setting the same device is not allowed.');\n            return;\n        }\n        if (!this.hasPermission) {\n            console.warn('Permissions not set yet, waiting for them to be set to apply device change.');\n            // this.permissionResponse\n            //   .pipe(\n            //     take(1),\n            //     tap(() => console.log(`Permissions set, applying device change${device ? ` (${device.deviceId})` : ''}.`))\n            //   )\n            //   .subscribe(() => this.device = device);\n            return;\n        }\n        this.setDevice(device);\n    }\n    /**\n     * User device accessor.\n     */\n    get device() {\n        return this._device;\n    }\n    /**\n     * Returns all the registered formats.\n     */\n    get formats() {\n        return this.hints.get(DecodeHintType.POSSIBLE_FORMATS);\n    }\n    /**\n     * Registers formats the scanner should support.\n     *\n     * @param input BarcodeFormat or case-insensitive string array.\n     */\n    set formats(input) {\n        if (typeof input === 'string') {\n            throw new Error('Invalid formats, make sure the [formats] input is a binding.');\n        }\n        // formats may be set from html template as BarcodeFormat or string array\n        const formats = input.map(f => this.getBarcodeFormatOrFail(f));\n        const hints = this.hints;\n        // updates the hints\n        hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);\n        // handles updating the codeReader\n        this.hints = hints;\n    }\n    /**\n     * Returns all the registered hints.\n     */\n    get hints() {\n        return this._hints;\n    }\n    /**\n     * Does what it takes to set the hints.\n     */\n    set hints(hints) {\n        this._hints = hints;\n        // new instance with new hints.\n        this.codeReader?.setHints(this._hints);\n    }\n    /**\n     * Sets the desired constraints in all video tracks.\n     * @experimental\n     */\n    set videoConstraints(constraints) {\n        // new instance with new hints.\n        const controls = this.codeReader?.getScannerControls();\n        if (!controls) {\n            // fails silently\n            return;\n        }\n        controls?.streamVideoConstraintsApply(constraints);\n    }\n    /**\n     *\n     */\n    set isAutostarting(state) {\n        this._isAutostarting = state;\n        this.autostarting.next(state);\n    }\n    /**\n     *\n     */\n    get isAutostarting() {\n        return this._isAutostarting;\n    }\n    /**\n     * Can turn on/off the device flashlight.\n     *\n     * @experimental Torch/Flash APIs are not stable in all browsers, it may be buggy!\n     */\n    set torch(onOff) {\n        try {\n            const controls = this.getCodeReader().getScannerControls();\n            controls.switchTorch(onOff);\n        }\n        catch (error) {\n            // ignore error\n        }\n    }\n    /**\n     * Starts and Stops the scanning.\n     */\n    set enable(enabled) {\n        this._enabled = Boolean(enabled);\n        if (!this._enabled) {\n            this.reset();\n            BrowserMultiFormatContinuousReader.releaseAllStreams();\n        }\n        else {\n            if (this.device) {\n                this.scanFromDevice(this.device.deviceId);\n            }\n            else {\n                this.init();\n            }\n        }\n    }\n    /**\n     * Tells if the scanner is enabled or not.\n     */\n    get enabled() {\n        return this._enabled;\n    }\n    /**\n     * If is `tryHarder` enabled.\n     */\n    get tryHarder() {\n        return this.hints.get(DecodeHintType.TRY_HARDER);\n    }\n    /**\n     * Enable/disable tryHarder hint.\n     */\n    set tryHarder(enable) {\n        const hints = this.hints;\n        if (enable) {\n            hints.set(DecodeHintType.TRY_HARDER, true);\n        }\n        else {\n            hints.delete(DecodeHintType.TRY_HARDER);\n        }\n        this.hints = hints;\n    }\n    /**\n     * Gets and registers all cameras.\n     */\n    async askForPermission() {\n        if (!this.hasNavigator) {\n            console.error('@zxing/ngx-scanner', 'Can\\'t ask permission, navigator is not present.');\n            this.setPermission(null);\n            return this.hasPermission;\n        }\n        if (!this.isMediaDevicesSupported) {\n            console.error('@zxing/ngx-scanner', 'Can\\'t get user media, this is not supported.');\n            this.setPermission(null);\n            return this.hasPermission;\n        }\n        let stream;\n        let permission;\n        try {\n            // Will try to ask for permission\n            stream = await this.getAnyVideoDevice();\n            permission = !!stream;\n        }\n        catch (err) {\n            return this.handlePermissionException(err);\n        }\n        finally {\n            this.terminateStream(stream);\n        }\n        this.setPermission(permission);\n        // Returns the permission\n        return permission;\n    }\n    /**\n     *\n     */\n    getAnyVideoDevice() {\n        return navigator.mediaDevices.getUserMedia({ video: true });\n    }\n    /**\n     * Terminates a stream and it's tracks.\n     */\n    terminateStream(stream) {\n        if (stream) {\n            stream.getTracks().forEach(t => t.stop());\n        }\n        stream = undefined;\n    }\n    async init() {\n        if (!this.autostart) {\n            console.warn('Feature \\'autostart\\' disabled. Permissions and devices recovery has to be run manually.');\n            // does the necessary configuration without autostarting\n            this.initAutostartOff();\n            this._ready = true;\n            return;\n        }\n        // configures the component and starts the scanner\n        await this.initAutostartOn();\n        this._ready = true;\n    }\n    /**\n     * Initializes the component without starting the scanner.\n     */\n    initAutostartOff() {\n        // do not ask for permission when autostart is off\n        this.isAutostarting = false;\n        // just update devices information\n        this.updateVideoInputDevices();\n        if (this._device && this._devicePreStart) {\n            this.setDevice(this._devicePreStart);\n        }\n    }\n    /**\n     * Initializes the component and starts the scanner.\n     * Permissions are asked to accomplish that.\n     */\n    async initAutostartOn() {\n        this.isAutostarting = true;\n        let hasPermission;\n        try {\n            // Asks for permission before enumerating devices so it can get all the device's info\n            hasPermission = await this.askForPermission();\n        }\n        catch (e) {\n            console.error('Exception occurred while asking for permission:', e);\n            return;\n        }\n        // from this point, things gonna need permissions\n        if (hasPermission) {\n            const devices = await this.updateVideoInputDevices();\n            await this.autostartScanner([...devices]);\n        }\n        this.isAutostarting = false;\n        this.autostarted.next();\n    }\n    /**\n     * Checks if the given device is the current defined one.\n     */\n    isCurrentDevice(device) {\n        return device?.deviceId === this._device?.deviceId;\n    }\n    /**\n     * Executes some actions before destroy the component.\n     */\n    ngOnDestroy() {\n        this.reset();\n        BrowserMultiFormatContinuousReader.releaseAllStreams();\n    }\n    /**\n     *\n     */\n    ngOnInit() {\n        this.init();\n    }\n    /**\n     * Stops the scanning, if any.\n     */\n    scanStop() {\n        if (this._scanSubscription) {\n            this.codeReader?.getScannerControls().stop();\n            this._scanSubscription?.unsubscribe();\n            this._scanSubscription = undefined;\n        }\n        this.torchCompatible.next(false);\n    }\n    /**\n     * Stops the scanning, if any.\n     */\n    scanStart() {\n        if (this._scanSubscription) {\n            throw new Error('There is already a scan process running.');\n        }\n        if (!this._device) {\n            throw new Error('No device defined, cannot start scan, please define a device.');\n        }\n        this.scanFromDevice(this._device.deviceId);\n    }\n    /**\n     * Stops old `codeReader` and starts scanning in a new one.\n     */\n    restart() {\n        // note only necessary for now because of the Torch\n        this._codeReader = undefined;\n        const prevDevice = this._reset();\n        if (!prevDevice) {\n            return;\n        }\n        this.device = prevDevice;\n    }\n    /**\n     * Discovers and updates known video input devices.\n     */\n    async updateVideoInputDevices() {\n        // permissions aren't needed to get devices, but to access them and their info\n        const devices = await BrowserCodeReader.listVideoInputDevices() || [];\n        const hasDevices = devices && devices.length > 0;\n        // stores discovered devices and updates information\n        this.hasDevices.next(hasDevices);\n        this.camerasFound.next([...devices]);\n        if (!hasDevices) {\n            this.camerasNotFound.next(null);\n        }\n        return devices;\n    }\n    /**\n     * Starts the scanner with the back camera otherwise take the last\n     * available device.\n     */\n    async autostartScanner(devices) {\n        const matcher = ({ label }) => /back|trás|rear|traseira|environment|ambiente/gi.test(label);\n        // select the rear camera by default, otherwise take the last camera.\n        const device = devices.find(matcher) || devices.pop();\n        if (!device) {\n            throw new Error('Impossible to autostart, no input devices available.');\n        }\n        await this.setDevice(device);\n        this.deviceChange.next(device);\n    }\n    /**\n     * Dispatches the scan success event.\n     *\n     * @param result the scan result.\n     */\n    dispatchScanSuccess(result) {\n        this.scanSuccess.next(result.getText());\n    }\n    /**\n     * Dispatches the scan failure event.\n     */\n    dispatchScanFailure(reason) {\n        this.scanFailure.next(reason);\n    }\n    /**\n     * Dispatches the scan error event.\n     *\n     * @param error the error thing.\n     */\n    dispatchScanError(error) {\n        if (!this.scanError.observed) {\n            console.error(`zxing scanner component: ${error.name}`, error);\n            console.warn('Use the `(scanError)` property to handle errors like this!');\n        }\n        this.scanError.next(error);\n    }\n    /**\n     * Dispatches the scan event.\n     *\n     * @param result the scan result.\n     */\n    dispatchScanComplete(result) {\n        this.scanComplete.next(result);\n    }\n    /**\n     * Returns the filtered permission.\n     */\n    handlePermissionException(err) {\n        // failed to grant permission to video input\n        console.error('@zxing/ngx-scanner', 'Error when asking for permission.', err);\n        let permission;\n        switch (err.name) {\n            // usually caused by not secure origins\n            case 'NotSupportedError':\n                console.warn('@zxing/ngx-scanner', err.message);\n                // could not claim\n                permission = null;\n                // can't check devices\n                this.hasDevices.next(null);\n                break;\n            // user denied permission\n            case 'NotAllowedError':\n                console.warn('@zxing/ngx-scanner', err.message);\n                // claimed and denied permission\n                permission = false;\n                // this means that input devices exists\n                this.hasDevices.next(true);\n                break;\n            // the device has no attached input devices\n            case 'NotFoundError':\n                console.warn('@zxing/ngx-scanner', err.message);\n                // no permissions claimed\n                permission = null;\n                // because there was no devices\n                this.hasDevices.next(false);\n                // tells the listener about the error\n                this.camerasNotFound.next(err);\n                break;\n            case 'NotReadableError':\n                console.warn('@zxing/ngx-scanner', 'Couldn\\'t read the device(s)\\'s stream, it\\'s probably in use by another app.');\n                // no permissions claimed\n                permission = null;\n                // there are devices, which I couldn't use\n                this.hasDevices.next(false);\n                // tells the listener about the error\n                this.camerasNotFound.next(err);\n                break;\n            default:\n                console.warn('@zxing/ngx-scanner', 'I was not able to define if I have permissions for camera or not.', err);\n                // unknown\n                permission = null;\n                // this.hasDevices.next(undefined;\n                break;\n        }\n        this.setPermission(permission);\n        // tells the listener about the error\n        this.permissionResponse.error(err);\n        return permission;\n    }\n    /**\n     * Returns a valid BarcodeFormat or fails.\n     */\n    getBarcodeFormatOrFail(format) {\n        return typeof format === 'string'\n            ? BarcodeFormat[format.trim().toUpperCase()]\n            : format;\n    }\n    /**\n     * Return a code reader, create one if non exist\n     */\n    getCodeReader() {\n        if (!this._codeReader) {\n            const options = {\n                delayBetweenScanAttempts: this.timeBetweenScans,\n                delayBetweenScanSuccess: this.delayBetweenScanSuccess,\n            };\n            this._codeReader = new BrowserMultiFormatContinuousReader(this.hints, options);\n        }\n        return this._codeReader;\n    }\n    /**\n     * Starts the continuous scanning for the given device.\n     *\n     * @param deviceId The deviceId from the device.\n     */\n    async scanFromDevice(deviceId) {\n        const videoElement = this.previewElemRef.nativeElement;\n        const codeReader = this.getCodeReader();\n        const scanStream = await codeReader.scanFromDeviceObservable(deviceId, videoElement);\n        if (!scanStream) {\n            throw new Error('Undefined decoding stream, aborting.');\n        }\n        const next = (x) => this._onDecodeResult(x.result, x.error);\n        const error = (err) => this._onDecodeError(err);\n        const complete = () => { };\n        this._scanSubscription = scanStream.subscribe(next, error, complete);\n        if (this._scanSubscription.closed) {\n            return;\n        }\n        const controls = codeReader.getScannerControls();\n        const hasTorchControl = typeof controls.switchTorch !== 'undefined';\n        this.torchCompatible.next(hasTorchControl);\n    }\n    /**\n     * Handles decode errors.\n     */\n    _onDecodeError(err) {\n        this.dispatchScanError(err);\n        // this.reset();\n    }\n    /**\n     * Handles decode results.\n     */\n    _onDecodeResult(result, error) {\n        if (result) {\n            this.dispatchScanSuccess(result);\n        }\n        else {\n            this.dispatchScanFailure(error);\n        }\n        this.dispatchScanComplete(result);\n    }\n    /**\n     * Stops the code reader and returns the previous selected device.\n     */\n    _reset() {\n        if (!this._codeReader) {\n            return;\n        }\n        const device = this._device;\n        // do not set this.device inside this method, it would create a recursive loop\n        this.device = undefined;\n        this._codeReader = undefined;\n        return device;\n    }\n    /**\n     * Resets the scanner and emits device change.\n     */\n    reset() {\n        this._reset();\n        this.deviceChange.emit(null);\n    }\n    /**\n     * Sets the current device.\n     */\n    async setDevice(device) {\n        // instantly stops the scan before changing devices\n        this.scanStop();\n        // correctly sets the new (or none) device\n        this._device = device || undefined;\n        if (!this._device) {\n            // cleans the video because user removed the device\n            BrowserCodeReader.cleanVideoSource(this.previewElemRef.nativeElement);\n        }\n        // if enabled, starts scanning\n        if (this._enabled && device) {\n            await this.scanFromDevice(device.deviceId);\n        }\n    }\n    /**\n     * Sets the permission value and emits the event.\n     */\n    setPermission(hasPermission) {\n        this.hasPermission = hasPermission;\n        this.permissionResponse.next(hasPermission);\n    }\n}\nZXingScannerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ZXingScannerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\nZXingScannerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"15.0.0\", type: ZXingScannerComponent, selector: \"zxing-scanner\", inputs: { autofocusEnabled: \"autofocusEnabled\", timeBetweenScans: \"timeBetweenScans\", delayBetweenScanSuccess: \"delayBetweenScanSuccess\", autostart: \"autostart\", previewFitMode: \"previewFitMode\", device: \"device\", formats: \"formats\", videoConstraints: \"videoConstraints\", torch: \"torch\", enable: \"enable\", tryHarder: \"tryHarder\" }, outputs: { autostarted: \"autostarted\", autostarting: \"autostarting\", torchCompatible: \"torchCompatible\", scanSuccess: \"scanSuccess\", scanFailure: \"scanFailure\", scanError: \"scanError\", scanComplete: \"scanComplete\", camerasFound: \"camerasFound\", camerasNotFound: \"camerasNotFound\", permissionResponse: \"permissionResponse\", hasDevices: \"hasDevices\", deviceChange: \"deviceChange\" }, viewQueries: [{ propertyName: \"previewElemRef\", first: true, predicate: [\"preview\"], descendants: true, static: true }], ngImport: i0, template: \"<video #preview [style.object-fit]=\\\"previewFitMode\\\">\\n  <p>\\n    Your browser does not support this feature, please try to upgrade it.\\n  </p>\\n  <p>\\n    Seu navegador n\\u00E3o suporta este recurso, por favor tente atualiz\\u00E1-lo.\\n  </p>\\n</video>\\n\", styles: [\":host{display:block}video{width:100%;height:auto;object-fit:contain}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ZXingScannerComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'zxing-scanner', changeDetection: ChangeDetectionStrategy.OnPush, template: \"<video #preview [style.object-fit]=\\\"previewFitMode\\\">\\n  <p>\\n    Your browser does not support this feature, please try to upgrade it.\\n  </p>\\n  <p>\\n    Seu navegador n\\u00E3o suporta este recurso, por favor tente atualiz\\u00E1-lo.\\n  </p>\\n</video>\\n\", styles: [\":host{display:block}video{width:100%;height:auto;object-fit:contain}\\n\"] }]\n        }], ctorParameters: function () { return []; }, propDecorators: { previewElemRef: [{\n                type: ViewChild,\n                args: ['preview', { static: true }]\n            }], autofocusEnabled: [{\n                type: Input\n            }], timeBetweenScans: [{\n                type: Input\n            }], delayBetweenScanSuccess: [{\n                type: Input\n            }], autostarted: [{\n                type: Output\n            }], autostarting: [{\n                type: Output\n            }], autostart: [{\n                type: Input\n            }], previewFitMode: [{\n                type: Input\n            }], torchCompatible: [{\n                type: Output\n            }], scanSuccess: [{\n                type: Output\n            }], scanFailure: [{\n                type: Output\n            }], scanError: [{\n                type: Output\n            }], scanComplete: [{\n                type: Output\n            }], camerasFound: [{\n                type: Output\n            }], camerasNotFound: [{\n                type: Output\n            }], permissionResponse: [{\n                type: Output\n            }], hasDevices: [{\n                type: Output\n            }], device: [{\n                type: Input\n            }], deviceChange: [{\n                type: Output\n            }], formats: [{\n                type: Input\n            }], videoConstraints: [{\n                type: Input\n            }], torch: [{\n                type: Input\n            }], enable: [{\n                type: Input\n            }], tryHarder: [{\n                type: Input\n            }] } });\n\nclass ZXingScannerModule {\n}\nZXingScannerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ZXingScannerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nZXingScannerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.0.0\", ngImport: i0, type: ZXingScannerModule, declarations: [ZXingScannerComponent], imports: [CommonModule,\n        FormsModule], exports: [ZXingScannerComponent] });\nZXingScannerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ZXingScannerModule, imports: [CommonModule,\n        FormsModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: ZXingScannerModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [\n                        CommonModule,\n                        FormsModule\n                    ],\n                    declarations: [ZXingScannerComponent],\n                    exports: [ZXingScannerComponent],\n                }]\n        }] });\n\n/*\n * Public API Surface of zxing-scanner\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ZXingScannerComponent, ZXingScannerModule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}