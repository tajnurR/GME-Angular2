{"ast":null,"code":"/*\r\n* Copyright 2012 ZXing authors\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*      http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n// package com.google.zxing.pdf417.decoder.ec;\n// import com.google.zxing.ChecksumException;\nimport ChecksumException from '../../../ChecksumException';\nimport ModulusPoly from './ModulusPoly';\nimport ModulusGF from './ModulusGF';\n/**\r\n * <p>PDF417 error correction implementation.</p>\r\n *\r\n * <p>This <a href=\"http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example\">example</a>\r\n * is quite useful in understanding the algorithm.</p>\r\n *\r\n * @author Sean Owen\r\n * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder\r\n */\nvar ErrorCorrection = /** @class */function () {\n  function ErrorCorrection() {\n    this.field = ModulusGF.PDF417_GF;\n  }\n  /**\r\n   * @param received received codewords\r\n   * @param numECCodewords number of those codewords used for EC\r\n   * @param erasures location of erasures\r\n   * @return number of errors\r\n   * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors\r\n   */\n  ErrorCorrection.prototype.decode = function (received, numECCodewords, erasures) {\n    var e_1, _a;\n    var poly = new ModulusPoly(this.field, received);\n    var S = new Int32Array(numECCodewords);\n    var error = false;\n    for (var i /*int*/ = numECCodewords; i > 0; i--) {\n      var evaluation = poly.evaluateAt(this.field.exp(i));\n      S[numECCodewords - i] = evaluation;\n      if (evaluation !== 0) {\n        error = true;\n      }\n    }\n    if (!error) {\n      return 0;\n    }\n    var knownErrors = this.field.getOne();\n    if (erasures != null) {\n      try {\n        for (var erasures_1 = __values(erasures), erasures_1_1 = erasures_1.next(); !erasures_1_1.done; erasures_1_1 = erasures_1.next()) {\n          var erasure = erasures_1_1.value;\n          var b = this.field.exp(received.length - 1 - erasure);\n          // Add (1 - bx) term:\n          var term = new ModulusPoly(this.field, new Int32Array([this.field.subtract(0, b), 1]));\n          knownErrors = knownErrors.multiply(term);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (erasures_1_1 && !erasures_1_1.done && (_a = erasures_1.return)) _a.call(erasures_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n    var syndrome = new ModulusPoly(this.field, S);\n    // syndrome = syndrome.multiply(knownErrors);\n    var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);\n    var sigma = sigmaOmega[0];\n    var omega = sigmaOmega[1];\n    // sigma = sigma.multiply(knownErrors);\n    var errorLocations = this.findErrorLocations(sigma);\n    var errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);\n    for (var i /*int*/ = 0; i < errorLocations.length; i++) {\n      var position = received.length - 1 - this.field.log(errorLocations[i]);\n      if (position < 0) {\n        throw ChecksumException.getChecksumInstance();\n      }\n      received[position] = this.field.subtract(received[position], errorMagnitudes[i]);\n    }\n    return errorLocations.length;\n  };\n  /**\r\n   *\r\n   * @param ModulusPoly\r\n   * @param a\r\n   * @param ModulusPoly\r\n   * @param b\r\n   * @param int\r\n   * @param R\r\n   * @throws ChecksumException\r\n   */\n  ErrorCorrection.prototype.runEuclideanAlgorithm = function (a, b, R) {\n    // Assume a's degree is >= b's\n    if (a.getDegree() < b.getDegree()) {\n      var temp = a;\n      a = b;\n      b = temp;\n    }\n    var rLast = a;\n    var r = b;\n    var tLast = this.field.getZero();\n    var t = this.field.getOne();\n    // Run Euclidean algorithm until r's degree is less than R/2\n    while (r.getDegree() >= Math.round(R / 2)) {\n      var rLastLast = rLast;\n      var tLastLast = tLast;\n      rLast = r;\n      tLast = t;\n      // Divide rLastLast by rLast, with quotient in q and remainder in r\n      if (rLast.isZero()) {\n        // Oops, Euclidean algorithm already terminated?\n        throw ChecksumException.getChecksumInstance();\n      }\n      r = rLastLast;\n      var q = this.field.getZero();\n      var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n      var dltInverse = this.field.inverse(denominatorLeadingTerm);\n      while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n        var degreeDiff = r.getDegree() - rLast.getDegree();\n        var scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n        q = q.add(this.field.buildMonomial(degreeDiff, scale));\n        r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));\n      }\n      t = q.multiply(tLast).subtract(tLastLast).negative();\n    }\n    var sigmaTildeAtZero = t.getCoefficient(0);\n    if (sigmaTildeAtZero === 0) {\n      throw ChecksumException.getChecksumInstance();\n    }\n    var inverse = this.field.inverse(sigmaTildeAtZero);\n    var sigma = t.multiply(inverse);\n    var omega = r.multiply(inverse);\n    return [sigma, omega];\n  };\n  /**\r\n   *\r\n   * @param errorLocator\r\n   * @throws ChecksumException\r\n   */\n  ErrorCorrection.prototype.findErrorLocations = function (errorLocator) {\n    // This is a direct application of Chien's search\n    var numErrors = errorLocator.getDegree();\n    var result = new Int32Array(numErrors);\n    var e = 0;\n    for (var i /*int*/ = 1; i < this.field.getSize() && e < numErrors; i++) {\n      if (errorLocator.evaluateAt(i) === 0) {\n        result[e] = this.field.inverse(i);\n        e++;\n      }\n    }\n    if (e !== numErrors) {\n      throw ChecksumException.getChecksumInstance();\n    }\n    return result;\n  };\n  ErrorCorrection.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocator, errorLocations) {\n    var errorLocatorDegree = errorLocator.getDegree();\n    var formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);\n    for (var i /*int*/ = 1; i <= errorLocatorDegree; i++) {\n      formalDerivativeCoefficients[errorLocatorDegree - i] = this.field.multiply(i, errorLocator.getCoefficient(i));\n    }\n    var formalDerivative = new ModulusPoly(this.field, formalDerivativeCoefficients);\n    // This is directly applying Forney's Formula\n    var s = errorLocations.length;\n    var result = new Int32Array(s);\n    for (var i /*int*/ = 0; i < s; i++) {\n      var xiInverse = this.field.inverse(errorLocations[i]);\n      var numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));\n      var denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));\n      result[i] = this.field.multiply(numerator, denominator);\n    }\n    return result;\n  };\n  return ErrorCorrection;\n}();\nexport default ErrorCorrection;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}