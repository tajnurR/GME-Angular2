{"ast":null,"code":"import _asyncToGenerator from \"E:/angular/GME-Angular2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewChild, Input, Output, NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { BrowserMultiFormatReader, BrowserCodeReader } from '@zxing/browser';\nimport { NotFoundException, ChecksumException, FormatException, BarcodeFormat, DecodeHintType } from '@zxing/library';\nimport { BehaviorSubject } from 'rxjs';\n\n/**\r\n * Based on zxing-typescript BrowserCodeReader\r\n */\nconst _c0 = [\"preview\"];\nclass BrowserMultiFormatContinuousReader extends BrowserMultiFormatReader {\n  /**\r\n   * Returns the code reader scanner controls.\r\n   */\n  getScannerControls() {\n    if (!this.scannerControls) {\n      throw new Error('No scanning is running at the time.');\n    }\n    return this.scannerControls;\n  }\n  /**\r\n   * Starts the decoding from the current or a new video element.\r\n   *\r\n   * @param deviceId The device's to be used Id\r\n   * @param previewEl A new video element\r\n   */\n  scanFromDeviceObservable(deviceId, previewEl) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const scan$ = new BehaviorSubject({});\n      let ctrls;\n      try {\n        ctrls = yield _this.decodeFromVideoDevice(deviceId, previewEl, (result, error) => {\n          if (!error) {\n            scan$.next({\n              result\n            });\n            return;\n          }\n          const errorName = error.name;\n          // stream cannot stop on fails.\n          if (\n          // scan Failure - found nothing, no error\n          errorName === NotFoundException.name ||\n          // scan Error - found the QR but got error on decoding\n          errorName === ChecksumException.name || errorName === FormatException.name || error.message.includes('No MultiFormat Readers were able to detect the code.')) {\n            scan$.next({\n              error\n            });\n            return;\n          }\n          // probably fatal error\n          scan$.error(error);\n          _this.scannerControls.stop();\n          _this.scannerControls = undefined;\n          return;\n        });\n        _this.scannerControls = {\n          ...ctrls,\n          stop() {\n            ctrls.stop();\n            scan$.complete();\n          }\n        };\n      } catch (e) {\n        scan$.error(e);\n        _this.scannerControls?.stop();\n        _this.scannerControls = undefined;\n      }\n      return scan$.asObservable();\n    })();\n  }\n}\nlet ZXingScannerComponent = /*#__PURE__*/(() => {\n  class ZXingScannerComponent {\n    /**\r\n     * Constructor to build the object and do some DI.\r\n     */\n    constructor() {\n      /**\r\n       * Delay between attempts to decode (default is 500ms)\r\n       */\n      this.timeBetweenScans = 500;\n      /**\r\n       * Delay between successful decode (default is 500ms)\r\n       */\n      this.delayBetweenScanSuccess = 500;\n      /**\r\n       * How the preview element should be fit inside the :host container.\r\n       */\n      this.previewFitMode = 'cover';\n      this._ready = false;\n      // instance based emitters\n      this.autostarted = new EventEmitter();\n      this.autostarting = new EventEmitter();\n      this.torchCompatible = new EventEmitter(false);\n      this.scanSuccess = new EventEmitter();\n      this.scanFailure = new EventEmitter();\n      this.scanError = new EventEmitter();\n      this.scanComplete = new EventEmitter();\n      this.camerasFound = new EventEmitter();\n      this.camerasNotFound = new EventEmitter();\n      this.permissionResponse = new EventEmitter(true);\n      this.hasDevices = new EventEmitter();\n      this.deviceChange = new EventEmitter();\n      this._enabled = true;\n      this._hints = new Map();\n      this.autofocusEnabled = true;\n      this.autostart = true;\n      this.formats = [BarcodeFormat.QR_CODE];\n      // computed data\n      this.hasNavigator = typeof navigator !== 'undefined';\n      this.isMediaDevicesSupported = this.hasNavigator && !!navigator.mediaDevices;\n    }\n    /**\r\n     * Exposes the current code reader, so the user can use it's APIs.\r\n     */\n    get codeReader() {\n      return this._codeReader;\n    }\n    /**\r\n     * User device input\r\n     */\n    set device(device) {\n      if (!this._ready) {\n        this._devicePreStart = device;\n        // let's ignore silently, users don't like logs\n        return;\n      }\n      if (this.isAutostarting) {\n        // do not allow setting devices during auto-start, since it will set one and emit it.\n        console.warn('Avoid setting a device during auto-start.');\n        return;\n      }\n      if (this.isCurrentDevice(device)) {\n        console.warn('Setting the same device is not allowed.');\n        return;\n      }\n      if (!this.hasPermission) {\n        console.warn('Permissions not set yet, waiting for them to be set to apply device change.');\n        // this.permissionResponse\n        //   .pipe(\n        //     take(1),\n        //     tap(() => console.log(`Permissions set, applying device change${device ? ` (${device.deviceId})` : ''}.`))\n        //   )\n        //   .subscribe(() => this.device = device);\n        return;\n      }\n      this.setDevice(device);\n    }\n    /**\r\n     * User device accessor.\r\n     */\n    get device() {\n      return this._device;\n    }\n    /**\r\n     * Returns all the registered formats.\r\n     */\n    get formats() {\n      return this.hints.get(DecodeHintType.POSSIBLE_FORMATS);\n    }\n    /**\r\n     * Registers formats the scanner should support.\r\n     *\r\n     * @param input BarcodeFormat or case-insensitive string array.\r\n     */\n    set formats(input) {\n      if (typeof input === 'string') {\n        throw new Error('Invalid formats, make sure the [formats] input is a binding.');\n      }\n      // formats may be set from html template as BarcodeFormat or string array\n      const formats = input.map(f => this.getBarcodeFormatOrFail(f));\n      const hints = this.hints;\n      // updates the hints\n      hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);\n      // handles updating the codeReader\n      this.hints = hints;\n    }\n    /**\r\n     * Returns all the registered hints.\r\n     */\n    get hints() {\n      return this._hints;\n    }\n    /**\r\n     * Does what it takes to set the hints.\r\n     */\n    set hints(hints) {\n      this._hints = hints;\n      // new instance with new hints.\n      this.codeReader?.setHints(this._hints);\n    }\n    /**\r\n     * Sets the desired constraints in all video tracks.\r\n     * @experimental\r\n     */\n    set videoConstraints(constraints) {\n      // new instance with new hints.\n      const controls = this.codeReader?.getScannerControls();\n      if (!controls) {\n        // fails silently\n        return;\n      }\n      controls?.streamVideoConstraintsApply(constraints);\n    }\n    /**\r\n     *\r\n     */\n    set isAutostarting(state) {\n      this._isAutostarting = state;\n      this.autostarting.next(state);\n    }\n    /**\r\n     *\r\n     */\n    get isAutostarting() {\n      return this._isAutostarting;\n    }\n    /**\r\n     * Can turn on/off the device flashlight.\r\n     *\r\n     * @experimental Torch/Flash APIs are not stable in all browsers, it may be buggy!\r\n     */\n    set torch(onOff) {\n      try {\n        const controls = this.getCodeReader().getScannerControls();\n        controls.switchTorch(onOff);\n      } catch (error) {\n        // ignore error\n      }\n    }\n    /**\r\n     * Starts and Stops the scanning.\r\n     */\n    set enable(enabled) {\n      this._enabled = Boolean(enabled);\n      if (!this._enabled) {\n        this.reset();\n        BrowserMultiFormatContinuousReader.releaseAllStreams();\n      } else {\n        if (this.device) {\n          this.scanFromDevice(this.device.deviceId);\n        } else {\n          this.init();\n        }\n      }\n    }\n    /**\r\n     * Tells if the scanner is enabled or not.\r\n     */\n    get enabled() {\n      return this._enabled;\n    }\n    /**\r\n     * If is `tryHarder` enabled.\r\n     */\n    get tryHarder() {\n      return this.hints.get(DecodeHintType.TRY_HARDER);\n    }\n    /**\r\n     * Enable/disable tryHarder hint.\r\n     */\n    set tryHarder(enable) {\n      const hints = this.hints;\n      if (enable) {\n        hints.set(DecodeHintType.TRY_HARDER, true);\n      } else {\n        hints.delete(DecodeHintType.TRY_HARDER);\n      }\n      this.hints = hints;\n    }\n    /**\r\n     * Gets and registers all cameras.\r\n     */\n    askForPermission() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this2.hasNavigator) {\n          console.error('@zxing/ngx-scanner', 'Can\\'t ask permission, navigator is not present.');\n          _this2.setPermission(null);\n          return _this2.hasPermission;\n        }\n        if (!_this2.isMediaDevicesSupported) {\n          console.error('@zxing/ngx-scanner', 'Can\\'t get user media, this is not supported.');\n          _this2.setPermission(null);\n          return _this2.hasPermission;\n        }\n        let stream;\n        let permission;\n        try {\n          // Will try to ask for permission\n          stream = yield _this2.getAnyVideoDevice();\n          permission = !!stream;\n        } catch (err) {\n          return _this2.handlePermissionException(err);\n        } finally {\n          _this2.terminateStream(stream);\n        }\n        _this2.setPermission(permission);\n        // Returns the permission\n        return permission;\n      })();\n    }\n    /**\r\n     *\r\n     */\n    getAnyVideoDevice() {\n      return navigator.mediaDevices.getUserMedia({\n        video: true\n      });\n    }\n    /**\r\n     * Terminates a stream and it's tracks.\r\n     */\n    terminateStream(stream) {\n      if (stream) {\n        stream.getTracks().forEach(t => t.stop());\n      }\n      stream = undefined;\n    }\n    init() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this3.autostart) {\n          console.warn('Feature \\'autostart\\' disabled. Permissions and devices recovery has to be run manually.');\n          // does the necessary configuration without autostarting\n          _this3.initAutostartOff();\n          _this3._ready = true;\n          return;\n        }\n        // configures the component and starts the scanner\n        yield _this3.initAutostartOn();\n        _this3._ready = true;\n      })();\n    }\n    /**\r\n     * Initializes the component without starting the scanner.\r\n     */\n    initAutostartOff() {\n      // do not ask for permission when autostart is off\n      this.isAutostarting = false;\n      // just update devices information\n      this.updateVideoInputDevices();\n      if (this._device && this._devicePreStart) {\n        this.setDevice(this._devicePreStart);\n      }\n    }\n    /**\r\n     * Initializes the component and starts the scanner.\r\n     * Permissions are asked to accomplish that.\r\n     */\n    initAutostartOn() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        _this4.isAutostarting = true;\n        let hasPermission;\n        try {\n          // Asks for permission before enumerating devices so it can get all the device's info\n          hasPermission = yield _this4.askForPermission();\n        } catch (e) {\n          console.error('Exception occurred while asking for permission:', e);\n          return;\n        }\n        // from this point, things gonna need permissions\n        if (hasPermission) {\n          const devices = yield _this4.updateVideoInputDevices();\n          yield _this4.autostartScanner([...devices]);\n        }\n        _this4.isAutostarting = false;\n        _this4.autostarted.next();\n      })();\n    }\n    /**\r\n     * Checks if the given device is the current defined one.\r\n     */\n    isCurrentDevice(device) {\n      return device?.deviceId === this._device?.deviceId;\n    }\n    /**\r\n     * Executes some actions before destroy the component.\r\n     */\n    ngOnDestroy() {\n      this.reset();\n      BrowserMultiFormatContinuousReader.releaseAllStreams();\n    }\n    /**\r\n     *\r\n     */\n    ngOnInit() {\n      this.init();\n    }\n    /**\r\n     * Stops the scanning, if any.\r\n     */\n    scanStop() {\n      if (this._scanSubscription) {\n        this.codeReader?.getScannerControls().stop();\n        this._scanSubscription?.unsubscribe();\n        this._scanSubscription = undefined;\n      }\n      this.torchCompatible.next(false);\n    }\n    /**\r\n     * Stops the scanning, if any.\r\n     */\n    scanStart() {\n      if (this._scanSubscription) {\n        throw new Error('There is already a scan process running.');\n      }\n      if (!this._device) {\n        throw new Error('No device defined, cannot start scan, please define a device.');\n      }\n      this.scanFromDevice(this._device.deviceId);\n    }\n    /**\r\n     * Stops old `codeReader` and starts scanning in a new one.\r\n     */\n    restart() {\n      // note only necessary for now because of the Torch\n      this._codeReader = undefined;\n      const prevDevice = this._reset();\n      if (!prevDevice) {\n        return;\n      }\n      this.device = prevDevice;\n    }\n    /**\r\n     * Discovers and updates known video input devices.\r\n     */\n    updateVideoInputDevices() {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        // permissions aren't needed to get devices, but to access them and their info\n        const devices = (yield BrowserCodeReader.listVideoInputDevices()) || [];\n        const hasDevices = devices && devices.length > 0;\n        // stores discovered devices and updates information\n        _this5.hasDevices.next(hasDevices);\n        _this5.camerasFound.next([...devices]);\n        if (!hasDevices) {\n          _this5.camerasNotFound.next(null);\n        }\n        return devices;\n      })();\n    }\n    /**\r\n     * Starts the scanner with the back camera otherwise take the last\r\n     * available device.\r\n     */\n    autostartScanner(devices) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        const matcher = ({\n          label\n        }) => /back|trás|rear|traseira|environment|ambiente/gi.test(label);\n        // select the rear camera by default, otherwise take the last camera.\n        const device = devices.find(matcher) || devices.pop();\n        if (!device) {\n          throw new Error('Impossible to autostart, no input devices available.');\n        }\n        yield _this6.setDevice(device);\n        _this6.deviceChange.next(device);\n      })();\n    }\n    /**\r\n     * Dispatches the scan success event.\r\n     *\r\n     * @param result the scan result.\r\n     */\n    dispatchScanSuccess(result) {\n      this.scanSuccess.next(result.getText());\n    }\n    /**\r\n     * Dispatches the scan failure event.\r\n     */\n    dispatchScanFailure(reason) {\n      this.scanFailure.next(reason);\n    }\n    /**\r\n     * Dispatches the scan error event.\r\n     *\r\n     * @param error the error thing.\r\n     */\n    dispatchScanError(error) {\n      if (!this.scanError.observed) {\n        console.error(`zxing scanner component: ${error.name}`, error);\n        console.warn('Use the `(scanError)` property to handle errors like this!');\n      }\n      this.scanError.next(error);\n    }\n    /**\r\n     * Dispatches the scan event.\r\n     *\r\n     * @param result the scan result.\r\n     */\n    dispatchScanComplete(result) {\n      this.scanComplete.next(result);\n    }\n    /**\r\n     * Returns the filtered permission.\r\n     */\n    handlePermissionException(err) {\n      // failed to grant permission to video input\n      console.error('@zxing/ngx-scanner', 'Error when asking for permission.', err);\n      let permission;\n      switch (err.name) {\n        // usually caused by not secure origins\n        case 'NotSupportedError':\n          console.warn('@zxing/ngx-scanner', err.message);\n          // could not claim\n          permission = null;\n          // can't check devices\n          this.hasDevices.next(null);\n          break;\n        // user denied permission\n        case 'NotAllowedError':\n          console.warn('@zxing/ngx-scanner', err.message);\n          // claimed and denied permission\n          permission = false;\n          // this means that input devices exists\n          this.hasDevices.next(true);\n          break;\n        // the device has no attached input devices\n        case 'NotFoundError':\n          console.warn('@zxing/ngx-scanner', err.message);\n          // no permissions claimed\n          permission = null;\n          // because there was no devices\n          this.hasDevices.next(false);\n          // tells the listener about the error\n          this.camerasNotFound.next(err);\n          break;\n        case 'NotReadableError':\n          console.warn('@zxing/ngx-scanner', 'Couldn\\'t read the device(s)\\'s stream, it\\'s probably in use by another app.');\n          // no permissions claimed\n          permission = null;\n          // there are devices, which I couldn't use\n          this.hasDevices.next(false);\n          // tells the listener about the error\n          this.camerasNotFound.next(err);\n          break;\n        default:\n          console.warn('@zxing/ngx-scanner', 'I was not able to define if I have permissions for camera or not.', err);\n          // unknown\n          permission = null;\n          // this.hasDevices.next(undefined;\n          break;\n      }\n      this.setPermission(permission);\n      // tells the listener about the error\n      this.permissionResponse.error(err);\n      return permission;\n    }\n    /**\r\n     * Returns a valid BarcodeFormat or fails.\r\n     */\n    getBarcodeFormatOrFail(format) {\n      return typeof format === 'string' ? BarcodeFormat[format.trim().toUpperCase()] : format;\n    }\n    /**\r\n     * Return a code reader, create one if non exist\r\n     */\n    getCodeReader() {\n      if (!this._codeReader) {\n        const options = {\n          delayBetweenScanAttempts: this.timeBetweenScans,\n          delayBetweenScanSuccess: this.delayBetweenScanSuccess\n        };\n        this._codeReader = new BrowserMultiFormatContinuousReader(this.hints, options);\n      }\n      return this._codeReader;\n    }\n    /**\r\n     * Starts the continuous scanning for the given device.\r\n     *\r\n     * @param deviceId The deviceId from the device.\r\n     */\n    scanFromDevice(deviceId) {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        const videoElement = _this7.previewElemRef.nativeElement;\n        const codeReader = _this7.getCodeReader();\n        const scanStream = yield codeReader.scanFromDeviceObservable(deviceId, videoElement);\n        if (!scanStream) {\n          throw new Error('Undefined decoding stream, aborting.');\n        }\n        const next = x => _this7._onDecodeResult(x.result, x.error);\n        const error = err => _this7._onDecodeError(err);\n        const complete = () => {};\n        _this7._scanSubscription = scanStream.subscribe(next, error, complete);\n        if (_this7._scanSubscription.closed) {\n          return;\n        }\n        const controls = codeReader.getScannerControls();\n        const hasTorchControl = typeof controls.switchTorch !== 'undefined';\n        _this7.torchCompatible.next(hasTorchControl);\n      })();\n    }\n    /**\r\n     * Handles decode errors.\r\n     */\n    _onDecodeError(err) {\n      this.dispatchScanError(err);\n      // this.reset();\n    }\n    /**\r\n     * Handles decode results.\r\n     */\n    _onDecodeResult(result, error) {\n      if (result) {\n        this.dispatchScanSuccess(result);\n      } else {\n        this.dispatchScanFailure(error);\n      }\n      this.dispatchScanComplete(result);\n    }\n    /**\r\n     * Stops the code reader and returns the previous selected device.\r\n     */\n    _reset() {\n      if (!this._codeReader) {\n        return;\n      }\n      const device = this._device;\n      // do not set this.device inside this method, it would create a recursive loop\n      this.device = undefined;\n      this._codeReader = undefined;\n      return device;\n    }\n    /**\r\n     * Resets the scanner and emits device change.\r\n     */\n    reset() {\n      this._reset();\n      this.deviceChange.emit(null);\n    }\n    /**\r\n     * Sets the current device.\r\n     */\n    setDevice(device) {\n      var _this8 = this;\n      return _asyncToGenerator(function* () {\n        // instantly stops the scan before changing devices\n        _this8.scanStop();\n        // correctly sets the new (or none) device\n        _this8._device = device || undefined;\n        if (!_this8._device) {\n          // cleans the video because user removed the device\n          BrowserCodeReader.cleanVideoSource(_this8.previewElemRef.nativeElement);\n        }\n        // if enabled, starts scanning\n        if (_this8._enabled && device) {\n          yield _this8.scanFromDevice(device.deviceId);\n        }\n      })();\n    }\n    /**\r\n     * Sets the permission value and emits the event.\r\n     */\n    setPermission(hasPermission) {\n      this.hasPermission = hasPermission;\n      this.permissionResponse.next(hasPermission);\n    }\n  }\n  ZXingScannerComponent.ɵfac = function ZXingScannerComponent_Factory(t) {\n    return new (t || ZXingScannerComponent)();\n  };\n  ZXingScannerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ZXingScannerComponent,\n    selectors: [[\"zxing-scanner\"]],\n    viewQuery: function ZXingScannerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.previewElemRef = _t.first);\n      }\n    },\n    inputs: {\n      autofocusEnabled: \"autofocusEnabled\",\n      timeBetweenScans: \"timeBetweenScans\",\n      delayBetweenScanSuccess: \"delayBetweenScanSuccess\",\n      autostart: \"autostart\",\n      previewFitMode: \"previewFitMode\",\n      device: \"device\",\n      formats: \"formats\",\n      videoConstraints: \"videoConstraints\",\n      torch: \"torch\",\n      enable: \"enable\",\n      tryHarder: \"tryHarder\"\n    },\n    outputs: {\n      autostarted: \"autostarted\",\n      autostarting: \"autostarting\",\n      torchCompatible: \"torchCompatible\",\n      scanSuccess: \"scanSuccess\",\n      scanFailure: \"scanFailure\",\n      scanError: \"scanError\",\n      scanComplete: \"scanComplete\",\n      camerasFound: \"camerasFound\",\n      camerasNotFound: \"camerasNotFound\",\n      permissionResponse: \"permissionResponse\",\n      hasDevices: \"hasDevices\",\n      deviceChange: \"deviceChange\"\n    },\n    decls: 6,\n    vars: 2,\n    consts: [[\"preview\", \"\"]],\n    template: function ZXingScannerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"video\", null, 0)(2, \"p\");\n        i0.ɵɵtext(3, \" Your browser does not support this feature, please try to upgrade it. \");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"p\");\n        i0.ɵɵtext(5, \" Seu navegador n\\xE3o suporta este recurso, por favor tente atualiz\\xE1-lo. \");\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"object-fit\", ctx.previewFitMode);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block}video[_ngcontent-%COMP%]{width:100%;height:auto;object-fit:contain}\"],\n    changeDetection: 0\n  });\n  return ZXingScannerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ZXingScannerModule = /*#__PURE__*/(() => {\n  class ZXingScannerModule {}\n  ZXingScannerModule.ɵfac = function ZXingScannerModule_Factory(t) {\n    return new (t || ZXingScannerModule)();\n  };\n  ZXingScannerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ZXingScannerModule\n  });\n  ZXingScannerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule, FormsModule]\n  });\n  return ZXingScannerModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\r\n * Public API Surface of zxing-scanner\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { ZXingScannerComponent, ZXingScannerModule };\n//# sourceMappingURL=zxing-ngx-scanner.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}