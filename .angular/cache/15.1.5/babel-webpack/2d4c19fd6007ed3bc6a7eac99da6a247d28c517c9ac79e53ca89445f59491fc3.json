{"ast":null,"code":"/*\r\n * Copyright 2010 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/*namespace com.google.zxing.common.detector {*/\nimport ResultPoint from '../../ResultPoint';\nimport MathUtils from './MathUtils';\nimport NotFoundException from '../../NotFoundException';\n/**\r\n * <p>\r\n * Detects a candidate barcode-like rectangular region within an image. It\r\n * starts around the center of the image, increases the size of the candidate\r\n * region until it finds a white rectangular region. By keeping track of the\r\n * last black points it encountered, it determines the corners of the barcode.\r\n * </p>\r\n *\r\n * @author David Olivier\r\n */\nvar WhiteRectangleDetector = /** @class */function () {\n  // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {\n  //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)\n  // }\n  /**\r\n   * @param image barcode image to find a rectangle in\r\n   * @param initSize initial size of search area around center\r\n   * @param x x position of search center\r\n   * @param y y position of search center\r\n   * @throws NotFoundException if image is too small to accommodate {@code initSize}\r\n   */\n  function WhiteRectangleDetector(image, initSize /*int*/, x /*int*/, y /*int*/) {\n    this.image = image;\n    this.height = image.getHeight();\n    this.width = image.getWidth();\n    if (undefined === initSize || null === initSize) {\n      initSize = WhiteRectangleDetector.INIT_SIZE;\n    }\n    if (undefined === x || null === x) {\n      x = image.getWidth() / 2 | 0;\n    }\n    if (undefined === y || null === y) {\n      y = image.getHeight() / 2 | 0;\n    }\n    var halfsize = initSize / 2 | 0;\n    this.leftInit = x - halfsize;\n    this.rightInit = x + halfsize;\n    this.upInit = y - halfsize;\n    this.downInit = y + halfsize;\n    if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {\n      throw new NotFoundException();\n    }\n  }\n  /**\r\n   * <p>\r\n   * Detects a candidate barcode-like rectangular region within an image. It\r\n   * starts around the center of the image, increases the size of the candidate\r\n   * region until it finds a white rectangular region.\r\n   * </p>\r\n   *\r\n   * @return {@link ResultPoint}[] describing the corners of the rectangular\r\n   *         region. The first and last points are opposed on the diagonal, as\r\n   *         are the second and third. The first point will be the topmost\r\n   *         point and the last, the bottommost. The second point will be\r\n   *         leftmost and the third, the rightmost\r\n   * @throws NotFoundException if no Data Matrix Code can be found\r\n   */\n  WhiteRectangleDetector.prototype.detect = function () {\n    var left = this.leftInit;\n    var right = this.rightInit;\n    var up = this.upInit;\n    var down = this.downInit;\n    var sizeExceeded = false;\n    var aBlackPointFoundOnBorder = true;\n    var atLeastOneBlackPointFoundOnBorder = false;\n    var atLeastOneBlackPointFoundOnRight = false;\n    var atLeastOneBlackPointFoundOnBottom = false;\n    var atLeastOneBlackPointFoundOnLeft = false;\n    var atLeastOneBlackPointFoundOnTop = false;\n    var width = this.width;\n    var height = this.height;\n    while (aBlackPointFoundOnBorder) {\n      aBlackPointFoundOnBorder = false;\n      // .....\n      // .   |\n      // .....\n      var rightBorderNotWhite = true;\n      while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n        rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);\n        if (rightBorderNotWhite) {\n          right++;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnRight = true;\n        } else if (!atLeastOneBlackPointFoundOnRight) {\n          right++;\n        }\n      }\n      if (right >= width) {\n        sizeExceeded = true;\n        break;\n      }\n      // .....\n      // .   .\n      // .___.\n      var bottomBorderNotWhite = true;\n      while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n        bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);\n        if (bottomBorderNotWhite) {\n          down++;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnBottom = true;\n        } else if (!atLeastOneBlackPointFoundOnBottom) {\n          down++;\n        }\n      }\n      if (down >= height) {\n        sizeExceeded = true;\n        break;\n      }\n      // .....\n      // |   .\n      // .....\n      var leftBorderNotWhite = true;\n      while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n        leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);\n        if (leftBorderNotWhite) {\n          left--;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnLeft = true;\n        } else if (!atLeastOneBlackPointFoundOnLeft) {\n          left--;\n        }\n      }\n      if (left < 0) {\n        sizeExceeded = true;\n        break;\n      }\n      // .___.\n      // .   .\n      // .....\n      var topBorderNotWhite = true;\n      while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n        topBorderNotWhite = this.containsBlackPoint(left, right, up, true);\n        if (topBorderNotWhite) {\n          up--;\n          aBlackPointFoundOnBorder = true;\n          atLeastOneBlackPointFoundOnTop = true;\n        } else if (!atLeastOneBlackPointFoundOnTop) {\n          up--;\n        }\n      }\n      if (up < 0) {\n        sizeExceeded = true;\n        break;\n      }\n      if (aBlackPointFoundOnBorder) {\n        atLeastOneBlackPointFoundOnBorder = true;\n      }\n    }\n    if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {\n      var maxSize = right - left;\n      var z = null;\n      for (var i = 1; z === null && i < maxSize; i++) {\n        z = this.getBlackPointOnSegment(left, down - i, left + i, down);\n      }\n      if (z == null) {\n        throw new NotFoundException();\n      }\n      var t = null;\n      // go down right\n      for (var i = 1; t === null && i < maxSize; i++) {\n        t = this.getBlackPointOnSegment(left, up + i, left + i, up);\n      }\n      if (t == null) {\n        throw new NotFoundException();\n      }\n      var x = null;\n      // go down left\n      for (var i = 1; x === null && i < maxSize; i++) {\n        x = this.getBlackPointOnSegment(right, up + i, right - i, up);\n      }\n      if (x == null) {\n        throw new NotFoundException();\n      }\n      var y = null;\n      // go up left\n      for (var i = 1; y === null && i < maxSize; i++) {\n        y = this.getBlackPointOnSegment(right, down - i, right - i, down);\n      }\n      if (y == null) {\n        throw new NotFoundException();\n      }\n      return this.centerEdges(y, z, x, t);\n    } else {\n      throw new NotFoundException();\n    }\n  };\n  WhiteRectangleDetector.prototype.getBlackPointOnSegment = function (aX /*float*/, aY /*float*/, bX /*float*/, bY /*float*/) {\n    var dist = MathUtils.round(MathUtils.distance(aX, aY, bX, bY));\n    var xStep = (bX - aX) / dist;\n    var yStep = (bY - aY) / dist;\n    var image = this.image;\n    for (var i = 0; i < dist; i++) {\n      var x = MathUtils.round(aX + i * xStep);\n      var y = MathUtils.round(aY + i * yStep);\n      if (image.get(x, y)) {\n        return new ResultPoint(x, y);\n      }\n    }\n    return null;\n  };\n  /**\r\n   * recenters the points of a constant distance towards the center\r\n   *\r\n   * @param y bottom most point\r\n   * @param z left most point\r\n   * @param x right most point\r\n   * @param t top most point\r\n   * @return {@link ResultPoint}[] describing the corners of the rectangular\r\n   *         region. The first and last points are opposed on the diagonal, as\r\n   *         are the second and third. The first point will be the topmost\r\n   *         point and the last, the bottommost. The second point will be\r\n   *         leftmost and the third, the rightmost\r\n   */\n  WhiteRectangleDetector.prototype.centerEdges = function (y, z, x, t) {\n    //\n    //       t            t\n    //  z                      x\n    //        x    OR    z\n    //   y                    y\n    //\n    var yi = y.getX();\n    var yj = y.getY();\n    var zi = z.getX();\n    var zj = z.getY();\n    var xi = x.getX();\n    var xj = x.getY();\n    var ti = t.getX();\n    var tj = t.getY();\n    var CORR = WhiteRectangleDetector.CORR;\n    if (yi < this.width / 2.0) {\n      return [new ResultPoint(ti - CORR, tj + CORR), new ResultPoint(zi + CORR, zj + CORR), new ResultPoint(xi - CORR, xj - CORR), new ResultPoint(yi + CORR, yj - CORR)];\n    } else {\n      return [new ResultPoint(ti + CORR, tj + CORR), new ResultPoint(zi + CORR, zj - CORR), new ResultPoint(xi - CORR, xj + CORR), new ResultPoint(yi - CORR, yj - CORR)];\n    }\n  };\n  /**\r\n   * Determines whether a segment contains a black point\r\n   *\r\n   * @param a          min value of the scanned coordinate\r\n   * @param b          max value of the scanned coordinate\r\n   * @param fixed      value of fixed coordinate\r\n   * @param horizontal set to true if scan must be horizontal, false if vertical\r\n   * @return true if a black point has been found, else false.\r\n   */\n  WhiteRectangleDetector.prototype.containsBlackPoint = function (a /*int*/, b /*int*/, fixed /*int*/, horizontal) {\n    var image = this.image;\n    if (horizontal) {\n      for (var x = a; x <= b; x++) {\n        if (image.get(x, fixed)) {\n          return true;\n        }\n      }\n    } else {\n      for (var y = a; y <= b; y++) {\n        if (image.get(fixed, y)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  WhiteRectangleDetector.INIT_SIZE = 10;\n  WhiteRectangleDetector.CORR = 1;\n  return WhiteRectangleDetector;\n}();\nexport default WhiteRectangleDetector;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}