{"ast":null,"code":"/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nimport Version from './Version';\nimport FormatInformation from './FormatInformation';\nimport DataMask from './DataMask';\nimport FormatException from '../../FormatException';\n/**\r\n * @author Sean Owen\r\n */\nvar BitMatrixParser = /** @class */function () {\n  /**\r\n   * @param bitMatrix {@link BitMatrix} to parse\r\n   * @throws FormatException if dimension is not >= 21 and 1 mod 4\r\n   */\n  function BitMatrixParser(bitMatrix) {\n    var dimension = bitMatrix.getHeight();\n    if (dimension < 21 || (dimension & 0x03) !== 1) {\n      throw new FormatException();\n    }\n    this.bitMatrix = bitMatrix;\n  }\n  /**\r\n   * <p>Reads format information from one of its two locations within the QR Code.</p>\r\n   *\r\n   * @return {@link FormatInformation} encapsulating the QR Code's format info\r\n   * @throws FormatException if both format information locations cannot be parsed as\r\n   * the valid encoding of format information\r\n   */\n  BitMatrixParser.prototype.readFormatInformation = function () {\n    if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {\n      return this.parsedFormatInfo;\n    }\n    // Read top-left format info bits\n    var formatInfoBits1 = 0;\n    for (var i = 0; i < 6; i++) {\n      formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);\n    }\n    // .. and skip a bit in the timing pattern ...\n    formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);\n    formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);\n    formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);\n    // .. and skip a bit in the timing pattern ...\n    for (var j = 5; j >= 0; j--) {\n      formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);\n    }\n    // Read the top-right/bottom-left pattern too\n    var dimension = this.bitMatrix.getHeight();\n    var formatInfoBits2 = 0;\n    var jMin = dimension - 7;\n    for (var j = dimension - 1; j >= jMin; j--) {\n      formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);\n    }\n    for (var i = dimension - 8; i < dimension; i++) {\n      formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);\n    }\n    this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);\n    if (this.parsedFormatInfo !== null) {\n      return this.parsedFormatInfo;\n    }\n    throw new FormatException();\n  };\n  /**\r\n   * <p>Reads version information from one of its two locations within the QR Code.</p>\r\n   *\r\n   * @return {@link Version} encapsulating the QR Code's version\r\n   * @throws FormatException if both version information locations cannot be parsed as\r\n   * the valid encoding of version information\r\n   */\n  BitMatrixParser.prototype.readVersion = function () {\n    if (this.parsedVersion !== null && this.parsedVersion !== undefined) {\n      return this.parsedVersion;\n    }\n    var dimension = this.bitMatrix.getHeight();\n    var provisionalVersion = Math.floor((dimension - 17) / 4);\n    if (provisionalVersion <= 6) {\n      return Version.getVersionForNumber(provisionalVersion);\n    }\n    // Read top-right version info: 3 wide by 6 tall\n    var versionBits = 0;\n    var ijMin = dimension - 11;\n    for (var j = 5; j >= 0; j--) {\n      for (var i = dimension - 9; i >= ijMin; i--) {\n        versionBits = this.copyBit(i, j, versionBits);\n      }\n    }\n    var theParsedVersion = Version.decodeVersionInformation(versionBits);\n    if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n      this.parsedVersion = theParsedVersion;\n      return theParsedVersion;\n    }\n    // Hmm, failed. Try bottom left: 6 wide by 3 tall\n    versionBits = 0;\n    for (var i = 5; i >= 0; i--) {\n      for (var j = dimension - 9; j >= ijMin; j--) {\n        versionBits = this.copyBit(i, j, versionBits);\n      }\n    }\n    theParsedVersion = Version.decodeVersionInformation(versionBits);\n    if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n      this.parsedVersion = theParsedVersion;\n      return theParsedVersion;\n    }\n    throw new FormatException();\n  };\n  BitMatrixParser.prototype.copyBit = function (i /*int*/, j /*int*/, versionBits /*int*/) {\n    var bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);\n    return bit ? versionBits << 1 | 0x1 : versionBits << 1;\n  };\n  /**\r\n   * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the\r\n   * correct order in order to reconstruct the codewords bytes contained within the\r\n   * QR Code.</p>\r\n   *\r\n   * @return bytes encoded within the QR Code\r\n   * @throws FormatException if the exact number of bytes expected is not read\r\n   */\n  BitMatrixParser.prototype.readCodewords = function () {\n    var formatInfo = this.readFormatInformation();\n    var version = this.readVersion();\n    // Get the data mask for the format used in this QR Code. This will exclude\n    // some bits from reading as we wind through the bit matrix.\n    var dataMask = DataMask.values.get(formatInfo.getDataMask());\n    var dimension = this.bitMatrix.getHeight();\n    dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n    var functionPattern = version.buildFunctionPattern();\n    var readingUp = true;\n    var result = new Uint8Array(version.getTotalCodewords());\n    var resultOffset = 0;\n    var currentByte = 0;\n    var bitsRead = 0;\n    // Read columns in pairs, from right to left\n    for (var j = dimension - 1; j > 0; j -= 2) {\n      if (j === 6) {\n        // Skip whole column with vertical alignment pattern\n        // saves time and makes the other code proceed more cleanly\n        j--;\n      }\n      // Read alternatingly from bottom to top then top to bottom\n      for (var count = 0; count < dimension; count++) {\n        var i = readingUp ? dimension - 1 - count : count;\n        for (var col = 0; col < 2; col++) {\n          // Ignore bits covered by the function pattern\n          if (!functionPattern.get(j - col, i)) {\n            // Read a bit\n            bitsRead++;\n            currentByte <<= 1;\n            if (this.bitMatrix.get(j - col, i)) {\n              currentByte |= 1;\n            }\n            // If we've made a whole byte, save it off\n            if (bitsRead === 8) {\n              result[resultOffset++] = /*(byte) */currentByte;\n              bitsRead = 0;\n              currentByte = 0;\n            }\n          }\n        }\n      }\n      readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions\n    }\n\n    if (resultOffset !== version.getTotalCodewords()) {\n      throw new FormatException();\n    }\n    return result;\n  };\n  /**\r\n   * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.\r\n   */\n  BitMatrixParser.prototype.remask = function () {\n    if (this.parsedFormatInfo === null) {\n      return; // We have no format information, and have no data mask\n    }\n\n    var dataMask = DataMask.values[this.parsedFormatInfo.getDataMask()];\n    var dimension = this.bitMatrix.getHeight();\n    dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n  };\n  /**\r\n   * Prepare the parser for a mirrored operation.\r\n   * This flag has effect only on the {@link #readFormatInformation()} and the\r\n   * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the\r\n   * {@link #mirror()} method should be called.\r\n   *\r\n   * @param mirror Whether to read version and format information mirrored.\r\n   */\n  BitMatrixParser.prototype.setMirror = function (isMirror) {\n    this.parsedVersion = null;\n    this.parsedFormatInfo = null;\n    this.isMirror = isMirror;\n  };\n  /** Mirror the bit matrix in order to attempt a second reading. */\n  BitMatrixParser.prototype.mirror = function () {\n    var bitMatrix = this.bitMatrix;\n    for (var x = 0, width = bitMatrix.getWidth(); x < width; x++) {\n      for (var y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {\n        if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {\n          bitMatrix.flip(y, x);\n          bitMatrix.flip(x, y);\n        }\n      }\n    }\n  };\n  return BitMatrixParser;\n}();\nexport default BitMatrixParser;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}