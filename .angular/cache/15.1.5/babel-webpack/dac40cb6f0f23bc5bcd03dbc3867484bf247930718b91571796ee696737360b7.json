{"ast":null,"code":"/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/*namespace com.google.zxing.common.reedsolomon {*/\nimport GenericGF from './GenericGF';\nimport GenericGFPoly from './GenericGFPoly';\nimport ReedSolomonException from '../../ReedSolomonException';\nimport IllegalStateException from '../../IllegalStateException';\n/**\r\n * <p>Implements Reed-Solomon decoding, as the name implies.</p>\r\n *\r\n * <p>The algorithm will not be explained here, but the following references were helpful\r\n * in creating this implementation:</p>\r\n *\r\n * <ul>\r\n * <li>Bruce Maggs.\r\n * <a href=\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps\">\r\n * \"Decoding Reed-Solomon Codes\"</a> (see discussion of Forney's Formula)</li>\r\n * <li>J.I. Hall. <a href=\"www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf\">\r\n * \"Chapter 5. Generalized Reed-Solomon Codes\"</a>\r\n * (see discussion of Euclidean algorithm)</li>\r\n * </ul>\r\n *\r\n * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\r\n * port of his C++ Reed-Solomon implementation.</p>\r\n *\r\n * @author Sean Owen\r\n * @author William Rucklidge\r\n * @author sanfordsquires\r\n */\nvar ReedSolomonDecoder = /** @class */function () {\n  function ReedSolomonDecoder(field) {\n    this.field = field;\n  }\n  /**\r\n   * <p>Decodes given set of received codewords, which include both data and error-correction\r\n   * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,\r\n   * in the input.</p>\r\n   *\r\n   * @param received data and error-correction codewords\r\n   * @param twoS number of error-correction codewords available\r\n   * @throws ReedSolomonException if decoding fails for any reason\r\n   */\n  ReedSolomonDecoder.prototype.decode = function (received, twoS /*int*/) {\n    var field = this.field;\n    var poly = new GenericGFPoly(field, received);\n    var syndromeCoefficients = new Int32Array(twoS);\n    var noError = true;\n    for (var i = 0; i < twoS; i++) {\n      var evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));\n      syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;\n      if (evalResult !== 0) {\n        noError = false;\n      }\n    }\n    if (noError) {\n      return;\n    }\n    var syndrome = new GenericGFPoly(field, syndromeCoefficients);\n    var sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);\n    var sigma = sigmaOmega[0];\n    var omega = sigmaOmega[1];\n    var errorLocations = this.findErrorLocations(sigma);\n    var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);\n    for (var i = 0; i < errorLocations.length; i++) {\n      var position = received.length - 1 - field.log(errorLocations[i]);\n      if (position < 0) {\n        throw new ReedSolomonException('Bad error location');\n      }\n      received[position] = GenericGF.addOrSubtract(received[position], errorMagnitudes[i]);\n    }\n  };\n  ReedSolomonDecoder.prototype.runEuclideanAlgorithm = function (a, b, R /*int*/) {\n    // Assume a's degree is >= b's\n    if (a.getDegree() < b.getDegree()) {\n      var temp = a;\n      a = b;\n      b = temp;\n    }\n    var field = this.field;\n    var rLast = a;\n    var r = b;\n    var tLast = field.getZero();\n    var t = field.getOne();\n    // Run Euclidean algorithm until r's degree is less than R/2\n    while (r.getDegree() >= (R / 2 | 0)) {\n      var rLastLast = rLast;\n      var tLastLast = tLast;\n      rLast = r;\n      tLast = t;\n      // Divide rLastLast by rLast, with quotient in q and remainder in r\n      if (rLast.isZero()) {\n        // Oops, Euclidean algorithm already terminated?\n        throw new ReedSolomonException('r_{i-1} was zero');\n      }\n      r = rLastLast;\n      var q = field.getZero();\n      var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n      var dltInverse = field.inverse(denominatorLeadingTerm);\n      while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n        var degreeDiff = r.getDegree() - rLast.getDegree();\n        var scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n        q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));\n        r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));\n      }\n      t = q.multiply(tLast).addOrSubtract(tLastLast);\n      if (r.getDegree() >= rLast.getDegree()) {\n        throw new IllegalStateException('Division algorithm failed to reduce polynomial?');\n      }\n    }\n    var sigmaTildeAtZero = t.getCoefficient(0);\n    if (sigmaTildeAtZero === 0) {\n      throw new ReedSolomonException('sigmaTilde(0) was zero');\n    }\n    var inverse = field.inverse(sigmaTildeAtZero);\n    var sigma = t.multiplyScalar(inverse);\n    var omega = r.multiplyScalar(inverse);\n    return [sigma, omega];\n  };\n  ReedSolomonDecoder.prototype.findErrorLocations = function (errorLocator) {\n    // This is a direct application of Chien's search\n    var numErrors = errorLocator.getDegree();\n    if (numErrors === 1) {\n      // shortcut\n      return Int32Array.from([errorLocator.getCoefficient(1)]);\n    }\n    var result = new Int32Array(numErrors);\n    var e = 0;\n    var field = this.field;\n    for (var i = 1; i < field.getSize() && e < numErrors; i++) {\n      if (errorLocator.evaluateAt(i) === 0) {\n        result[e] = field.inverse(i);\n        e++;\n      }\n    }\n    if (e !== numErrors) {\n      throw new ReedSolomonException('Error locator degree does not match number of roots');\n    }\n    return result;\n  };\n  ReedSolomonDecoder.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocations) {\n    // This is directly applying Forney's Formula\n    var s = errorLocations.length;\n    var result = new Int32Array(s);\n    var field = this.field;\n    for (var i = 0; i < s; i++) {\n      var xiInverse = field.inverse(errorLocations[i]);\n      var denominator = 1;\n      for (var j = 0; j < s; j++) {\n        if (i !== j) {\n          // denominator = field.multiply(denominator,\n          //    GenericGF.addOrSubtract(1, field.multiply(errorLocations[j], xiInverse)))\n          // Above should work but fails on some Apple and Linux JDKs due to a Hotspot bug.\n          // Below is a funny-looking workaround from Steven Parkes\n          var term = field.multiply(errorLocations[j], xiInverse);\n          var termPlus1 = (term & 0x1) === 0 ? term | 1 : term & ~1;\n          denominator = field.multiply(denominator, termPlus1);\n        }\n      }\n      result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));\n      if (field.getGeneratorBase() !== 0) {\n        result[i] = field.multiply(result[i], xiInverse);\n      }\n    }\n    return result;\n  };\n  return ReedSolomonDecoder;\n}();\nexport default ReedSolomonDecoder;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}