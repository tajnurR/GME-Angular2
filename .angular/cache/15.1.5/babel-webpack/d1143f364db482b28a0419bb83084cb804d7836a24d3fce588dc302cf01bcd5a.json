{"ast":null,"code":"/*\r\n * Copyright 2010 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nimport DecoderResult from '../../common/DecoderResult';\nimport GenericGF from '../../common/reedsolomon/GenericGF';\nimport ReedSolomonDecoder from '../../common/reedsolomon/ReedSolomonDecoder';\nimport IllegalStateException from '../../IllegalStateException';\nimport FormatException from '../../FormatException';\nimport StringUtils from '../../common/StringUtils';\nimport Integer from '../../util/Integer';\n// import java.util.Arrays;\nvar Table = /*#__PURE__*/(() => {\n  (function (Table) {\n    Table[Table[\"UPPER\"] = 0] = \"UPPER\";\n    Table[Table[\"LOWER\"] = 1] = \"LOWER\";\n    Table[Table[\"MIXED\"] = 2] = \"MIXED\";\n    Table[Table[\"DIGIT\"] = 3] = \"DIGIT\";\n    Table[Table[\"PUNCT\"] = 4] = \"PUNCT\";\n    Table[Table[\"BINARY\"] = 5] = \"BINARY\";\n  })(Table || (Table = {}));\n  return Table;\n})();\n/**\r\n * <p>The main class which implements Aztec Code decoding -- as opposed to locating and extracting\r\n * the Aztec Code from an image.</p>\r\n *\r\n * @author David Olivier\r\n */\nvar Decoder = /** @class */function () {\n  function Decoder() {}\n  Decoder.prototype.decode = function (detectorResult) {\n    this.ddata = detectorResult;\n    var matrix = detectorResult.getBits();\n    var rawbits = this.extractBits(matrix);\n    var correctedBits = this.correctBits(rawbits);\n    var rawBytes = Decoder.convertBoolArrayToByteArray(correctedBits);\n    var result = Decoder.getEncodedData(correctedBits);\n    var decoderResult = new DecoderResult(rawBytes, result, null, null);\n    decoderResult.setNumBits(correctedBits.length);\n    return decoderResult;\n  };\n  // This method is used for testing the high-level encoder\n  Decoder.highLevelDecode = function (correctedBits) {\n    return this.getEncodedData(correctedBits);\n  };\n  /**\r\n   * Gets the string encoded in the aztec code bits\r\n   *\r\n   * @return the decoded string\r\n   */\n  Decoder.getEncodedData = function (correctedBits) {\n    var endIndex = correctedBits.length;\n    var latchTable = Table.UPPER; // table most recently latched to\n    var shiftTable = Table.UPPER; // table to use for the next read\n    var result = '';\n    var index = 0;\n    while (index < endIndex) {\n      if (shiftTable === Table.BINARY) {\n        if (endIndex - index < 5) {\n          break;\n        }\n        var length_1 = Decoder.readCode(correctedBits, index, 5);\n        index += 5;\n        if (length_1 === 0) {\n          if (endIndex - index < 11) {\n            break;\n          }\n          length_1 = Decoder.readCode(correctedBits, index, 11) + 31;\n          index += 11;\n        }\n        for (var charCount = 0; charCount < length_1; charCount++) {\n          if (endIndex - index < 8) {\n            index = endIndex; // Force outer loop to exit\n            break;\n          }\n          var code = Decoder.readCode(correctedBits, index, 8);\n          result += /*(char)*/StringUtils.castAsNonUtf8Char(code);\n          index += 8;\n        }\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      } else {\n        var size = shiftTable === Table.DIGIT ? 4 : 5;\n        if (endIndex - index < size) {\n          break;\n        }\n        var code = Decoder.readCode(correctedBits, index, size);\n        index += size;\n        var str = Decoder.getCharacter(shiftTable, code);\n        if (str.startsWith('CTRL_')) {\n          // Table changes\n          // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n          // That's including when that mode is a shift.\n          // Our test case dlusbs.png for issue #642 exercises that.\n          latchTable = shiftTable; // Latch the current mode, so as to return to Upper after U/S B/S\n          shiftTable = Decoder.getTable(str.charAt(5));\n          if (str.charAt(6) === 'L') {\n            latchTable = shiftTable;\n          }\n        } else {\n          result += str;\n          // Go back to whatever mode we had been in\n          shiftTable = latchTable;\n        }\n      }\n    }\n    return result;\n  };\n  /**\r\n   * gets the table corresponding to the char passed\r\n   */\n  Decoder.getTable = function (t) {\n    switch (t) {\n      case 'L':\n        return Table.LOWER;\n      case 'P':\n        return Table.PUNCT;\n      case 'M':\n        return Table.MIXED;\n      case 'D':\n        return Table.DIGIT;\n      case 'B':\n        return Table.BINARY;\n      case 'U':\n      default:\n        return Table.UPPER;\n    }\n  };\n  /**\r\n   * Gets the character (or string) corresponding to the passed code in the given table\r\n   *\r\n   * @param table the table used\r\n   * @param code the code of the character\r\n   */\n  Decoder.getCharacter = function (table, code) {\n    switch (table) {\n      case Table.UPPER:\n        return Decoder.UPPER_TABLE[code];\n      case Table.LOWER:\n        return Decoder.LOWER_TABLE[code];\n      case Table.MIXED:\n        return Decoder.MIXED_TABLE[code];\n      case Table.PUNCT:\n        return Decoder.PUNCT_TABLE[code];\n      case Table.DIGIT:\n        return Decoder.DIGIT_TABLE[code];\n      default:\n        // Should not reach here.\n        throw new IllegalStateException('Bad table');\n    }\n  };\n  /**\r\n   * <p>Performs RS error correction on an array of bits.</p>\r\n   *\r\n   * @return the corrected array\r\n   * @throws FormatException if the input contains too many errors\r\n   */\n  Decoder.prototype.correctBits = function (rawbits) {\n    var gf;\n    var codewordSize;\n    if (this.ddata.getNbLayers() <= 2) {\n      codewordSize = 6;\n      gf = GenericGF.AZTEC_DATA_6;\n    } else if (this.ddata.getNbLayers() <= 8) {\n      codewordSize = 8;\n      gf = GenericGF.AZTEC_DATA_8;\n    } else if (this.ddata.getNbLayers() <= 22) {\n      codewordSize = 10;\n      gf = GenericGF.AZTEC_DATA_10;\n    } else {\n      codewordSize = 12;\n      gf = GenericGF.AZTEC_DATA_12;\n    }\n    var numDataCodewords = this.ddata.getNbDatablocks();\n    var numCodewords = rawbits.length / codewordSize;\n    if (numCodewords < numDataCodewords) {\n      throw new FormatException();\n    }\n    var offset = rawbits.length % codewordSize;\n    var dataWords = new Int32Array(numCodewords);\n    for (var i = 0; i < numCodewords; i++, offset += codewordSize) {\n      dataWords[i] = Decoder.readCode(rawbits, offset, codewordSize);\n    }\n    try {\n      var rsDecoder = new ReedSolomonDecoder(gf);\n      rsDecoder.decode(dataWords, numCodewords - numDataCodewords);\n    } catch (ex) {\n      throw new FormatException(ex);\n    }\n    // Now perform the unstuffing operation.\n    // First, count how many bits are going to be thrown out as stuffing\n    var mask = (1 << codewordSize) - 1;\n    var stuffedBits = 0;\n    for (var i = 0; i < numDataCodewords; i++) {\n      var dataWord = dataWords[i];\n      if (dataWord === 0 || dataWord === mask) {\n        throw new FormatException();\n      } else if (dataWord === 1 || dataWord === mask - 1) {\n        stuffedBits++;\n      }\n    }\n    // Now, actually unpack the bits and remove the stuffing\n    var correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);\n    var index = 0;\n    for (var i = 0; i < numDataCodewords; i++) {\n      var dataWord = dataWords[i];\n      if (dataWord === 1 || dataWord === mask - 1) {\n        // next codewordSize-1 bits are all zeros or all ones\n        correctedBits.fill(dataWord > 1, index, index + codewordSize - 1);\n        // Arrays.fill(correctedBits, index, index + codewordSize - 1, dataWord > 1);\n        index += codewordSize - 1;\n      } else {\n        for (var bit = codewordSize - 1; bit >= 0; --bit) {\n          correctedBits[index++] = (dataWord & 1 << bit) !== 0;\n        }\n      }\n    }\n    return correctedBits;\n  };\n  /**\r\n   * Gets the array of bits from an Aztec Code matrix\r\n   *\r\n   * @return the array of bits\r\n   */\n  Decoder.prototype.extractBits = function (matrix) {\n    var compact = this.ddata.isCompact();\n    var layers = this.ddata.getNbLayers();\n    var baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n    var alignmentMap = new Int32Array(baseMatrixSize);\n    var rawbits = new Array(this.totalBitsInLayer(layers, compact));\n    if (compact) {\n      for (var i = 0; i < alignmentMap.length; i++) {\n        alignmentMap[i] = i;\n      }\n    } else {\n      var matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);\n      var origCenter = baseMatrixSize / 2;\n      var center = Integer.truncDivision(matrixSize, 2);\n      for (var i = 0; i < origCenter; i++) {\n        var newOffset = i + Integer.truncDivision(i, 15);\n        alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n        alignmentMap[origCenter + i] = center + newOffset + 1;\n      }\n    }\n    for (var i = 0, rowOffset = 0; i < layers; i++) {\n      var rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n      // The top-left most point of this layer is <low, low> (not including alignment lines)\n      var low = i * 2;\n      // The bottom-right most point of this layer is <high, high> (not including alignment lines)\n      var high = baseMatrixSize - 1 - low;\n      // We pull bits from the two 2 x rowSize columns and two rowSize x 2 rows\n      for (var j = 0; j < rowSize; j++) {\n        var columnOffset = j * 2;\n        for (var k = 0; k < 2; k++) {\n          // left column\n          rawbits[rowOffset + columnOffset + k] = matrix.get(alignmentMap[low + k], alignmentMap[low + j]);\n          // bottom row\n          rawbits[rowOffset + 2 * rowSize + columnOffset + k] = matrix.get(alignmentMap[low + j], alignmentMap[high - k]);\n          // right column\n          rawbits[rowOffset + 4 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - k], alignmentMap[high - j]);\n          // top row\n          rawbits[rowOffset + 6 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - j], alignmentMap[low + k]);\n        }\n      }\n      rowOffset += rowSize * 8;\n    }\n    return rawbits;\n  };\n  /**\r\n   * Reads a code of given length and at given index in an array of bits\r\n   */\n  Decoder.readCode = function (rawbits, startIndex, length) {\n    var res = 0;\n    for (var i = startIndex; i < startIndex + length; i++) {\n      res <<= 1;\n      if (rawbits[i]) {\n        res |= 0x01;\n      }\n    }\n    return res;\n  };\n  /**\r\n   * Reads a code of length 8 in an array of bits, padding with zeros\r\n   */\n  Decoder.readByte = function (rawbits, startIndex) {\n    var n = rawbits.length - startIndex;\n    if (n >= 8) {\n      return Decoder.readCode(rawbits, startIndex, 8);\n    }\n    return Decoder.readCode(rawbits, startIndex, n) << 8 - n;\n  };\n  /**\r\n   * Packs a bit array into bytes, most significant bit first\r\n   */\n  Decoder.convertBoolArrayToByteArray = function (boolArr) {\n    var byteArr = new Uint8Array((boolArr.length + 7) / 8);\n    for (var i = 0; i < byteArr.length; i++) {\n      byteArr[i] = Decoder.readByte(boolArr, 8 * i);\n    }\n    return byteArr;\n  };\n  Decoder.prototype.totalBitsInLayer = function (layers, compact) {\n    return ((compact ? 88 : 112) + 16 * layers) * layers;\n  };\n  Decoder.UPPER_TABLE = ['CTRL_PS', ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'CTRL_LL', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'];\n  Decoder.LOWER_TABLE = ['CTRL_PS', ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'CTRL_US', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'];\n  Decoder.MIXED_TABLE = [\n  // Module parse failed: Octal literal in strict mode (50:29)\n  // so number string were scaped\n  'CTRL_PS', ' ', '\\\\1', '\\\\2', '\\\\3', '\\\\4', '\\\\5', '\\\\6', '\\\\7', '\\b', '\\t', '\\n', '\\\\13', '\\f', '\\r', '\\\\33', '\\\\34', '\\\\35', '\\\\36', '\\\\37', '@', '\\\\', '^', '_', '`', '|', '~', '\\\\177', 'CTRL_LL', 'CTRL_UL', 'CTRL_PL', 'CTRL_BS'];\n  Decoder.PUNCT_TABLE = ['', '\\r', '\\r\\n', '. ', ', ', ': ', '!', '\"', '#', '$', '%', '&', '\\'', '(', ')', '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '[', ']', '{', '}', 'CTRL_UL'];\n  Decoder.DIGIT_TABLE = ['CTRL_PS', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', '.', 'CTRL_UL', 'CTRL_US'];\n  return Decoder;\n}();\nexport default Decoder;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}