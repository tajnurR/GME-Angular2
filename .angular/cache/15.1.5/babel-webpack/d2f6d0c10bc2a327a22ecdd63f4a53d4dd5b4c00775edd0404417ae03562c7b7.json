{"ast":null,"code":"var __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport BitArray from '../../common/BitArray';\nimport IllegalArgumentException from '../../IllegalArgumentException';\nimport StringUtils from '../../common/StringUtils';\nimport BitMatrix from '../../common/BitMatrix';\nimport AztecCode from './AztecCode';\nimport ReedSolomonEncoder from '../../common/reedsolomon/ReedSolomonEncoder';\nimport GenericGF from '../../common/reedsolomon/GenericGF';\nimport HighLevelEncoder from './HighLevelEncoder';\nimport Integer from '../../util/Integer';\n/*\r\n * Copyright 2013 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n// package com.google.zxing.aztec.encoder;\n// import com.google.zxing.common.BitArray;\n// import com.google.zxing.common.BitMatrix;\n// import com.google.zxing.common.reedsolomon.GenericGF;\n// import com.google.zxing.common.reedsolomon.ReedSolomonEncoder;\n/**\r\n * Generates Aztec 2D barcodes.\r\n *\r\n * @author Rustam Abdullaev\r\n */\nvar Encoder = /** @class */function () {\n  function Encoder() {}\n  /**\r\n   * Encodes the given binary content as an Aztec symbol\r\n   *\r\n   * @param data input data string\r\n   * @return Aztec symbol matrix with metadata\r\n   */\n  Encoder.encodeBytes = function (data) {\n    return Encoder.encode(data, Encoder.DEFAULT_EC_PERCENT, Encoder.DEFAULT_AZTEC_LAYERS);\n  };\n  /**\r\n   * Encodes the given binary content as an Aztec symbol\r\n   *\r\n   * @param data input data string\r\n   * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,\r\n   *                      a minimum of 23% + 3 words is recommended)\r\n   * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers\r\n   * @return Aztec symbol matrix with metadata\r\n   */\n  Encoder.encode = function (data, minECCPercent, userSpecifiedLayers) {\n    // High-level encode\n    var bits = new HighLevelEncoder(data).encode();\n    // stuff bits and choose symbol size\n    var eccBits = Integer.truncDivision(bits.getSize() * minECCPercent, 100) + 11;\n    var totalSizeBits = bits.getSize() + eccBits;\n    var compact;\n    var layers;\n    var totalBitsInLayer;\n    var wordSize;\n    var stuffedBits;\n    if (userSpecifiedLayers !== Encoder.DEFAULT_AZTEC_LAYERS) {\n      compact = userSpecifiedLayers < 0;\n      layers = Math.abs(userSpecifiedLayers);\n      if (layers > (compact ? Encoder.MAX_NB_BITS_COMPACT : Encoder.MAX_NB_BITS)) {\n        throw new IllegalArgumentException(StringUtils.format('Illegal value %s for layers', userSpecifiedLayers));\n      }\n      totalBitsInLayer = Encoder.totalBitsInLayer(layers, compact);\n      wordSize = Encoder.WORD_SIZE[layers];\n      var usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;\n      stuffedBits = Encoder.stuffBits(bits, wordSize);\n      if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {\n        throw new IllegalArgumentException('Data to large for user specified layer');\n      }\n      if (compact && stuffedBits.getSize() > wordSize * 64) {\n        // Compact format only allows 64 data words, though C4 can hold more words than that\n        throw new IllegalArgumentException('Data to large for user specified layer');\n      }\n    } else {\n      wordSize = 0;\n      stuffedBits = null;\n      // We look at the possible table sizes in the order Compact1, Compact2, Compact3,\n      // Compact4, Normal4,...  Normal(i) for i < 4 isn't typically used since Compact(i+1)\n      // is the same size, but has more data.\n      for (var i /*int*/ = 0;; i++) {\n        if (i > Encoder.MAX_NB_BITS) {\n          throw new IllegalArgumentException('Data too large for an Aztec code');\n        }\n        compact = i <= 3;\n        layers = compact ? i + 1 : i;\n        totalBitsInLayer = Encoder.totalBitsInLayer(layers, compact);\n        if (totalSizeBits > totalBitsInLayer) {\n          continue;\n        }\n        // [Re]stuff the bits if this is the first opportunity, or if the\n        // wordSize has changed\n        if (stuffedBits == null || wordSize !== Encoder.WORD_SIZE[layers]) {\n          wordSize = Encoder.WORD_SIZE[layers];\n          stuffedBits = Encoder.stuffBits(bits, wordSize);\n        }\n        var usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;\n        if (compact && stuffedBits.getSize() > wordSize * 64) {\n          // Compact format only allows 64 data words, though C4 can hold more words than that\n          continue;\n        }\n        if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {\n          break;\n        }\n      }\n    }\n    var messageBits = Encoder.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);\n    // generate mode message\n    var messageSizeInWords = stuffedBits.getSize() / wordSize;\n    var modeMessage = Encoder.generateModeMessage(compact, layers, messageSizeInWords);\n    // allocate symbol\n    var baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n    var alignmentMap = new Int32Array(baseMatrixSize);\n    var matrixSize;\n    if (compact) {\n      // no alignment marks in compact mode, alignmentMap is a no-op\n      matrixSize = baseMatrixSize;\n      for (var i /*int*/ = 0; i < alignmentMap.length; i++) {\n        alignmentMap[i] = i;\n      }\n    } else {\n      matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);\n      var origCenter = Integer.truncDivision(baseMatrixSize, 2);\n      var center = Integer.truncDivision(matrixSize, 2);\n      for (var i /*int*/ = 0; i < origCenter; i++) {\n        var newOffset = i + Integer.truncDivision(i, 15);\n        alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n        alignmentMap[origCenter + i] = center + newOffset + 1;\n      }\n    }\n    var matrix = new BitMatrix(matrixSize);\n    // draw data bits\n    for (var i /*int*/ = 0, rowOffset = 0; i < layers; i++) {\n      var rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n      for (var j /*int*/ = 0; j < rowSize; j++) {\n        var columnOffset = j * 2;\n        for (var k /*int*/ = 0; k < 2; k++) {\n          if (messageBits.get(rowOffset + columnOffset + k)) {\n            matrix.set(alignmentMap[i * 2 + k], alignmentMap[i * 2 + j]);\n          }\n          if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {\n            matrix.set(alignmentMap[i * 2 + j], alignmentMap[baseMatrixSize - 1 - i * 2 - k]);\n          }\n          if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {\n            matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - k], alignmentMap[baseMatrixSize - 1 - i * 2 - j]);\n          }\n          if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {\n            matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - j], alignmentMap[i * 2 + k]);\n          }\n        }\n      }\n      rowOffset += rowSize * 8;\n    }\n    // draw mode message\n    Encoder.drawModeMessage(matrix, compact, matrixSize, modeMessage);\n    // draw alignment marks\n    if (compact) {\n      Encoder.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 5);\n    } else {\n      Encoder.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 7);\n      for (var i /*int*/ = 0, j = 0; i < Integer.truncDivision(baseMatrixSize, 2) - 1; i += 15, j += 16) {\n        for (var k /*int*/ = Integer.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2) {\n          matrix.set(Integer.truncDivision(matrixSize, 2) - j, k);\n          matrix.set(Integer.truncDivision(matrixSize, 2) + j, k);\n          matrix.set(k, Integer.truncDivision(matrixSize, 2) - j);\n          matrix.set(k, Integer.truncDivision(matrixSize, 2) + j);\n        }\n      }\n    }\n    var aztec = new AztecCode();\n    aztec.setCompact(compact);\n    aztec.setSize(matrixSize);\n    aztec.setLayers(layers);\n    aztec.setCodeWords(messageSizeInWords);\n    aztec.setMatrix(matrix);\n    return aztec;\n  };\n  Encoder.drawBullsEye = function (matrix, center, size) {\n    for (var i /*int*/ = 0; i < size; i += 2) {\n      for (var j /*int*/ = center - i; j <= center + i; j++) {\n        matrix.set(j, center - i);\n        matrix.set(j, center + i);\n        matrix.set(center - i, j);\n        matrix.set(center + i, j);\n      }\n    }\n    matrix.set(center - size, center - size);\n    matrix.set(center - size + 1, center - size);\n    matrix.set(center - size, center - size + 1);\n    matrix.set(center + size, center - size);\n    matrix.set(center + size, center - size + 1);\n    matrix.set(center + size, center + size - 1);\n  };\n  Encoder.generateModeMessage = function (compact, layers, messageSizeInWords) {\n    var modeMessage = new BitArray();\n    if (compact) {\n      modeMessage.appendBits(layers - 1, 2);\n      modeMessage.appendBits(messageSizeInWords - 1, 6);\n      modeMessage = Encoder.generateCheckWords(modeMessage, 28, 4);\n    } else {\n      modeMessage.appendBits(layers - 1, 5);\n      modeMessage.appendBits(messageSizeInWords - 1, 11);\n      modeMessage = Encoder.generateCheckWords(modeMessage, 40, 4);\n    }\n    return modeMessage;\n  };\n  Encoder.drawModeMessage = function (matrix, compact, matrixSize, modeMessage) {\n    var center = Integer.truncDivision(matrixSize, 2);\n    if (compact) {\n      for (var i /*int*/ = 0; i < 7; i++) {\n        var offset = center - 3 + i;\n        if (modeMessage.get(i)) {\n          matrix.set(offset, center - 5);\n        }\n        if (modeMessage.get(i + 7)) {\n          matrix.set(center + 5, offset);\n        }\n        if (modeMessage.get(20 - i)) {\n          matrix.set(offset, center + 5);\n        }\n        if (modeMessage.get(27 - i)) {\n          matrix.set(center - 5, offset);\n        }\n      }\n    } else {\n      for (var i /*int*/ = 0; i < 10; i++) {\n        var offset = center - 5 + i + Integer.truncDivision(i, 5);\n        if (modeMessage.get(i)) {\n          matrix.set(offset, center - 7);\n        }\n        if (modeMessage.get(i + 10)) {\n          matrix.set(center + 7, offset);\n        }\n        if (modeMessage.get(29 - i)) {\n          matrix.set(offset, center + 7);\n        }\n        if (modeMessage.get(39 - i)) {\n          matrix.set(center - 7, offset);\n        }\n      }\n    }\n  };\n  Encoder.generateCheckWords = function (bitArray, totalBits, wordSize) {\n    var e_1, _a;\n    // bitArray is guaranteed to be a multiple of the wordSize, so no padding needed\n    var messageSizeInWords = bitArray.getSize() / wordSize;\n    var rs = new ReedSolomonEncoder(Encoder.getGF(wordSize));\n    var totalWords = Integer.truncDivision(totalBits, wordSize);\n    var messageWords = Encoder.bitsToWords(bitArray, wordSize, totalWords);\n    rs.encode(messageWords, totalWords - messageSizeInWords);\n    var startPad = totalBits % wordSize;\n    var messageBits = new BitArray();\n    messageBits.appendBits(0, startPad);\n    try {\n      for (var _b = __values(Array.from(messageWords)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var messageWord = _c.value /*: int*/;\n        messageBits.appendBits(messageWord, wordSize);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return messageBits;\n  };\n  Encoder.bitsToWords = function (stuffedBits, wordSize, totalWords) {\n    var message = new Int32Array(totalWords);\n    var i;\n    var n;\n    for (i = 0, n = stuffedBits.getSize() / wordSize; i < n; i++) {\n      var value = 0;\n      for (var j /*int*/ = 0; j < wordSize; j++) {\n        value |= stuffedBits.get(i * wordSize + j) ? 1 << wordSize - j - 1 : 0;\n      }\n      message[i] = value;\n    }\n    return message;\n  };\n  Encoder.getGF = function (wordSize) {\n    switch (wordSize) {\n      case 4:\n        return GenericGF.AZTEC_PARAM;\n      case 6:\n        return GenericGF.AZTEC_DATA_6;\n      case 8:\n        return GenericGF.AZTEC_DATA_8;\n      case 10:\n        return GenericGF.AZTEC_DATA_10;\n      case 12:\n        return GenericGF.AZTEC_DATA_12;\n      default:\n        throw new IllegalArgumentException('Unsupported word size ' + wordSize);\n    }\n  };\n  Encoder.stuffBits = function (bits, wordSize) {\n    var out = new BitArray();\n    var n = bits.getSize();\n    var mask = (1 << wordSize) - 2;\n    for (var i /*int*/ = 0; i < n; i += wordSize) {\n      var word = 0;\n      for (var j /*int*/ = 0; j < wordSize; j++) {\n        if (i + j >= n || bits.get(i + j)) {\n          word |= 1 << wordSize - 1 - j;\n        }\n      }\n      if ((word & mask) === mask) {\n        out.appendBits(word & mask, wordSize);\n        i--;\n      } else if ((word & mask) === 0) {\n        out.appendBits(word | 1, wordSize);\n        i--;\n      } else {\n        out.appendBits(word, wordSize);\n      }\n    }\n    return out;\n  };\n  Encoder.totalBitsInLayer = function (layers, compact) {\n    return ((compact ? 88 : 112) + 16 * layers) * layers;\n  };\n  Encoder.DEFAULT_EC_PERCENT = 33; // default minimal percentage of error check words\n  Encoder.DEFAULT_AZTEC_LAYERS = 0;\n  Encoder.MAX_NB_BITS = 32;\n  Encoder.MAX_NB_BITS_COMPACT = 4;\n  Encoder.WORD_SIZE = Int32Array.from([4, 6, 6, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]);\n  return Encoder;\n}();\nexport default Encoder;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}