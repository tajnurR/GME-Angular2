{"ast":null,"code":"/*\r\n * Copyright 2009 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/*namespace com.google.zxing.common {*/\nimport Binarizer from '../Binarizer';\nimport BitArray from './BitArray';\nimport BitMatrix from './BitMatrix';\nimport NotFoundException from '../NotFoundException';\n/**\r\n * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable\r\n * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding\r\n * algorithm. However, because it picks a global black point, it cannot handle difficult shadows\r\n * and gradients.\r\n *\r\n * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.\r\n *\r\n * @author dswitkin@google.com (Daniel Switkin)\r\n * @author Sean Owen\r\n */\nvar GlobalHistogramBinarizer = /** @class */function (_super) {\n  __extends(GlobalHistogramBinarizer, _super);\n  function GlobalHistogramBinarizer(source) {\n    var _this = _super.call(this, source) || this;\n    _this.luminances = GlobalHistogramBinarizer.EMPTY;\n    _this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);\n    return _this;\n  }\n  // Applies simple sharpening to the row data to improve performance of the 1D Readers.\n  /*@Override*/\n  GlobalHistogramBinarizer.prototype.getBlackRow = function (y /*int*/, row) {\n    var source = this.getLuminanceSource();\n    var width = source.getWidth();\n    if (row === undefined || row === null || row.getSize() < width) {\n      row = new BitArray(width);\n    } else {\n      row.clear();\n    }\n    this.initArrays(width);\n    var localLuminances = source.getRow(y, this.luminances);\n    var localBuckets = this.buckets;\n    for (var x = 0; x < width; x++) {\n      localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n    }\n    var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n    if (width < 3) {\n      // Special case for very small images\n      for (var x = 0; x < width; x++) {\n        if ((localLuminances[x] & 0xff) < blackPoint) {\n          row.set(x);\n        }\n      }\n    } else {\n      var left = localLuminances[0] & 0xff;\n      var center = localLuminances[1] & 0xff;\n      for (var x = 1; x < width - 1; x++) {\n        var right = localLuminances[x + 1] & 0xff;\n        // A simple -1 4 -1 box filter with a weight of 2.\n        if ((center * 4 - left - right) / 2 < blackPoint) {\n          row.set(x);\n        }\n        left = center;\n        center = right;\n      }\n    }\n    return row;\n  };\n  // Does not sharpen the data, as this call is intended to only be used by 2D Readers.\n  /*@Override*/\n  GlobalHistogramBinarizer.prototype.getBlackMatrix = function () {\n    var source = this.getLuminanceSource();\n    var width = source.getWidth();\n    var height = source.getHeight();\n    var matrix = new BitMatrix(width, height);\n    // Quickly calculates the histogram by sampling four rows from the image. This proved to be\n    // more robust on the blackbox tests than sampling a diagonal as we used to do.\n    this.initArrays(width);\n    var localBuckets = this.buckets;\n    for (var y = 1; y < 5; y++) {\n      var row = Math.floor(height * y / 5);\n      var localLuminances_1 = source.getRow(row, this.luminances);\n      var right = Math.floor(width * 4 / 5);\n      for (var x = Math.floor(width / 5); x < right; x++) {\n        var pixel = localLuminances_1[x] & 0xff;\n        localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n      }\n    }\n    var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n    // We delay reading the entire image luminance until the black point estimation succeeds.\n    // Although we end up reading four rows twice, it is consistent with our motto of\n    // \"fail quickly\" which is necessary for continuous scanning.\n    var localLuminances = source.getMatrix();\n    for (var y = 0; y < height; y++) {\n      var offset = y * width;\n      for (var x = 0; x < width; x++) {\n        var pixel = localLuminances[offset + x] & 0xff;\n        if (pixel < blackPoint) {\n          matrix.set(x, y);\n        }\n      }\n    }\n    return matrix;\n  };\n  /*@Override*/\n  GlobalHistogramBinarizer.prototype.createBinarizer = function (source) {\n    return new GlobalHistogramBinarizer(source);\n  };\n  GlobalHistogramBinarizer.prototype.initArrays = function (luminanceSize /*int*/) {\n    if (this.luminances.length < luminanceSize) {\n      this.luminances = new Uint8ClampedArray(luminanceSize);\n    }\n    var buckets = this.buckets;\n    for (var x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {\n      buckets[x] = 0;\n    }\n  };\n  GlobalHistogramBinarizer.estimateBlackPoint = function (buckets) {\n    // Find the tallest peak in the histogram.\n    var numBuckets = buckets.length;\n    var maxBucketCount = 0;\n    var firstPeak = 0;\n    var firstPeakSize = 0;\n    for (var x = 0; x < numBuckets; x++) {\n      if (buckets[x] > firstPeakSize) {\n        firstPeak = x;\n        firstPeakSize = buckets[x];\n      }\n      if (buckets[x] > maxBucketCount) {\n        maxBucketCount = buckets[x];\n      }\n    }\n    // Find the second-tallest peak which is somewhat far from the tallest peak.\n    var secondPeak = 0;\n    var secondPeakScore = 0;\n    for (var x = 0; x < numBuckets; x++) {\n      var distanceToBiggest = x - firstPeak;\n      // Encourage more distant second peaks by multiplying by square of distance.\n      var score = buckets[x] * distanceToBiggest * distanceToBiggest;\n      if (score > secondPeakScore) {\n        secondPeak = x;\n        secondPeakScore = score;\n      }\n    }\n    // Make sure firstPeak corresponds to the black peak.\n    if (firstPeak > secondPeak) {\n      var temp = firstPeak;\n      firstPeak = secondPeak;\n      secondPeak = temp;\n    }\n    // If there is too little contrast in the image to pick a meaningful black point, throw rather\n    // than waste time trying to decode the image, and risk false positives.\n    if (secondPeak - firstPeak <= numBuckets / 16) {\n      throw new NotFoundException();\n    }\n    // Find a valley between them that is low and closer to the white peak.\n    var bestValley = secondPeak - 1;\n    var bestValleyScore = -1;\n    for (var x = secondPeak - 1; x > firstPeak; x--) {\n      var fromFirst = x - firstPeak;\n      var score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);\n      if (score > bestValleyScore) {\n        bestValley = x;\n        bestValleyScore = score;\n      }\n    }\n    return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;\n  };\n  GlobalHistogramBinarizer.LUMINANCE_BITS = 5;\n  GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;\n  GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;\n  GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);\n  return GlobalHistogramBinarizer;\n}(Binarizer);\nexport default GlobalHistogramBinarizer;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}