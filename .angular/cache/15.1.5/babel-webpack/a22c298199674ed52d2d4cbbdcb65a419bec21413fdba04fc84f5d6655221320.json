{"ast":null,"code":"import BitMatrix from '../../common/BitMatrix';\nimport Version from './Version';\nimport FormatException from '../../FormatException';\nimport IllegalArgumentException from '../../IllegalArgumentException';\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * @author bbrown@google.com (Brian Brown)\r\n */\nvar BitMatrixParser = /** @class */function () {\n  /**\r\n   * @param bitMatrix {@link BitMatrix} to parse\r\n   * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2\r\n   */\n  function BitMatrixParser(bitMatrix) {\n    var dimension = bitMatrix.getHeight();\n    if (dimension < 8 || dimension > 144 || (dimension & 0x01) !== 0) {\n      throw new FormatException();\n    }\n    this.version = BitMatrixParser.readVersion(bitMatrix);\n    this.mappingBitMatrix = this.extractDataRegion(bitMatrix);\n    this.readMappingMatrix = new BitMatrix(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());\n  }\n  BitMatrixParser.prototype.getVersion = function () {\n    return this.version;\n  };\n  /**\r\n   * <p>Creates the version object based on the dimension of the original bit matrix from\r\n   * the datamatrix code.</p>\r\n   *\r\n   * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>\r\n   *\r\n   * @param bitMatrix Original {@link BitMatrix} including alignment patterns\r\n   * @return {@link Version} encapsulating the Data Matrix Code's \"version\"\r\n   * @throws FormatException if the dimensions of the mapping matrix are not valid\r\n   * Data Matrix dimensions.\r\n   */\n  BitMatrixParser.readVersion = function (bitMatrix) {\n    var numRows = bitMatrix.getHeight();\n    var numColumns = bitMatrix.getWidth();\n    return Version.getVersionForDimensions(numRows, numColumns);\n  };\n  /**\r\n   * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)\r\n   * in the correct order in order to reconstitute the codewords bytes contained within the\r\n   * Data Matrix Code.</p>\r\n   *\r\n   * @return bytes encoded within the Data Matrix Code\r\n   * @throws FormatException if the exact number of bytes expected is not read\r\n   */\n  BitMatrixParser.prototype.readCodewords = function () {\n    var result = new Int8Array(this.version.getTotalCodewords());\n    var resultOffset = 0;\n    var row = 4;\n    var column = 0;\n    var numRows = this.mappingBitMatrix.getHeight();\n    var numColumns = this.mappingBitMatrix.getWidth();\n    var corner1Read = false;\n    var corner2Read = false;\n    var corner3Read = false;\n    var corner4Read = false;\n    // Read all of the codewords\n    do {\n      // Check the four corner cases\n      if (row === numRows && column === 0 && !corner1Read) {\n        result[resultOffset++] = this.readCorner1(numRows, numColumns) & 0xff;\n        row -= 2;\n        column += 2;\n        corner1Read = true;\n      } else if (row === numRows - 2 && column === 0 && (numColumns & 0x03) !== 0 && !corner2Read) {\n        result[resultOffset++] = this.readCorner2(numRows, numColumns) & 0xff;\n        row -= 2;\n        column += 2;\n        corner2Read = true;\n      } else if (row === numRows + 4 && column === 2 && (numColumns & 0x07) === 0 && !corner3Read) {\n        result[resultOffset++] = this.readCorner3(numRows, numColumns) & 0xff;\n        row -= 2;\n        column += 2;\n        corner3Read = true;\n      } else if (row === numRows - 2 && column === 0 && (numColumns & 0x07) === 4 && !corner4Read) {\n        result[resultOffset++] = this.readCorner4(numRows, numColumns) & 0xff;\n        row -= 2;\n        column += 2;\n        corner4Read = true;\n      } else {\n        // Sweep upward diagonally to the right\n        do {\n          if (row < numRows && column >= 0 && !this.readMappingMatrix.get(column, row)) {\n            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n          }\n          row -= 2;\n          column += 2;\n        } while (row >= 0 && column < numColumns);\n        row += 1;\n        column += 3;\n        // Sweep downward diagonally to the left\n        do {\n          if (row >= 0 && column < numColumns && !this.readMappingMatrix.get(column, row)) {\n            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n          }\n          row += 2;\n          column -= 2;\n        } while (row < numRows && column >= 0);\n        row += 3;\n        column += 1;\n      }\n    } while (row < numRows || column < numColumns);\n    if (resultOffset !== this.version.getTotalCodewords()) {\n      throw new FormatException();\n    }\n    return result;\n  };\n  /**\r\n   * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>\r\n   *\r\n   * @param row Row to read in the mapping matrix\r\n   * @param column Column to read in the mapping matrix\r\n   * @param numRows Number of rows in the mapping matrix\r\n   * @param numColumns Number of columns in the mapping matrix\r\n   * @return value of the given bit in the mapping matrix\r\n   */\n  BitMatrixParser.prototype.readModule = function (row, column, numRows, numColumns) {\n    // Adjust the row and column indices based on boundary wrapping\n    if (row < 0) {\n      row += numRows;\n      column += 4 - (numRows + 4 & 0x07);\n    }\n    if (column < 0) {\n      column += numColumns;\n      row += 4 - (numColumns + 4 & 0x07);\n    }\n    this.readMappingMatrix.set(column, row);\n    return this.mappingBitMatrix.get(column, row);\n  };\n  /**\r\n   * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>\r\n   *\r\n   * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>\r\n   *\r\n   * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\r\n   * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\r\n   * @param numRows Number of rows in the mapping matrix\r\n   * @param numColumns Number of columns in the mapping matrix\r\n   * @return byte from the utah shape\r\n   */\n  BitMatrixParser.prototype.readUtah = function (row, column, numRows, numColumns) {\n    var currentByte = 0;\n    if (this.readModule(row - 2, column - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(row - 2, column - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(row - 1, column - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(row - 1, column - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(row - 1, column, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(row, column - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(row, column - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(row, column, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    return currentByte;\n  };\n  /**\r\n   * <p>Reads the 8 bits of the special corner condition 1.</p>\r\n   *\r\n   * <p>See ISO 16022:2006, Figure F.3</p>\r\n   *\r\n   * @param numRows Number of rows in the mapping matrix\r\n   * @param numColumns Number of columns in the mapping matrix\r\n   * @return byte from the Corner condition 1\r\n   */\n  BitMatrixParser.prototype.readCorner1 = function (numRows, numColumns) {\n    var currentByte = 0;\n    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(numRows - 1, 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(numRows - 1, 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    return currentByte;\n  };\n  /**\r\n   * <p>Reads the 8 bits of the special corner condition 2.</p>\r\n   *\r\n   * <p>See ISO 16022:2006, Figure F.4</p>\r\n   *\r\n   * @param numRows Number of rows in the mapping matrix\r\n   * @param numColumns Number of columns in the mapping matrix\r\n   * @return byte from the Corner condition 2\r\n   */\n  BitMatrixParser.prototype.readCorner2 = function (numRows, numColumns) {\n    var currentByte = 0;\n    if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(0, numColumns - 4, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    return currentByte;\n  };\n  /**\r\n   * <p>Reads the 8 bits of the special corner condition 3.</p>\r\n   *\r\n   * <p>See ISO 16022:2006, Figure F.5</p>\r\n   *\r\n   * @param numRows Number of rows in the mapping matrix\r\n   * @param numColumns Number of columns in the mapping matrix\r\n   * @return byte from the Corner condition 3\r\n   */\n  BitMatrixParser.prototype.readCorner3 = function (numRows, numColumns) {\n    var currentByte = 0;\n    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(1, numColumns - 3, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(1, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    return currentByte;\n  };\n  /**\r\n   * <p>Reads the 8 bits of the special corner condition 4.</p>\r\n   *\r\n   * <p>See ISO 16022:2006, Figure F.6</p>\r\n   *\r\n   * @param numRows Number of rows in the mapping matrix\r\n   * @param numColumns Number of columns in the mapping matrix\r\n   * @return byte from the Corner condition 4\r\n   */\n  BitMatrixParser.prototype.readCorner4 = function (numRows, numColumns) {\n    var currentByte = 0;\n    if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    currentByte <<= 1;\n    if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n    return currentByte;\n  };\n  /**\r\n   * <p>Extracts the data region from a {@link BitMatrix} that contains\r\n   * alignment patterns.</p>\r\n   *\r\n   * @param bitMatrix Original {@link BitMatrix} with alignment patterns\r\n   * @return BitMatrix that has the alignment patterns removed\r\n   */\n  BitMatrixParser.prototype.extractDataRegion = function (bitMatrix) {\n    var symbolSizeRows = this.version.getSymbolSizeRows();\n    var symbolSizeColumns = this.version.getSymbolSizeColumns();\n    if (bitMatrix.getHeight() !== symbolSizeRows) {\n      throw new IllegalArgumentException('Dimension of bitMatrix must match the version size');\n    }\n    var dataRegionSizeRows = this.version.getDataRegionSizeRows();\n    var dataRegionSizeColumns = this.version.getDataRegionSizeColumns();\n    var numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;\n    var numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;\n    var sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;\n    var sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;\n    var bitMatrixWithoutAlignment = new BitMatrix(sizeDataRegionColumn, sizeDataRegionRow);\n    for (var dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {\n      var dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;\n      for (var dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {\n        var dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;\n        for (var i = 0; i < dataRegionSizeRows; ++i) {\n          var readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;\n          var writeRowOffset = dataRegionRowOffset + i;\n          for (var j = 0; j < dataRegionSizeColumns; ++j) {\n            var readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;\n            if (bitMatrix.get(readColumnOffset, readRowOffset)) {\n              var writeColumnOffset = dataRegionColumnOffset + j;\n              bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);\n            }\n          }\n        }\n      }\n    }\n    return bitMatrixWithoutAlignment;\n  };\n  return BitMatrixParser;\n}();\nexport default BitMatrixParser;","map":{"version":3,"names":["BitMatrix","Version","FormatException","IllegalArgumentException","BitMatrixParser","bitMatrix","dimension","getHeight","version","readVersion","mappingBitMatrix","extractDataRegion","readMappingMatrix","getWidth","prototype","getVersion","numRows","numColumns","getVersionForDimensions","readCodewords","result","Int8Array","getTotalCodewords","resultOffset","row","column","corner1Read","corner2Read","corner3Read","corner4Read","readCorner1","readCorner2","readCorner3","readCorner4","get","readUtah","readModule","set","currentByte","symbolSizeRows","getSymbolSizeRows","symbolSizeColumns","getSymbolSizeColumns","dataRegionSizeRows","getDataRegionSizeRows","dataRegionSizeColumns","getDataRegionSizeColumns","numDataRegionsRow","numDataRegionsColumn","sizeDataRegionRow","sizeDataRegionColumn","bitMatrixWithoutAlignment","dataRegionRow","dataRegionRowOffset","dataRegionColumn","dataRegionColumnOffset","i","readRowOffset","writeRowOffset","j","readColumnOffset","writeColumnOffset"],"sources":["E:/angular/GME-Angular2/node_modules/@zxing/library/esm/core/datamatrix/decoder/BitMatrixParser.js"],"sourcesContent":["import BitMatrix from '../../common/BitMatrix';\r\nimport Version from './Version';\r\nimport FormatException from '../../FormatException';\r\nimport IllegalArgumentException from '../../IllegalArgumentException';\r\n/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @author bbrown@google.com (Brian Brown)\r\n */\r\nvar BitMatrixParser = /** @class */ (function () {\r\n    /**\r\n     * @param bitMatrix {@link BitMatrix} to parse\r\n     * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2\r\n     */\r\n    function BitMatrixParser(bitMatrix) {\r\n        var dimension = bitMatrix.getHeight();\r\n        if (dimension < 8 || dimension > 144 || (dimension & 0x01) !== 0) {\r\n            throw new FormatException();\r\n        }\r\n        this.version = BitMatrixParser.readVersion(bitMatrix);\r\n        this.mappingBitMatrix = this.extractDataRegion(bitMatrix);\r\n        this.readMappingMatrix = new BitMatrix(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());\r\n    }\r\n    BitMatrixParser.prototype.getVersion = function () {\r\n        return this.version;\r\n    };\r\n    /**\r\n     * <p>Creates the version object based on the dimension of the original bit matrix from\r\n     * the datamatrix code.</p>\r\n     *\r\n     * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>\r\n     *\r\n     * @param bitMatrix Original {@link BitMatrix} including alignment patterns\r\n     * @return {@link Version} encapsulating the Data Matrix Code's \"version\"\r\n     * @throws FormatException if the dimensions of the mapping matrix are not valid\r\n     * Data Matrix dimensions.\r\n     */\r\n    BitMatrixParser.readVersion = function (bitMatrix) {\r\n        var numRows = bitMatrix.getHeight();\r\n        var numColumns = bitMatrix.getWidth();\r\n        return Version.getVersionForDimensions(numRows, numColumns);\r\n    };\r\n    /**\r\n     * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)\r\n     * in the correct order in order to reconstitute the codewords bytes contained within the\r\n     * Data Matrix Code.</p>\r\n     *\r\n     * @return bytes encoded within the Data Matrix Code\r\n     * @throws FormatException if the exact number of bytes expected is not read\r\n     */\r\n    BitMatrixParser.prototype.readCodewords = function () {\r\n        var result = new Int8Array(this.version.getTotalCodewords());\r\n        var resultOffset = 0;\r\n        var row = 4;\r\n        var column = 0;\r\n        var numRows = this.mappingBitMatrix.getHeight();\r\n        var numColumns = this.mappingBitMatrix.getWidth();\r\n        var corner1Read = false;\r\n        var corner2Read = false;\r\n        var corner3Read = false;\r\n        var corner4Read = false;\r\n        // Read all of the codewords\r\n        do {\r\n            // Check the four corner cases\r\n            if ((row === numRows) && (column === 0) && !corner1Read) {\r\n                result[resultOffset++] = this.readCorner1(numRows, numColumns) & 0xff;\r\n                row -= 2;\r\n                column += 2;\r\n                corner1Read = true;\r\n            }\r\n            else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x03) !== 0) && !corner2Read) {\r\n                result[resultOffset++] = this.readCorner2(numRows, numColumns) & 0xff;\r\n                row -= 2;\r\n                column += 2;\r\n                corner2Read = true;\r\n            }\r\n            else if ((row === numRows + 4) && (column === 2) && ((numColumns & 0x07) === 0) && !corner3Read) {\r\n                result[resultOffset++] = this.readCorner3(numRows, numColumns) & 0xff;\r\n                row -= 2;\r\n                column += 2;\r\n                corner3Read = true;\r\n            }\r\n            else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x07) === 4) && !corner4Read) {\r\n                result[resultOffset++] = this.readCorner4(numRows, numColumns) & 0xff;\r\n                row -= 2;\r\n                column += 2;\r\n                corner4Read = true;\r\n            }\r\n            else {\r\n                // Sweep upward diagonally to the right\r\n                do {\r\n                    if ((row < numRows) && (column >= 0) && !this.readMappingMatrix.get(column, row)) {\r\n                        result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\r\n                    }\r\n                    row -= 2;\r\n                    column += 2;\r\n                } while ((row >= 0) && (column < numColumns));\r\n                row += 1;\r\n                column += 3;\r\n                // Sweep downward diagonally to the left\r\n                do {\r\n                    if ((row >= 0) && (column < numColumns) && !this.readMappingMatrix.get(column, row)) {\r\n                        result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\r\n                    }\r\n                    row += 2;\r\n                    column -= 2;\r\n                } while ((row < numRows) && (column >= 0));\r\n                row += 3;\r\n                column += 1;\r\n            }\r\n        } while ((row < numRows) || (column < numColumns));\r\n        if (resultOffset !== this.version.getTotalCodewords()) {\r\n            throw new FormatException();\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>\r\n     *\r\n     * @param row Row to read in the mapping matrix\r\n     * @param column Column to read in the mapping matrix\r\n     * @param numRows Number of rows in the mapping matrix\r\n     * @param numColumns Number of columns in the mapping matrix\r\n     * @return value of the given bit in the mapping matrix\r\n     */\r\n    BitMatrixParser.prototype.readModule = function (row, column, numRows, numColumns) {\r\n        // Adjust the row and column indices based on boundary wrapping\r\n        if (row < 0) {\r\n            row += numRows;\r\n            column += 4 - ((numRows + 4) & 0x07);\r\n        }\r\n        if (column < 0) {\r\n            column += numColumns;\r\n            row += 4 - ((numColumns + 4) & 0x07);\r\n        }\r\n        this.readMappingMatrix.set(column, row);\r\n        return this.mappingBitMatrix.get(column, row);\r\n    };\r\n    /**\r\n     * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>\r\n     *\r\n     * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>\r\n     *\r\n     * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\r\n     * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\r\n     * @param numRows Number of rows in the mapping matrix\r\n     * @param numColumns Number of columns in the mapping matrix\r\n     * @return byte from the utah shape\r\n     */\r\n    BitMatrixParser.prototype.readUtah = function (row, column, numRows, numColumns) {\r\n        var currentByte = 0;\r\n        if (this.readModule(row - 2, column - 2, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(row - 2, column - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(row - 1, column - 2, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(row - 1, column - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(row - 1, column, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(row, column - 2, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(row, column - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(row, column, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        return currentByte;\r\n    };\r\n    /**\r\n     * <p>Reads the 8 bits of the special corner condition 1.</p>\r\n     *\r\n     * <p>See ISO 16022:2006, Figure F.3</p>\r\n     *\r\n     * @param numRows Number of rows in the mapping matrix\r\n     * @param numColumns Number of columns in the mapping matrix\r\n     * @return byte from the Corner condition 1\r\n     */\r\n    BitMatrixParser.prototype.readCorner1 = function (numRows, numColumns) {\r\n        var currentByte = 0;\r\n        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(numRows - 1, 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(numRows - 1, 2, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        return currentByte;\r\n    };\r\n    /**\r\n     * <p>Reads the 8 bits of the special corner condition 2.</p>\r\n     *\r\n     * <p>See ISO 16022:2006, Figure F.4</p>\r\n     *\r\n     * @param numRows Number of rows in the mapping matrix\r\n     * @param numColumns Number of columns in the mapping matrix\r\n     * @return byte from the Corner condition 2\r\n     */\r\n    BitMatrixParser.prototype.readCorner2 = function (numRows, numColumns) {\r\n        var currentByte = 0;\r\n        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(0, numColumns - 4, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        return currentByte;\r\n    };\r\n    /**\r\n     * <p>Reads the 8 bits of the special corner condition 3.</p>\r\n     *\r\n     * <p>See ISO 16022:2006, Figure F.5</p>\r\n     *\r\n     * @param numRows Number of rows in the mapping matrix\r\n     * @param numColumns Number of columns in the mapping matrix\r\n     * @return byte from the Corner condition 3\r\n     */\r\n    BitMatrixParser.prototype.readCorner3 = function (numRows, numColumns) {\r\n        var currentByte = 0;\r\n        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(1, numColumns - 3, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(1, numColumns - 2, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        return currentByte;\r\n    };\r\n    /**\r\n     * <p>Reads the 8 bits of the special corner condition 4.</p>\r\n     *\r\n     * <p>See ISO 16022:2006, Figure F.6</p>\r\n     *\r\n     * @param numRows Number of rows in the mapping matrix\r\n     * @param numColumns Number of columns in the mapping matrix\r\n     * @return byte from the Corner condition 4\r\n     */\r\n    BitMatrixParser.prototype.readCorner4 = function (numRows, numColumns) {\r\n        var currentByte = 0;\r\n        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        currentByte <<= 1;\r\n        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\r\n            currentByte |= 1;\r\n        }\r\n        return currentByte;\r\n    };\r\n    /**\r\n     * <p>Extracts the data region from a {@link BitMatrix} that contains\r\n     * alignment patterns.</p>\r\n     *\r\n     * @param bitMatrix Original {@link BitMatrix} with alignment patterns\r\n     * @return BitMatrix that has the alignment patterns removed\r\n     */\r\n    BitMatrixParser.prototype.extractDataRegion = function (bitMatrix) {\r\n        var symbolSizeRows = this.version.getSymbolSizeRows();\r\n        var symbolSizeColumns = this.version.getSymbolSizeColumns();\r\n        if (bitMatrix.getHeight() !== symbolSizeRows) {\r\n            throw new IllegalArgumentException('Dimension of bitMatrix must match the version size');\r\n        }\r\n        var dataRegionSizeRows = this.version.getDataRegionSizeRows();\r\n        var dataRegionSizeColumns = this.version.getDataRegionSizeColumns();\r\n        var numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;\r\n        var numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;\r\n        var sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;\r\n        var sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;\r\n        var bitMatrixWithoutAlignment = new BitMatrix(sizeDataRegionColumn, sizeDataRegionRow);\r\n        for (var dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {\r\n            var dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;\r\n            for (var dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {\r\n                var dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;\r\n                for (var i = 0; i < dataRegionSizeRows; ++i) {\r\n                    var readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;\r\n                    var writeRowOffset = dataRegionRowOffset + i;\r\n                    for (var j = 0; j < dataRegionSizeColumns; ++j) {\r\n                        var readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;\r\n                        if (bitMatrix.get(readColumnOffset, readRowOffset)) {\r\n                            var writeColumnOffset = dataRegionColumnOffset + j;\r\n                            bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return bitMatrixWithoutAlignment;\r\n    };\r\n    return BitMatrixParser;\r\n}());\r\nexport default BitMatrixParser;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}