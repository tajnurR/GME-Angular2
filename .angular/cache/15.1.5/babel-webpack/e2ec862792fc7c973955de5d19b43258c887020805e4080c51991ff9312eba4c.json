{"ast":null,"code":"/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/*namespace com.google.zxing.common {*/\n/*import java.util.Arrays;*/\nimport IllegalArgumentException from '../IllegalArgumentException';\nimport Arrays from '../util/Arrays';\nimport Integer from '../util/Integer';\nimport System from '../util/System';\n/**\r\n * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>\r\n *\r\n * @author Sean Owen\r\n */\nvar BitArray /*implements Cloneable*/ = /** @class */function () {\n  // public constructor() {\n  //   this.size = 0\n  //   this.bits = new Int32Array(1)\n  // }\n  // public constructor(size?: number /*int*/) {\n  //   if (undefined === size) {\n  //     this.size = 0\n  //   } else {\n  //     this.size = size\n  //   }\n  //   this.bits = this.makeArray(size)\n  // }\n  // For testing only\n  function BitArray(size /*int*/, bits) {\n    if (undefined === size) {\n      this.size = 0;\n      this.bits = new Int32Array(1);\n    } else {\n      this.size = size;\n      if (undefined === bits || null === bits) {\n        this.bits = BitArray.makeArray(size);\n      } else {\n        this.bits = bits;\n      }\n    }\n  }\n  BitArray.prototype.getSize = function () {\n    return this.size;\n  };\n  BitArray.prototype.getSizeInBytes = function () {\n    return Math.floor((this.size + 7) / 8);\n  };\n  BitArray.prototype.ensureCapacity = function (size /*int*/) {\n    if (size > this.bits.length * 32) {\n      var newBits = BitArray.makeArray(size);\n      System.arraycopy(this.bits, 0, newBits, 0, this.bits.length);\n      this.bits = newBits;\n    }\n  };\n  /**\r\n   * @param i bit to get\r\n   * @return true iff bit i is set\r\n   */\n  BitArray.prototype.get = function (i /*int*/) {\n    return (this.bits[Math.floor(i / 32)] & 1 << (i & 0x1F)) !== 0;\n  };\n  /**\r\n   * Sets bit i.\r\n   *\r\n   * @param i bit to set\r\n   */\n  BitArray.prototype.set = function (i /*int*/) {\n    this.bits[Math.floor(i / 32)] |= 1 << (i & 0x1F);\n  };\n  /**\r\n   * Flips bit i.\r\n   *\r\n   * @param i bit to set\r\n   */\n  BitArray.prototype.flip = function (i /*int*/) {\n    this.bits[Math.floor(i / 32)] ^= 1 << (i & 0x1F);\n  };\n  /**\r\n   * @param from first bit to check\r\n   * @return index of first bit that is set, starting from the given index, or size if none are set\r\n   *  at or beyond this given index\r\n   * @see #getNextUnset(int)\r\n   */\n  BitArray.prototype.getNextSet = function (from /*int*/) {\n    var size = this.size;\n    if (from >= size) {\n      return size;\n    }\n    var bits = this.bits;\n    var bitsOffset = Math.floor(from / 32);\n    var currentBits = bits[bitsOffset];\n    // mask off lesser bits first\n    currentBits &= ~((1 << (from & 0x1F)) - 1);\n    var length = bits.length;\n    while (currentBits === 0) {\n      if (++bitsOffset === length) {\n        return size;\n      }\n      currentBits = bits[bitsOffset];\n    }\n    var result = bitsOffset * 32 + Integer.numberOfTrailingZeros(currentBits);\n    return result > size ? size : result;\n  };\n  /**\r\n   * @param from index to start looking for unset bit\r\n   * @return index of next unset bit, or {@code size} if none are unset until the end\r\n   * @see #getNextSet(int)\r\n   */\n  BitArray.prototype.getNextUnset = function (from /*int*/) {\n    var size = this.size;\n    if (from >= size) {\n      return size;\n    }\n    var bits = this.bits;\n    var bitsOffset = Math.floor(from / 32);\n    var currentBits = ~bits[bitsOffset];\n    // mask off lesser bits first\n    currentBits &= ~((1 << (from & 0x1F)) - 1);\n    var length = bits.length;\n    while (currentBits === 0) {\n      if (++bitsOffset === length) {\n        return size;\n      }\n      currentBits = ~bits[bitsOffset];\n    }\n    var result = bitsOffset * 32 + Integer.numberOfTrailingZeros(currentBits);\n    return result > size ? size : result;\n  };\n  /**\r\n   * Sets a block of 32 bits, starting at bit i.\r\n   *\r\n   * @param i first bit to set\r\n   * @param newBits the new value of the next 32 bits. Note again that the least-significant bit\r\n   * corresponds to bit i, the next-least-significant to i+1, and so on.\r\n   */\n  BitArray.prototype.setBulk = function (i /*int*/, newBits /*int*/) {\n    this.bits[Math.floor(i / 32)] = newBits;\n  };\n  /**\r\n   * Sets a range of bits.\r\n   *\r\n   * @param start start of range, inclusive.\r\n   * @param end end of range, exclusive\r\n   */\n  BitArray.prototype.setRange = function (start /*int*/, end /*int*/) {\n    if (end < start || start < 0 || end > this.size) {\n      throw new IllegalArgumentException();\n    }\n    if (end === start) {\n      return;\n    }\n    end--; // will be easier to treat this as the last actually set bit -- inclusive\n    var firstInt = Math.floor(start / 32);\n    var lastInt = Math.floor(end / 32);\n    var bits = this.bits;\n    for (var i = firstInt; i <= lastInt; i++) {\n      var firstBit = i > firstInt ? 0 : start & 0x1F;\n      var lastBit = i < lastInt ? 31 : end & 0x1F;\n      // Ones from firstBit to lastBit, inclusive\n      var mask = (2 << lastBit) - (1 << firstBit);\n      bits[i] |= mask;\n    }\n  };\n  /**\r\n   * Clears all bits (sets to false).\r\n   */\n  BitArray.prototype.clear = function () {\n    var max = this.bits.length;\n    var bits = this.bits;\n    for (var i = 0; i < max; i++) {\n      bits[i] = 0;\n    }\n  };\n  /**\r\n   * Efficient method to check if a range of bits is set, or not set.\r\n   *\r\n   * @param start start of range, inclusive.\r\n   * @param end end of range, exclusive\r\n   * @param value if true, checks that bits in range are set, otherwise checks that they are not set\r\n   * @return true iff all bits are set or not set in range, according to value argument\r\n   * @throws IllegalArgumentException if end is less than start or the range is not contained in the array\r\n   */\n  BitArray.prototype.isRange = function (start /*int*/, end /*int*/, value) {\n    if (end < start || start < 0 || end > this.size) {\n      throw new IllegalArgumentException();\n    }\n    if (end === start) {\n      return true; // empty range matches\n    }\n\n    end--; // will be easier to treat this as the last actually set bit -- inclusive\n    var firstInt = Math.floor(start / 32);\n    var lastInt = Math.floor(end / 32);\n    var bits = this.bits;\n    for (var i = firstInt; i <= lastInt; i++) {\n      var firstBit = i > firstInt ? 0 : start & 0x1F;\n      var lastBit = i < lastInt ? 31 : end & 0x1F;\n      // Ones from firstBit to lastBit, inclusive\n      var mask = (2 << lastBit) - (1 << firstBit) & 0xFFFFFFFF;\n      // TYPESCRIPTPORT: & 0xFFFFFFFF added to discard anything after 32 bits, as ES has 53 bits\n      // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (is: that,\n      // equals the mask, or we're looking for 0s and the masked portion is not all 0s\n      if ((bits[i] & mask) !== (value ? mask : 0)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  BitArray.prototype.appendBit = function (bit) {\n    this.ensureCapacity(this.size + 1);\n    if (bit) {\n      this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 0x1F);\n    }\n    this.size++;\n  };\n  /**\r\n   * Appends the least-significant bits, from value, in order from most-significant to\r\n   * least-significant. For example, appending 6 bits from 0x000001E will append the bits\r\n   * 0, 1, 1, 1, 1, 0 in that order.\r\n   *\r\n   * @param value {@code int} containing bits to append\r\n   * @param numBits bits from value to append\r\n   */\n  BitArray.prototype.appendBits = function (value /*int*/, numBits /*int*/) {\n    if (numBits < 0 || numBits > 32) {\n      throw new IllegalArgumentException('Num bits must be between 0 and 32');\n    }\n    this.ensureCapacity(this.size + numBits);\n    // const appendBit = this.appendBit;\n    for (var numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {\n      this.appendBit((value >> numBitsLeft - 1 & 0x01) === 1);\n    }\n  };\n  BitArray.prototype.appendBitArray = function (other) {\n    var otherSize = other.size;\n    this.ensureCapacity(this.size + otherSize);\n    // const appendBit = this.appendBit;\n    for (var i = 0; i < otherSize; i++) {\n      this.appendBit(other.get(i));\n    }\n  };\n  BitArray.prototype.xor = function (other) {\n    if (this.size !== other.size) {\n      throw new IllegalArgumentException('Sizes don\\'t match');\n    }\n    var bits = this.bits;\n    for (var i = 0, length_1 = bits.length; i < length_1; i++) {\n      // The last int could be incomplete (i.e. not have 32 bits in\n      // it) but there is no problem since 0 XOR 0 == 0.\n      bits[i] ^= other.bits[i];\n    }\n  };\n  /**\r\n   *\r\n   * @param bitOffset first bit to start writing\r\n   * @param array array to write into. Bytes are written most-significant byte first. This is the opposite\r\n   *  of the internal representation, which is exposed by {@link #getBitArray()}\r\n   * @param offset position in array to start writing\r\n   * @param numBytes how many bytes to write\r\n   */\n  BitArray.prototype.toBytes = function (bitOffset /*int*/, array, offset /*int*/, numBytes /*int*/) {\n    for (var i = 0; i < numBytes; i++) {\n      var theByte = 0;\n      for (var j = 0; j < 8; j++) {\n        if (this.get(bitOffset)) {\n          theByte |= 1 << 7 - j;\n        }\n        bitOffset++;\n      }\n      array[offset + i] = /*(byte)*/theByte;\n    }\n  };\n  /**\r\n   * @return underlying array of ints. The first element holds the first 32 bits, and the least\r\n   *         significant bit is bit 0.\r\n   */\n  BitArray.prototype.getBitArray = function () {\n    return this.bits;\n  };\n  /**\r\n   * Reverses all bits in the array.\r\n   */\n  BitArray.prototype.reverse = function () {\n    var newBits = new Int32Array(this.bits.length);\n    // reverse all int's first\n    var len = Math.floor((this.size - 1) / 32);\n    var oldBitsLen = len + 1;\n    var bits = this.bits;\n    for (var i = 0; i < oldBitsLen; i++) {\n      var x = bits[i];\n      x = x >> 1 & 0x55555555 | (x & 0x55555555) << 1;\n      x = x >> 2 & 0x33333333 | (x & 0x33333333) << 2;\n      x = x >> 4 & 0x0f0f0f0f | (x & 0x0f0f0f0f) << 4;\n      x = x >> 8 & 0x00ff00ff | (x & 0x00ff00ff) << 8;\n      x = x >> 16 & 0x0000ffff | (x & 0x0000ffff) << 16;\n      newBits[len - i] = /*(int)*/x;\n    }\n    // now correct the int's if the bit size isn't a multiple of 32\n    if (this.size !== oldBitsLen * 32) {\n      var leftOffset = oldBitsLen * 32 - this.size;\n      var currentInt = newBits[0] >>> leftOffset;\n      for (var i = 1; i < oldBitsLen; i++) {\n        var nextInt = newBits[i];\n        currentInt |= nextInt << 32 - leftOffset;\n        newBits[i - 1] = currentInt;\n        currentInt = nextInt >>> leftOffset;\n      }\n      newBits[oldBitsLen - 1] = currentInt;\n    }\n    this.bits = newBits;\n  };\n  BitArray.makeArray = function (size /*int*/) {\n    return new Int32Array(Math.floor((size + 31) / 32));\n  };\n  /*@Override*/\n  BitArray.prototype.equals = function (o) {\n    if (!(o instanceof BitArray)) {\n      return false;\n    }\n    var other = o;\n    return this.size === other.size && Arrays.equals(this.bits, other.bits);\n  };\n  /*@Override*/\n  BitArray.prototype.hashCode = function () {\n    return 31 * this.size + Arrays.hashCode(this.bits);\n  };\n  /*@Override*/\n  BitArray.prototype.toString = function () {\n    var result = '';\n    for (var i = 0, size = this.size; i < size; i++) {\n      if ((i & 0x07) === 0) {\n        result += ' ';\n      }\n      result += this.get(i) ? 'X' : '.';\n    }\n    return result;\n  };\n  /*@Override*/\n  BitArray.prototype.clone = function () {\n    return new BitArray(this.size, this.bits.slice());\n  };\n  return BitArray;\n}();\nexport default BitArray;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}