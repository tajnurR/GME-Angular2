{"ast":null,"code":"/*\r\n * Copyright 2013 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n// import java.util.Collection;\n// import java.util.Collections;\nimport Collections from '../../util/Collections';\n// import java.util.Comparator;\n// import java.util.Iterator;\n// import java.util.LinkedList;\nimport State from './State';\nimport * as C from './EncoderConstants';\nimport * as CharMap from './CharMap';\nimport * as ShiftTable from './ShiftTable';\nimport StringUtils from '../../common/StringUtils';\n/**\r\n * This produces nearly optimal encodings of text into the first-level of\r\n * encoding used by Aztec code.\r\n *\r\n * It uses a dynamic algorithm.  For each prefix of the string, it determines\r\n * a set of encodings that could lead to this prefix.  We repeatedly add a\r\n * character and generate a new set of optimal encodings until we have read\r\n * through the entire input.\r\n *\r\n * @author Frank Yellin\r\n * @author Rustam Abdullaev\r\n */\nvar HighLevelEncoder = /** @class */function () {\n  function HighLevelEncoder(text) {\n    this.text = text;\n  }\n  /**\r\n   * @return text represented by this encoder encoded as a {@link BitArray}\r\n   */\n  HighLevelEncoder.prototype.encode = function () {\n    var spaceCharCode = StringUtils.getCharCode(' ');\n    var lineBreakCharCode = StringUtils.getCharCode('\\n');\n    var states = Collections.singletonList(State.INITIAL_STATE);\n    for (var index = 0; index < this.text.length; index++) {\n      var pairCode = void 0;\n      var nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;\n      switch (this.text[index]) {\n        case StringUtils.getCharCode('\\r'):\n          pairCode = nextChar === lineBreakCharCode ? 2 : 0;\n          break;\n        case StringUtils.getCharCode('.'):\n          pairCode = nextChar === spaceCharCode ? 3 : 0;\n          break;\n        case StringUtils.getCharCode(','):\n          pairCode = nextChar === spaceCharCode ? 4 : 0;\n          break;\n        case StringUtils.getCharCode(':'):\n          pairCode = nextChar === spaceCharCode ? 5 : 0;\n          break;\n        default:\n          pairCode = 0;\n      }\n      if (pairCode > 0) {\n        // We have one of the four special PUNCT pairs.  Treat them specially.\n        // Get a new set of states for the two new characters.\n        states = HighLevelEncoder.updateStateListForPair(states, index, pairCode);\n        index++;\n      } else {\n        // Get a new set of states for the new character.\n        states = this.updateStateListForChar(states, index);\n      }\n    }\n    // We are left with a set of states.  Find the shortest one.\n    var minState = Collections.min(states, function (a, b) {\n      return a.getBitCount() - b.getBitCount();\n    });\n    // Convert it to a bit array, and return.\n    return minState.toBitArray(this.text);\n  };\n  // We update a set of states for a new character by updating each state\n  // for the new character, merging the results, and then removing the\n  // non-optimal states.\n  HighLevelEncoder.prototype.updateStateListForChar = function (states, index) {\n    var e_1, _a;\n    var result = [];\n    try {\n      for (var states_1 = __values(states), states_1_1 = states_1.next(); !states_1_1.done; states_1_1 = states_1.next()) {\n        var state = states_1_1.value /*State*/;\n        this.updateStateForChar(state, index, result);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (states_1_1 && !states_1_1.done && (_a = states_1.return)) _a.call(states_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return HighLevelEncoder.simplifyStates(result);\n  };\n  // Return a set of states that represent the possible ways of updating this\n  // state for the next character.  The resulting set of states are added to\n  // the \"result\" list.\n  HighLevelEncoder.prototype.updateStateForChar = function (state, index, result) {\n    var ch = this.text[index] & 0xff;\n    var charInCurrentTable = CharMap.CHAR_MAP[state.getMode()][ch] > 0;\n    var stateNoBinary = null;\n    for (var mode /*int*/ = 0; mode <= C.MODE_PUNCT; mode++) {\n      var charInMode = CharMap.CHAR_MAP[mode][ch];\n      if (charInMode > 0) {\n        if (stateNoBinary == null) {\n          // Only create stateNoBinary the first time it's required.\n          stateNoBinary = state.endBinaryShift(index);\n        }\n        // Try generating the character by latching to its mode\n        if (!charInCurrentTable || mode === state.getMode() || mode === C.MODE_DIGIT) {\n          // If the character is in the current table, we don't want to latch to\n          // any other mode except possibly digit (which uses only 4 bits).  Any\n          // other latch would be equally successful *after* this character, and\n          // so wouldn't save any bits.\n          var latchState = stateNoBinary.latchAndAppend(mode, charInMode);\n          result.push(latchState);\n        }\n        // Try generating the character by switching to its mode.\n        if (!charInCurrentTable && ShiftTable.SHIFT_TABLE[state.getMode()][mode] >= 0) {\n          // It never makes sense to temporarily shift to another mode if the\n          // character exists in the current mode.  That can never save bits.\n          var shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);\n          result.push(shiftState);\n        }\n      }\n    }\n    if (state.getBinaryShiftByteCount() > 0 || CharMap.CHAR_MAP[state.getMode()][ch] === 0) {\n      // It's never worthwhile to go into binary shift mode if you're not already\n      // in binary shift mode, and the character exists in your current mode.\n      // That can never save bits over just outputting the char in the current mode.\n      var binaryState = state.addBinaryShiftChar(index);\n      result.push(binaryState);\n    }\n  };\n  HighLevelEncoder.updateStateListForPair = function (states, index, pairCode) {\n    var e_2, _a;\n    var result = [];\n    try {\n      for (var states_2 = __values(states), states_2_1 = states_2.next(); !states_2_1.done; states_2_1 = states_2.next()) {\n        var state = states_2_1.value /*State*/;\n        this.updateStateForPair(state, index, pairCode, result);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (states_2_1 && !states_2_1.done && (_a = states_2.return)) _a.call(states_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return this.simplifyStates(result);\n  };\n  HighLevelEncoder.updateStateForPair = function (state, index, pairCode, result) {\n    var stateNoBinary = state.endBinaryShift(index);\n    // Possibility 1.  Latch to C.MODE_PUNCT, and then append this code\n    result.push(stateNoBinary.latchAndAppend(C.MODE_PUNCT, pairCode));\n    if (state.getMode() !== C.MODE_PUNCT) {\n      // Possibility 2.  Shift to C.MODE_PUNCT, and then append this code.\n      // Every state except C.MODE_PUNCT (handled above) can shift\n      result.push(stateNoBinary.shiftAndAppend(C.MODE_PUNCT, pairCode));\n    }\n    if (pairCode === 3 || pairCode === 4) {\n      // both characters are in DIGITS.  Sometimes better to just add two digits\n      var digitState = stateNoBinary.latchAndAppend(C.MODE_DIGIT, 16 - pairCode) // period or comma in DIGIT\n      .latchAndAppend(C.MODE_DIGIT, 1); // space in DIGIT\n      result.push(digitState);\n    }\n    if (state.getBinaryShiftByteCount() > 0) {\n      // It only makes sense to do the characters as binary if we're already\n      // in binary mode.\n      var binaryState = state.addBinaryShiftChar(index).addBinaryShiftChar(index + 1);\n      result.push(binaryState);\n    }\n  };\n  HighLevelEncoder.simplifyStates = function (states) {\n    var e_3, _a, e_4, _b;\n    var result = [];\n    try {\n      for (var states_3 = __values(states), states_3_1 = states_3.next(); !states_3_1.done; states_3_1 = states_3.next()) {\n        var newState = states_3_1.value;\n        var add = true;\n        var _loop_1 = function (oldState) {\n          if (oldState.isBetterThanOrEqualTo(newState)) {\n            add = false;\n            return \"break\";\n          }\n          if (newState.isBetterThanOrEqualTo(oldState)) {\n            // iterator.remove();\n            result = result.filter(function (x) {\n              return x !== oldState;\n            }); // remove old state\n          }\n        };\n\n        try {\n          for (var result_1 = (e_4 = void 0, __values(result)), result_1_1 = result_1.next(); !result_1_1.done; result_1_1 = result_1.next()) {\n            var oldState = result_1_1.value;\n            var state_1 = _loop_1(oldState);\n            if (state_1 === \"break\") break;\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (result_1_1 && !result_1_1.done && (_b = result_1.return)) _b.call(result_1);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n        if (add) {\n          result.push(newState);\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (states_3_1 && !states_3_1.done && (_a = states_3.return)) _a.call(states_3);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    return result;\n  };\n  return HighLevelEncoder;\n}();\nexport default HighLevelEncoder;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}