{"ast":null,"code":"/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nimport IllegalArgumentException from '../../IllegalArgumentException';\nexport var ModeValues;\n(function (ModeValues) {\n  ModeValues[ModeValues[\"TERMINATOR\"] = 0] = \"TERMINATOR\";\n  ModeValues[ModeValues[\"NUMERIC\"] = 1] = \"NUMERIC\";\n  ModeValues[ModeValues[\"ALPHANUMERIC\"] = 2] = \"ALPHANUMERIC\";\n  ModeValues[ModeValues[\"STRUCTURED_APPEND\"] = 3] = \"STRUCTURED_APPEND\";\n  ModeValues[ModeValues[\"BYTE\"] = 4] = \"BYTE\";\n  ModeValues[ModeValues[\"ECI\"] = 5] = \"ECI\";\n  ModeValues[ModeValues[\"KANJI\"] = 6] = \"KANJI\";\n  ModeValues[ModeValues[\"FNC1_FIRST_POSITION\"] = 7] = \"FNC1_FIRST_POSITION\";\n  ModeValues[ModeValues[\"FNC1_SECOND_POSITION\"] = 8] = \"FNC1_SECOND_POSITION\";\n  /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\n  ModeValues[ModeValues[\"HANZI\"] = 9] = \"HANZI\";\n})(ModeValues || (ModeValues = {}));\n/**\r\n * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which\r\n * data can be encoded to bits in the QR code standard.</p>\r\n *\r\n * @author Sean Owen\r\n */\nvar Mode = /** @class */function () {\n  function Mode(value, stringValue, characterCountBitsForVersions, bits /*int*/) {\n    this.value = value;\n    this.stringValue = stringValue;\n    this.characterCountBitsForVersions = characterCountBitsForVersions;\n    this.bits = bits;\n    Mode.FOR_BITS.set(bits, this);\n    Mode.FOR_VALUE.set(value, this);\n  }\n  /**\r\n   * @param bits four bits encoding a QR Code data mode\r\n   * @return Mode encoded by these bits\r\n   * @throws IllegalArgumentException if bits do not correspond to a known mode\r\n   */\n  Mode.forBits = function (bits /*int*/) {\n    var mode = Mode.FOR_BITS.get(bits);\n    if (undefined === mode) {\n      throw new IllegalArgumentException();\n    }\n    return mode;\n  };\n  /**\r\n   * @param version version in question\r\n   * @return number of bits used, in this QR Code symbol {@link Version}, to encode the\r\n   *         count of characters that will follow encoded in this Mode\r\n   */\n  Mode.prototype.getCharacterCountBits = function (version) {\n    var versionNumber = version.getVersionNumber();\n    var offset;\n    if (versionNumber <= 9) {\n      offset = 0;\n    } else if (versionNumber <= 26) {\n      offset = 1;\n    } else {\n      offset = 2;\n    }\n    return this.characterCountBitsForVersions[offset];\n  };\n  Mode.prototype.getValue = function () {\n    return this.value;\n  };\n  Mode.prototype.getBits = function () {\n    return this.bits;\n  };\n  Mode.prototype.equals = function (o) {\n    if (!(o instanceof Mode)) {\n      return false;\n    }\n    var other = o;\n    return this.value === other.value;\n  };\n  Mode.prototype.toString = function () {\n    return this.stringValue;\n  };\n  Mode.FOR_BITS = new Map();\n  Mode.FOR_VALUE = new Map();\n  Mode.TERMINATOR = new Mode(ModeValues.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0x00); // Not really a mode...\n  Mode.NUMERIC = new Mode(ModeValues.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 0x01);\n  Mode.ALPHANUMERIC = new Mode(ModeValues.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 0x02);\n  Mode.STRUCTURED_APPEND = new Mode(ModeValues.STRUCTURED_APPEND, 'STRUCTURED_APPEND', Int32Array.from([0, 0, 0]), 0x03); // Not supported\n  Mode.BYTE = new Mode(ModeValues.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 0x04);\n  Mode.ECI = new Mode(ModeValues.ECI, 'ECI', Int32Array.from([0, 0, 0]), 0x07); // character counts don't apply\n  Mode.KANJI = new Mode(ModeValues.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 0x08);\n  Mode.FNC1_FIRST_POSITION = new Mode(ModeValues.FNC1_FIRST_POSITION, 'FNC1_FIRST_POSITION', Int32Array.from([0, 0, 0]), 0x05);\n  Mode.FNC1_SECOND_POSITION = new Mode(ModeValues.FNC1_SECOND_POSITION, 'FNC1_SECOND_POSITION', Int32Array.from([0, 0, 0]), 0x09);\n  /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\n  Mode.HANZI = new Mode(ModeValues.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 0x0D);\n  return Mode;\n}();\nexport default Mode;","map":{"version":3,"names":["IllegalArgumentException","ModeValues","Mode","value","stringValue","characterCountBitsForVersions","bits","FOR_BITS","set","FOR_VALUE","forBits","mode","get","undefined","prototype","getCharacterCountBits","version","versionNumber","getVersionNumber","offset","getValue","getBits","equals","o","other","toString","Map","TERMINATOR","Int32Array","from","NUMERIC","ALPHANUMERIC","STRUCTURED_APPEND","BYTE","ECI","KANJI","FNC1_FIRST_POSITION","FNC1_SECOND_POSITION","HANZI"],"sources":["D:/Git/GME-Angular2/node_modules/@zxing/library/esm/core/qrcode/decoder/Mode.js"],"sourcesContent":["/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport IllegalArgumentException from '../../IllegalArgumentException';\r\nexport var ModeValues;\r\n(function (ModeValues) {\r\n    ModeValues[ModeValues[\"TERMINATOR\"] = 0] = \"TERMINATOR\";\r\n    ModeValues[ModeValues[\"NUMERIC\"] = 1] = \"NUMERIC\";\r\n    ModeValues[ModeValues[\"ALPHANUMERIC\"] = 2] = \"ALPHANUMERIC\";\r\n    ModeValues[ModeValues[\"STRUCTURED_APPEND\"] = 3] = \"STRUCTURED_APPEND\";\r\n    ModeValues[ModeValues[\"BYTE\"] = 4] = \"BYTE\";\r\n    ModeValues[ModeValues[\"ECI\"] = 5] = \"ECI\";\r\n    ModeValues[ModeValues[\"KANJI\"] = 6] = \"KANJI\";\r\n    ModeValues[ModeValues[\"FNC1_FIRST_POSITION\"] = 7] = \"FNC1_FIRST_POSITION\";\r\n    ModeValues[ModeValues[\"FNC1_SECOND_POSITION\"] = 8] = \"FNC1_SECOND_POSITION\";\r\n    /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\r\n    ModeValues[ModeValues[\"HANZI\"] = 9] = \"HANZI\";\r\n})(ModeValues || (ModeValues = {}));\r\n/**\r\n * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which\r\n * data can be encoded to bits in the QR code standard.</p>\r\n *\r\n * @author Sean Owen\r\n */\r\nvar Mode = /** @class */ (function () {\r\n    function Mode(value, stringValue, characterCountBitsForVersions, bits /*int*/) {\r\n        this.value = value;\r\n        this.stringValue = stringValue;\r\n        this.characterCountBitsForVersions = characterCountBitsForVersions;\r\n        this.bits = bits;\r\n        Mode.FOR_BITS.set(bits, this);\r\n        Mode.FOR_VALUE.set(value, this);\r\n    }\r\n    /**\r\n     * @param bits four bits encoding a QR Code data mode\r\n     * @return Mode encoded by these bits\r\n     * @throws IllegalArgumentException if bits do not correspond to a known mode\r\n     */\r\n    Mode.forBits = function (bits /*int*/) {\r\n        var mode = Mode.FOR_BITS.get(bits);\r\n        if (undefined === mode) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n        return mode;\r\n    };\r\n    /**\r\n     * @param version version in question\r\n     * @return number of bits used, in this QR Code symbol {@link Version}, to encode the\r\n     *         count of characters that will follow encoded in this Mode\r\n     */\r\n    Mode.prototype.getCharacterCountBits = function (version) {\r\n        var versionNumber = version.getVersionNumber();\r\n        var offset;\r\n        if (versionNumber <= 9) {\r\n            offset = 0;\r\n        }\r\n        else if (versionNumber <= 26) {\r\n            offset = 1;\r\n        }\r\n        else {\r\n            offset = 2;\r\n        }\r\n        return this.characterCountBitsForVersions[offset];\r\n    };\r\n    Mode.prototype.getValue = function () {\r\n        return this.value;\r\n    };\r\n    Mode.prototype.getBits = function () {\r\n        return this.bits;\r\n    };\r\n    Mode.prototype.equals = function (o) {\r\n        if (!(o instanceof Mode)) {\r\n            return false;\r\n        }\r\n        var other = o;\r\n        return this.value === other.value;\r\n    };\r\n    Mode.prototype.toString = function () {\r\n        return this.stringValue;\r\n    };\r\n    Mode.FOR_BITS = new Map();\r\n    Mode.FOR_VALUE = new Map();\r\n    Mode.TERMINATOR = new Mode(ModeValues.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0x00); // Not really a mode...\r\n    Mode.NUMERIC = new Mode(ModeValues.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 0x01);\r\n    Mode.ALPHANUMERIC = new Mode(ModeValues.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 0x02);\r\n    Mode.STRUCTURED_APPEND = new Mode(ModeValues.STRUCTURED_APPEND, 'STRUCTURED_APPEND', Int32Array.from([0, 0, 0]), 0x03); // Not supported\r\n    Mode.BYTE = new Mode(ModeValues.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 0x04);\r\n    Mode.ECI = new Mode(ModeValues.ECI, 'ECI', Int32Array.from([0, 0, 0]), 0x07); // character counts don't apply\r\n    Mode.KANJI = new Mode(ModeValues.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 0x08);\r\n    Mode.FNC1_FIRST_POSITION = new Mode(ModeValues.FNC1_FIRST_POSITION, 'FNC1_FIRST_POSITION', Int32Array.from([0, 0, 0]), 0x05);\r\n    Mode.FNC1_SECOND_POSITION = new Mode(ModeValues.FNC1_SECOND_POSITION, 'FNC1_SECOND_POSITION', Int32Array.from([0, 0, 0]), 0x09);\r\n    /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\r\n    Mode.HANZI = new Mode(ModeValues.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 0x0D);\r\n    return Mode;\r\n}());\r\nexport default Mode;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}