{"ast":null,"code":"/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/*namespace com.google.zxing.common {*/\nimport IllegalArgumentException from '../IllegalArgumentException';\n/**\r\n * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the\r\n * number of bits read is not often a multiple of 8.</p>\r\n *\r\n * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array\r\n * it passed in, in which case all bets are off.</p>\r\n *\r\n * @author Sean Owen\r\n */\nvar BitSource = /** @class */function () {\n  /**\r\n   * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.\r\n   * Bits are read within a byte from most-significant to least-significant bit.\r\n   */\n  function BitSource(bytes) {\n    this.bytes = bytes;\n    this.byteOffset = 0;\n    this.bitOffset = 0;\n  }\n  /**\r\n   * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.\r\n   */\n  BitSource.prototype.getBitOffset = function () {\n    return this.bitOffset;\n  };\n  /**\r\n   * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.\r\n   */\n  BitSource.prototype.getByteOffset = function () {\n    return this.byteOffset;\n  };\n  /**\r\n   * @param numBits number of bits to read\r\n   * @return int representing the bits read. The bits will appear as the least-significant\r\n   *         bits of the int\r\n   * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available\r\n   */\n  BitSource.prototype.readBits = function (numBits /*int*/) {\n    if (numBits < 1 || numBits > 32 || numBits > this.available()) {\n      throw new IllegalArgumentException('' + numBits);\n    }\n    var result = 0;\n    var bitOffset = this.bitOffset;\n    var byteOffset = this.byteOffset;\n    var bytes = this.bytes;\n    // First, read remainder from current byte\n    if (bitOffset > 0) {\n      var bitsLeft = 8 - bitOffset;\n      var toRead = numBits < bitsLeft ? numBits : bitsLeft;\n      var bitsToNotRead = bitsLeft - toRead;\n      var mask = 0xFF >> 8 - toRead << bitsToNotRead;\n      result = (bytes[byteOffset] & mask) >> bitsToNotRead;\n      numBits -= toRead;\n      bitOffset += toRead;\n      if (bitOffset === 8) {\n        bitOffset = 0;\n        byteOffset++;\n      }\n    }\n    // Next read whole bytes\n    if (numBits > 0) {\n      while (numBits >= 8) {\n        result = result << 8 | bytes[byteOffset] & 0xFF;\n        byteOffset++;\n        numBits -= 8;\n      }\n      // Finally read a partial byte\n      if (numBits > 0) {\n        var bitsToNotRead = 8 - numBits;\n        var mask = 0xFF >> bitsToNotRead << bitsToNotRead;\n        result = result << numBits | (bytes[byteOffset] & mask) >> bitsToNotRead;\n        bitOffset += numBits;\n      }\n    }\n    this.bitOffset = bitOffset;\n    this.byteOffset = byteOffset;\n    return result;\n  };\n  /**\r\n   * @return number of bits that can be read successfully\r\n   */\n  BitSource.prototype.available = function () {\n    return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;\n  };\n  return BitSource;\n}();\nexport default BitSource;","map":{"version":3,"names":["IllegalArgumentException","BitSource","bytes","byteOffset","bitOffset","prototype","getBitOffset","getByteOffset","readBits","numBits","available","result","bitsLeft","toRead","bitsToNotRead","mask","length"],"sources":["D:/Git/GME-Angular2/node_modules/@zxing/library/esm/core/common/BitSource.js"],"sourcesContent":["/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/*namespace com.google.zxing.common {*/\r\nimport IllegalArgumentException from '../IllegalArgumentException';\r\n/**\r\n * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the\r\n * number of bits read is not often a multiple of 8.</p>\r\n *\r\n * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array\r\n * it passed in, in which case all bets are off.</p>\r\n *\r\n * @author Sean Owen\r\n */\r\nvar BitSource = /** @class */ (function () {\r\n    /**\r\n     * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.\r\n     * Bits are read within a byte from most-significant to least-significant bit.\r\n     */\r\n    function BitSource(bytes) {\r\n        this.bytes = bytes;\r\n        this.byteOffset = 0;\r\n        this.bitOffset = 0;\r\n    }\r\n    /**\r\n     * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.\r\n     */\r\n    BitSource.prototype.getBitOffset = function () {\r\n        return this.bitOffset;\r\n    };\r\n    /**\r\n     * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.\r\n     */\r\n    BitSource.prototype.getByteOffset = function () {\r\n        return this.byteOffset;\r\n    };\r\n    /**\r\n     * @param numBits number of bits to read\r\n     * @return int representing the bits read. The bits will appear as the least-significant\r\n     *         bits of the int\r\n     * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available\r\n     */\r\n    BitSource.prototype.readBits = function (numBits /*int*/) {\r\n        if (numBits < 1 || numBits > 32 || numBits > this.available()) {\r\n            throw new IllegalArgumentException('' + numBits);\r\n        }\r\n        var result = 0;\r\n        var bitOffset = this.bitOffset;\r\n        var byteOffset = this.byteOffset;\r\n        var bytes = this.bytes;\r\n        // First, read remainder from current byte\r\n        if (bitOffset > 0) {\r\n            var bitsLeft = 8 - bitOffset;\r\n            var toRead = numBits < bitsLeft ? numBits : bitsLeft;\r\n            var bitsToNotRead = bitsLeft - toRead;\r\n            var mask = (0xFF >> (8 - toRead)) << bitsToNotRead;\r\n            result = (bytes[byteOffset] & mask) >> bitsToNotRead;\r\n            numBits -= toRead;\r\n            bitOffset += toRead;\r\n            if (bitOffset === 8) {\r\n                bitOffset = 0;\r\n                byteOffset++;\r\n            }\r\n        }\r\n        // Next read whole bytes\r\n        if (numBits > 0) {\r\n            while (numBits >= 8) {\r\n                result = (result << 8) | (bytes[byteOffset] & 0xFF);\r\n                byteOffset++;\r\n                numBits -= 8;\r\n            }\r\n            // Finally read a partial byte\r\n            if (numBits > 0) {\r\n                var bitsToNotRead = 8 - numBits;\r\n                var mask = (0xFF >> bitsToNotRead) << bitsToNotRead;\r\n                result = (result << numBits) | ((bytes[byteOffset] & mask) >> bitsToNotRead);\r\n                bitOffset += numBits;\r\n            }\r\n        }\r\n        this.bitOffset = bitOffset;\r\n        this.byteOffset = byteOffset;\r\n        return result;\r\n    };\r\n    /**\r\n     * @return number of bits that can be read successfully\r\n     */\r\n    BitSource.prototype.available = function () {\r\n        return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;\r\n    };\r\n    return BitSource;\r\n}());\r\nexport default BitSource;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}