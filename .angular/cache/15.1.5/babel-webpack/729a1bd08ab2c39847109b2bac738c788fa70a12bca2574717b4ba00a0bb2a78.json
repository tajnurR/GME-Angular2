{"ast":null,"code":"/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/*namespace com.google.zxing.qrcode {*/\nimport BarcodeFormat from '../BarcodeFormat';\nimport BitMatrix from '../common/BitMatrix';\nimport DecodeHintType from '../DecodeHintType';\nimport NotFoundException from '../NotFoundException';\nimport Result from '../Result';\nimport ResultMetadataType from '../ResultMetadataType';\n// import DetectorResult from '../common/DetectorResult';\nimport Decoder from './decoder/Decoder';\nimport QRCodeDecoderMetaData from './decoder/QRCodeDecoderMetaData';\nimport Detector from './detector/Detector';\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\r\n * This implementation can detect and decode QR Codes in an image.\r\n *\r\n * @author Sean Owen\r\n */\nvar QRCodeReader = /** @class */function () {\n  function QRCodeReader() {\n    this.decoder = new Decoder();\n  }\n  QRCodeReader.prototype.getDecoder = function () {\n    return this.decoder;\n  };\n  /**\r\n   * Locates and decodes a QR code in an image.\r\n   *\r\n   * @return a representing: string the content encoded by the QR code\r\n   * @throws NotFoundException if a QR code cannot be found\r\n   * @throws FormatException if a QR code cannot be decoded\r\n   * @throws ChecksumException if error correction fails\r\n   */\n  /*@Override*/\n  // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {\n  //   return this.decode(image, null)\n  // }\n  /*@Override*/\n  QRCodeReader.prototype.decode = function (image, hints) {\n    var decoderResult;\n    var points;\n    if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType.PURE_BARCODE)) {\n      var bits = QRCodeReader.extractPureBits(image.getBlackMatrix());\n      decoderResult = this.decoder.decodeBitMatrix(bits, hints);\n      points = QRCodeReader.NO_POINTS;\n    } else {\n      var detectorResult = new Detector(image.getBlackMatrix()).detect(hints);\n      decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);\n      points = detectorResult.getPoints();\n    }\n    // If the code was mirrored: swap the bottom-left and the top-right points.\n    if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {\n      decoderResult.getOther().applyMirroredCorrection(points);\n    }\n    var result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat.QR_CODE, undefined);\n    var byteSegments = decoderResult.getByteSegments();\n    if (byteSegments !== null) {\n      result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);\n    }\n    var ecLevel = decoderResult.getECLevel();\n    if (ecLevel !== null) {\n      result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);\n    }\n    if (decoderResult.hasStructuredAppend()) {\n      result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());\n      result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());\n    }\n    return result;\n  };\n  /*@Override*/\n  QRCodeReader.prototype.reset = function () {\n    // do nothing\n  };\n  /**\r\n   * This method detects a code in a \"pure\" image -- that is, pure monochrome image\r\n   * which contains only an unrotated, unskewed, image of a code, with some white border\r\n   * around it. This is a specialized method that works exceptionally fast in this special\r\n   * case.\r\n   *\r\n   * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)\r\n   */\n  QRCodeReader.extractPureBits = function (image) {\n    var leftTopBlack = image.getTopLeftOnBit();\n    var rightBottomBlack = image.getBottomRightOnBit();\n    if (leftTopBlack === null || rightBottomBlack === null) {\n      throw new NotFoundException();\n    }\n    var moduleSize = this.moduleSize(leftTopBlack, image);\n    var top = leftTopBlack[1];\n    var bottom = rightBottomBlack[1];\n    var left = leftTopBlack[0];\n    var right = rightBottomBlack[0];\n    // Sanity check!\n    if (left >= right || top >= bottom) {\n      throw new NotFoundException();\n    }\n    if (bottom - top !== right - left) {\n      // Special case, where bottom-right module wasn't black so we found something else in the last row\n      // Assume it's a square, so use height as the width\n      right = left + (bottom - top);\n      if (right >= image.getWidth()) {\n        // Abort if that would not make sense -- off image\n        throw new NotFoundException();\n      }\n    }\n    var matrixWidth = Math.round((right - left + 1) / moduleSize);\n    var matrixHeight = Math.round((bottom - top + 1) / moduleSize);\n    if (matrixWidth <= 0 || matrixHeight <= 0) {\n      throw new NotFoundException();\n    }\n    if (matrixHeight !== matrixWidth) {\n      // Only possibly decode square regions\n      throw new NotFoundException();\n    }\n    // Push in the \"border\" by half the module width so that we start\n    // sampling in the middle of the module. Just in case the image is a\n    // little off, this will help recover.\n    var nudge = /*(int) */Math.floor(moduleSize / 2.0);\n    top += nudge;\n    left += nudge;\n    // But careful that this does not sample off the edge\n    // \"right\" is the farthest-right valid pixel location -- right+1 is not necessarily\n    // This is positive by how much the inner x loop below would be too large\n    var nudgedTooFarRight = left + /*(int) */Math.floor((matrixWidth - 1) * moduleSize) - right;\n    if (nudgedTooFarRight > 0) {\n      if (nudgedTooFarRight > nudge) {\n        // Neither way fits; abort\n        throw new NotFoundException();\n      }\n      left -= nudgedTooFarRight;\n    }\n    // See logic above\n    var nudgedTooFarDown = top + /*(int) */Math.floor((matrixHeight - 1) * moduleSize) - bottom;\n    if (nudgedTooFarDown > 0) {\n      if (nudgedTooFarDown > nudge) {\n        // Neither way fits; abort\n        throw new NotFoundException();\n      }\n      top -= nudgedTooFarDown;\n    }\n    // Now just read off the bits\n    var bits = new BitMatrix(matrixWidth, matrixHeight);\n    for (var y = 0; y < matrixHeight; y++) {\n      var iOffset = top + /*(int) */Math.floor(y * moduleSize);\n      for (var x = 0; x < matrixWidth; x++) {\n        if (image.get(left + /*(int) */Math.floor(x * moduleSize), iOffset)) {\n          bits.set(x, y);\n        }\n      }\n    }\n    return bits;\n  };\n  QRCodeReader.moduleSize = function (leftTopBlack, image) {\n    var height = image.getHeight();\n    var width = image.getWidth();\n    var x = leftTopBlack[0];\n    var y = leftTopBlack[1];\n    var inBlack = true;\n    var transitions = 0;\n    while (x < width && y < height) {\n      if (inBlack !== image.get(x, y)) {\n        if (++transitions === 5) {\n          break;\n        }\n        inBlack = !inBlack;\n      }\n      x++;\n      y++;\n    }\n    if (x === width || y === height) {\n      throw new NotFoundException();\n    }\n    return (x - leftTopBlack[0]) / 7.0;\n  };\n  QRCodeReader.NO_POINTS = new Array();\n  return QRCodeReader;\n}();\nexport default QRCodeReader;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}