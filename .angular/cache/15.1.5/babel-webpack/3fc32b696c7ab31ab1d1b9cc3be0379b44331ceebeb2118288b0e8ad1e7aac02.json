{"ast":null,"code":"/*\r\n * Copyright 2008 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/*namespace com.google.zxing.qrcode {*/\nimport BarcodeFormat from '../BarcodeFormat';\nimport EncodeHintType from '../EncodeHintType';\nimport BitMatrix from '../common/BitMatrix';\nimport ErrorCorrectionLevel from './decoder/ErrorCorrectionLevel';\nimport Encoder from './encoder/Encoder';\nimport IllegalArgumentException from '../IllegalArgumentException';\nimport IllegalStateException from '../IllegalStateException';\n/*import java.util.Map;*/\n/**\r\n * This object renders a QR Code as a BitMatrix 2D array of greyscale values.\r\n *\r\n * @author dswitkin@google.com (Daniel Switkin)\r\n */\nvar QRCodeWriter = /** @class */function () {\n  function QRCodeWriter() {}\n  /*@Override*/\n  // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix\n  //     /*throws WriterException */ {\n  //   return encode(contents, format, width, height, null)\n  // }\n  /*@Override*/\n  QRCodeWriter.prototype.encode = function (contents, format, width /*int*/, height /*int*/, hints) {\n    if (contents.length === 0) {\n      throw new IllegalArgumentException('Found empty contents');\n    }\n    if (format !== BarcodeFormat.QR_CODE) {\n      throw new IllegalArgumentException('Can only encode QR_CODE, but got ' + format);\n    }\n    if (width < 0 || height < 0) {\n      throw new IllegalArgumentException(\"Requested dimensions are too small: \" + width + \"x\" + height);\n    }\n    var errorCorrectionLevel = ErrorCorrectionLevel.L;\n    var quietZone = QRCodeWriter.QUIET_ZONE_SIZE;\n    if (hints !== null) {\n      if (undefined !== hints.get(EncodeHintType.ERROR_CORRECTION)) {\n        errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType.ERROR_CORRECTION).toString());\n      }\n      if (undefined !== hints.get(EncodeHintType.MARGIN)) {\n        quietZone = Number.parseInt(hints.get(EncodeHintType.MARGIN).toString(), 10);\n      }\n    }\n    var code = Encoder.encode(contents, errorCorrectionLevel, hints);\n    return QRCodeWriter.renderResult(code, width, height, quietZone);\n  };\n  // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses\n  // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).\n  QRCodeWriter.renderResult = function (code, width /*int*/, height /*int*/, quietZone /*int*/) {\n    var input = code.getMatrix();\n    if (input === null) {\n      throw new IllegalStateException();\n    }\n    var inputWidth = input.getWidth();\n    var inputHeight = input.getHeight();\n    var qrWidth = inputWidth + quietZone * 2;\n    var qrHeight = inputHeight + quietZone * 2;\n    var outputWidth = Math.max(width, qrWidth);\n    var outputHeight = Math.max(height, qrHeight);\n    var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));\n    // Padding includes both the quiet zone and the extra white pixels to accommodate the requested\n    // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.\n    // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will\n    // handle all the padding from 100x100 (the actual QR) up to 200x160.\n    var leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);\n    var topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);\n    var output = new BitMatrix(outputWidth, outputHeight);\n    for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n      // Write the contents of this row of the barcode\n      for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n        if (input.get(inputX, inputY) === 1) {\n          output.setRegion(outputX, outputY, multiple, multiple);\n        }\n      }\n    }\n    return output;\n  };\n  QRCodeWriter.QUIET_ZONE_SIZE = 4;\n  return QRCodeWriter;\n}();\nexport default QRCodeWriter;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}