{"ast":null,"code":"/*\r\n * Copyright 2008 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nimport BitArray from '../common/BitArray';\nimport DecodeHintType from '../DecodeHintType';\nimport ResultMetadataType from '../ResultMetadataType';\nimport ResultPoint from '../ResultPoint';\nimport NotFoundException from '../NotFoundException';\n/**\r\n * Encapsulates functionality and implementation that is common to all families\r\n * of one-dimensional barcodes.\r\n *\r\n * @author dswitkin@google.com (Daniel Switkin)\r\n * @author Sean Owen\r\n */\nvar OneDReader = /** @class */function () {\n  function OneDReader() {}\n  /*\r\n  @Override\r\n  public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {\r\n    return decode(image, null);\r\n  }\r\n  */\n  // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n  // @Override\n  OneDReader.prototype.decode = function (image, hints) {\n    try {\n      return this.doDecode(image, hints);\n    } catch (nfe) {\n      var tryHarder = hints && hints.get(DecodeHintType.TRY_HARDER) === true;\n      if (tryHarder && image.isRotateSupported()) {\n        var rotatedImage = image.rotateCounterClockwise();\n        var result = this.doDecode(rotatedImage, hints);\n        // Record that we found it rotated 90 degrees CCW / 270 degrees CW\n        var metadata = result.getResultMetadata();\n        var orientation_1 = 270;\n        if (metadata !== null && metadata.get(ResultMetadataType.ORIENTATION) === true) {\n          // But if we found it reversed in doDecode(), add in that result here:\n          orientation_1 = orientation_1 + metadata.get(ResultMetadataType.ORIENTATION) % 360;\n        }\n        result.putMetadata(ResultMetadataType.ORIENTATION, orientation_1);\n        // Update result points\n        var points = result.getResultPoints();\n        if (points !== null) {\n          var height = rotatedImage.getHeight();\n          for (var i = 0; i < points.length; i++) {\n            points[i] = new ResultPoint(height - points[i].getY() - 1, points[i].getX());\n          }\n        }\n        return result;\n      } else {\n        throw new NotFoundException();\n      }\n    }\n  };\n  // @Override\n  OneDReader.prototype.reset = function () {\n    // do nothing\n  };\n  /**\r\n   * We're going to examine rows from the middle outward, searching alternately above and below the\r\n   * middle, and farther out each time. rowStep is the number of rows between each successive\r\n   * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then\r\n   * middle + rowStep, then middle - (2 * rowStep), etc.\r\n   * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily\r\n   * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the\r\n   * image if \"trying harder\".\r\n   *\r\n   * @param image The image to decode\r\n   * @param hints Any hints that were requested\r\n   * @return The contents of the decoded barcode\r\n   * @throws NotFoundException Any spontaneous errors which occur\r\n   */\n  OneDReader.prototype.doDecode = function (image, hints) {\n    var width = image.getWidth();\n    var height = image.getHeight();\n    var row = new BitArray(width);\n    var tryHarder = hints && hints.get(DecodeHintType.TRY_HARDER) === true;\n    var rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));\n    var maxLines;\n    if (tryHarder) {\n      maxLines = height; // Look at the whole image, not just the center\n    } else {\n      maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image\n    }\n\n    var middle = Math.trunc(height / 2);\n    for (var x = 0; x < maxLines; x++) {\n      // Scanning from the middle out. Determine which row we're looking at next:\n      var rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);\n      var isAbove = (x & 0x01) === 0; // i.e. is x even?\n      var rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);\n      if (rowNumber < 0 || rowNumber >= height) {\n        // Oops, if we run off the top or bottom, stop\n        break;\n      }\n      // Estimate black point for this row and load it:\n      try {\n        row = image.getBlackRow(rowNumber, row);\n      } catch (ignored) {\n        continue;\n      }\n      var _loop_1 = function (attempt) {\n        if (attempt === 1) {\n          // trying again?\n          row.reverse(); // reverse the row and continue\n          // This means we will only ever draw result points *once* in the life of this method\n          // since we want to avoid drawing the wrong points after flipping the row, and,\n          // don't want to clutter with noise from every single row scan -- just the scans\n          // that start on the center line.\n          if (hints && hints.get(DecodeHintType.NEED_RESULT_POINT_CALLBACK) === true) {\n            var newHints_1 = new Map();\n            hints.forEach(function (hint, key) {\n              return newHints_1.set(key, hint);\n            });\n            newHints_1.delete(DecodeHintType.NEED_RESULT_POINT_CALLBACK);\n            hints = newHints_1;\n          }\n        }\n        try {\n          // Look for a barcode\n          var result = this_1.decodeRow(rowNumber, row, hints);\n          // We found our barcode\n          if (attempt === 1) {\n            // But it was upside down, so note that\n            result.putMetadata(ResultMetadataType.ORIENTATION, 180);\n            // And remember to flip the result points horizontally.\n            var points = result.getResultPoints();\n            if (points !== null) {\n              points[0] = new ResultPoint(width - points[0].getX() - 1, points[0].getY());\n              points[1] = new ResultPoint(width - points[1].getX() - 1, points[1].getY());\n            }\n          }\n          return {\n            value: result\n          };\n        } catch (re) {\n          // continue -- just couldn't decode this row\n        }\n      };\n      var this_1 = this;\n      // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to\n      // handle decoding upside down barcodes.\n      for (var attempt = 0; attempt < 2; attempt++) {\n        var state_1 = _loop_1(attempt);\n        if (typeof state_1 === \"object\") return state_1.value;\n      }\n    }\n    throw new NotFoundException();\n  };\n  /**\r\n   * Records the size of successive runs of white and black pixels in a row, starting at a given point.\r\n   * The values are recorded in the given array, and the number of runs recorded is equal to the size\r\n   * of the array. If the row starts on a white pixel at the given start point, then the first count\r\n   * recorded is the run of white pixels starting from that point; likewise it is the count of a run\r\n   * of black pixels if the row begin on a black pixels at that point.\r\n   *\r\n   * @param row row to count from\r\n   * @param start offset into row to start at\r\n   * @param counters array into which to record counts\r\n   * @throws NotFoundException if counters cannot be filled entirely from row before running out\r\n   *  of pixels\r\n   */\n  OneDReader.recordPattern = function (row, start, counters) {\n    var numCounters = counters.length;\n    for (var index = 0; index < numCounters; index++) counters[index] = 0;\n    var end = row.getSize();\n    if (start >= end) {\n      throw new NotFoundException();\n    }\n    var isWhite = !row.get(start);\n    var counterPosition = 0;\n    var i = start;\n    while (i < end) {\n      if (row.get(i) !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (++counterPosition === numCounters) {\n          break;\n        } else {\n          counters[counterPosition] = 1;\n          isWhite = !isWhite;\n        }\n      }\n      i++;\n    }\n    // If we read fully the last section of pixels and filled up our counters -- or filled\n    // the last counter but ran off the side of the image, OK. Otherwise, a problem.\n    if (!(counterPosition === numCounters || counterPosition === numCounters - 1 && i === end)) {\n      throw new NotFoundException();\n    }\n  };\n  OneDReader.recordPatternInReverse = function (row, start, counters) {\n    // This could be more efficient I guess\n    var numTransitionsLeft = counters.length;\n    var last = row.get(start);\n    while (start > 0 && numTransitionsLeft >= 0) {\n      if (row.get(--start) !== last) {\n        numTransitionsLeft--;\n        last = !last;\n      }\n    }\n    if (numTransitionsLeft >= 0) {\n      throw new NotFoundException();\n    }\n    OneDReader.recordPattern(row, start + 1, counters);\n  };\n  /**\r\n   * Determines how closely a set of observed counts of runs of black/white values matches a given\r\n   * target pattern. This is reported as the ratio of the total variance from the expected pattern\r\n   * proportions across all pattern elements, to the length of the pattern.\r\n   *\r\n   * @param counters observed counters\r\n   * @param pattern expected pattern\r\n   * @param maxIndividualVariance The most any counter can differ before we give up\r\n   * @return ratio of total variance between counters and pattern compared to total pattern size\r\n   */\n  OneDReader.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {\n    var numCounters = counters.length;\n    var total = 0;\n    var patternLength = 0;\n    for (var i = 0; i < numCounters; i++) {\n      total += counters[i];\n      patternLength += pattern[i];\n    }\n    if (total < patternLength) {\n      // If we don't even have one pixel per unit of bar width, assume this is too small\n      // to reliably match, so fail:\n      return Number.POSITIVE_INFINITY;\n    }\n    var unitBarWidth = total / patternLength;\n    maxIndividualVariance *= unitBarWidth;\n    var totalVariance = 0.0;\n    for (var x = 0; x < numCounters; x++) {\n      var counter = counters[x];\n      var scaledPattern = pattern[x] * unitBarWidth;\n      var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n      if (variance > maxIndividualVariance) {\n        return Number.POSITIVE_INFINITY;\n      }\n      totalVariance += variance;\n    }\n    return totalVariance / total;\n  };\n  return OneDReader;\n}();\nexport default OneDReader;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}