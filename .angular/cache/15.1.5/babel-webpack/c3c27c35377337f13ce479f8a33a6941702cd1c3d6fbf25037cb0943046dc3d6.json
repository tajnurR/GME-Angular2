{"ast":null,"code":"/*\r\n * Copyright 2013 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n// package com.google.zxing.aztec.encoder;\n// import java.util.Deque;\n// import java.util.LinkedList;\n// import com.google.zxing.common.BitArray;\nimport BitArray from '../../common/BitArray';\nimport * as TokenHelpers from './TokenHelpers';\nimport * as C from './EncoderConstants';\nimport * as LatchTable from './LatchTable';\nimport * as ShiftTable from './ShiftTable';\nimport StringUtils from '../../common/StringUtils';\n/**\r\n * State represents all information about a sequence necessary to generate the current output.\r\n * Note that a state is immutable.\r\n */\nvar State = /** @class */function () {\n  function State(token, mode, binaryBytes, bitCount) {\n    this.token = token;\n    this.mode = mode;\n    this.binaryShiftByteCount = binaryBytes;\n    this.bitCount = bitCount;\n    // Make sure we match the token\n    // int binaryShiftBitCount = (binaryShiftByteCount * 8) +\n    //    (binaryShiftByteCount === 0 ? 0 :\n    //     binaryShiftByteCount <= 31 ? 10 :\n    //     binaryShiftByteCount <= 62 ? 20 : 21);\n    // assert this.bitCount === token.getTotalBitCount() + binaryShiftBitCount;\n  }\n\n  State.prototype.getMode = function () {\n    return this.mode;\n  };\n  State.prototype.getToken = function () {\n    return this.token;\n  };\n  State.prototype.getBinaryShiftByteCount = function () {\n    return this.binaryShiftByteCount;\n  };\n  State.prototype.getBitCount = function () {\n    return this.bitCount;\n  };\n  // Create a new state representing this state with a latch to a (not\n  // necessary different) mode, and then a code.\n  State.prototype.latchAndAppend = function (mode, value) {\n    // assert binaryShiftByteCount === 0;\n    var bitCount = this.bitCount;\n    var token = this.token;\n    if (mode !== this.mode) {\n      var latch = LatchTable.LATCH_TABLE[this.mode][mode];\n      token = TokenHelpers.add(token, latch & 0xffff, latch >> 16);\n      bitCount += latch >> 16;\n    }\n    var latchModeBitCount = mode === C.MODE_DIGIT ? 4 : 5;\n    token = TokenHelpers.add(token, value, latchModeBitCount);\n    return new State(token, mode, 0, bitCount + latchModeBitCount);\n  };\n  // Create a new state representing this state, with a temporary shift\n  // to a different mode to output a single value.\n  State.prototype.shiftAndAppend = function (mode, value) {\n    // assert binaryShiftByteCount === 0 && this.mode !== mode;\n    var token = this.token;\n    var thisModeBitCount = this.mode === C.MODE_DIGIT ? 4 : 5;\n    // Shifts exist only to UPPER and PUNCT, both with tokens size 5.\n    token = TokenHelpers.add(token, ShiftTable.SHIFT_TABLE[this.mode][mode], thisModeBitCount);\n    token = TokenHelpers.add(token, value, 5);\n    return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);\n  };\n  // Create a new state representing this state, but an additional character\n  // output in Binary Shift mode.\n  State.prototype.addBinaryShiftChar = function (index) {\n    var token = this.token;\n    var mode = this.mode;\n    var bitCount = this.bitCount;\n    if (this.mode === C.MODE_PUNCT || this.mode === C.MODE_DIGIT) {\n      // assert binaryShiftByteCount === 0;\n      var latch = LatchTable.LATCH_TABLE[mode][C.MODE_UPPER];\n      token = TokenHelpers.add(token, latch & 0xffff, latch >> 16);\n      bitCount += latch >> 16;\n      mode = C.MODE_UPPER;\n    }\n    var deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31 ? 18 : this.binaryShiftByteCount === 62 ? 9 : 8;\n    var result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);\n    if (result.binaryShiftByteCount === 2047 + 31) {\n      // The string is as long as it's allowed to be.  We should end it.\n      result = result.endBinaryShift(index + 1);\n    }\n    return result;\n  };\n  // Create the state identical to this one, but we are no longer in\n  // Binary Shift mode.\n  State.prototype.endBinaryShift = function (index) {\n    if (this.binaryShiftByteCount === 0) {\n      return this;\n    }\n    var token = this.token;\n    token = TokenHelpers.addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);\n    // assert token.getTotalBitCount() === this.bitCount;\n    return new State(token, this.mode, 0, this.bitCount);\n  };\n  // Returns true if \"this\" state is better (equal: or) to be in than \"that\"\n  // state under all possible circumstances.\n  State.prototype.isBetterThanOrEqualTo = function (other) {\n    var newModeBitCount = this.bitCount + (LatchTable.LATCH_TABLE[this.mode][other.mode] >> 16);\n    if (this.binaryShiftByteCount < other.binaryShiftByteCount) {\n      // add additional B/S encoding cost of other, if any\n      newModeBitCount += State.calculateBinaryShiftCost(other) - State.calculateBinaryShiftCost(this);\n    } else if (this.binaryShiftByteCount > other.binaryShiftByteCount && other.binaryShiftByteCount > 0) {\n      // maximum possible additional cost (it: h)\n      newModeBitCount += 10;\n    }\n    return newModeBitCount <= other.bitCount;\n  };\n  State.prototype.toBitArray = function (text) {\n    var e_1, _a;\n    // Reverse the tokens, so that they are in the order that they should\n    // be output\n    var symbols = [];\n    for (var token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {\n      symbols.unshift(token);\n    }\n    var bitArray = new BitArray();\n    try {\n      // Add each token to the result.\n      for (var symbols_1 = __values(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {\n        var symbol = symbols_1_1.value;\n        symbol.appendTo(bitArray, text);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (symbols_1_1 && !symbols_1_1.done && (_a = symbols_1.return)) _a.call(symbols_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    // assert bitArray.getSize() === this.bitCount;\n    return bitArray;\n  };\n  /**\r\n   * @Override\r\n   */\n  State.prototype.toString = function () {\n    return StringUtils.format('%s bits=%d bytes=%d', C.MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);\n  };\n  State.calculateBinaryShiftCost = function (state) {\n    if (state.binaryShiftByteCount > 62) {\n      return 21; // B/S with extended length\n    }\n\n    if (state.binaryShiftByteCount > 31) {\n      return 20; // two B/S\n    }\n\n    if (state.binaryShiftByteCount > 0) {\n      return 10; // one B/S\n    }\n\n    return 0;\n  };\n  State.INITIAL_STATE = new State(C.EMPTY_TOKEN, C.MODE_UPPER, 0, 0);\n  return State;\n}();\nexport default State;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}