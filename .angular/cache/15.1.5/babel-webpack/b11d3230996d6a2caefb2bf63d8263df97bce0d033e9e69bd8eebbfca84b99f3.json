{"ast":null,"code":"/*\r\n * Copyright 2008 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport OneDReader from './OneDReader';\nimport NotFoundException from '../NotFoundException';\nimport FormatException from '../FormatException';\n/**\r\n * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\r\n * of one-dimensional barcodes.</p>\r\n *\r\n * @author dswitkin@google.com (Daniel Switkin)\r\n * @author Sean Owen\r\n * @author alasdair@google.com (Alasdair Mackintosh)\r\n */\nvar AbstractUPCEANReader = /** @class */function (_super) {\n  __extends(AbstractUPCEANReader, _super);\n  function AbstractUPCEANReader() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.decodeRowStringBuffer = '';\n    return _this;\n  }\n  // private final UPCEANExtensionSupport extensionReader;\n  // private final EANManufacturerOrgSupport eanManSupport;\n  /*\r\n  protected UPCEANReader() {\r\n      decodeRowStringBuffer = new StringBuilder(20);\r\n      extensionReader = new UPCEANExtensionSupport();\r\n      eanManSupport = new EANManufacturerOrgSupport();\r\n  }\r\n  */\n  AbstractUPCEANReader.findStartGuardPattern = function (row) {\n    var foundStart = false;\n    var startRange;\n    var nextStart = 0;\n    var counters = Int32Array.from([0, 0, 0]);\n    while (!foundStart) {\n      counters = Int32Array.from([0, 0, 0]);\n      startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);\n      var start = startRange[0];\n      nextStart = startRange[1];\n      var quietStart = start - (nextStart - start);\n      if (quietStart >= 0) {\n        foundStart = row.isRange(quietStart, start, false);\n      }\n    }\n    return startRange;\n  };\n  AbstractUPCEANReader.checkChecksum = function (s) {\n    return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);\n  };\n  AbstractUPCEANReader.checkStandardUPCEANChecksum = function (s) {\n    var length = s.length;\n    if (length === 0) return false;\n    var check = parseInt(s.charAt(length - 1), 10);\n    return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n  };\n  AbstractUPCEANReader.getStandardUPCEANChecksum = function (s) {\n    var length = s.length;\n    var sum = 0;\n    for (var i = length - 1; i >= 0; i -= 2) {\n      var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n      if (digit < 0 || digit > 9) {\n        throw new FormatException();\n      }\n      sum += digit;\n    }\n    sum *= 3;\n    for (var i = length - 2; i >= 0; i -= 2) {\n      var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n      if (digit < 0 || digit > 9) {\n        throw new FormatException();\n      }\n      sum += digit;\n    }\n    return (1000 - sum) % 10;\n  };\n  AbstractUPCEANReader.decodeEnd = function (row, endStart) {\n    return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));\n  };\n  /**\r\n   * @throws NotFoundException\r\n   */\n  AbstractUPCEANReader.findGuardPatternWithoutCounters = function (row, rowOffset, whiteFirst, pattern) {\n    return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));\n  };\n  /**\r\n   * @param row row of black/white values to search\r\n   * @param rowOffset position to start search\r\n   * @param whiteFirst if true, indicates that the pattern specifies white/black/white/...\r\n   * pixel counts, otherwise, it is interpreted as black/white/black/...\r\n   * @param pattern pattern of counts of number of black and white pixels that are being\r\n   * searched for as a pattern\r\n   * @param counters array of counters, as long as pattern, to re-use\r\n   * @return start/end horizontal offset of guard pattern, as an array of two ints\r\n   * @throws NotFoundException if pattern is not found\r\n   */\n  AbstractUPCEANReader.findGuardPattern = function (row, rowOffset, whiteFirst, pattern, counters) {\n    var width = row.getSize();\n    rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);\n    var counterPosition = 0;\n    var patternStart = rowOffset;\n    var patternLength = pattern.length;\n    var isWhite = whiteFirst;\n    for (var x = rowOffset; x < width; x++) {\n      if (row.get(x) !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (counterPosition === patternLength - 1) {\n          if (OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {\n            return Int32Array.from([patternStart, x]);\n          }\n          patternStart += counters[0] + counters[1];\n          var slice = counters.slice(2, counters.length - 1);\n          for (var i = 0; i < counterPosition - 1; i++) {\n            counters[i] = slice[i];\n          }\n          counters[counterPosition - 1] = 0;\n          counters[counterPosition] = 0;\n          counterPosition--;\n        } else {\n          counterPosition++;\n        }\n        counters[counterPosition] = 1;\n        isWhite = !isWhite;\n      }\n    }\n    throw new NotFoundException();\n  };\n  AbstractUPCEANReader.decodeDigit = function (row, counters, rowOffset, patterns) {\n    this.recordPattern(row, rowOffset, counters);\n    var bestVariance = this.MAX_AVG_VARIANCE;\n    var bestMatch = -1;\n    var max = patterns.length;\n    for (var i = 0; i < max; i++) {\n      var pattern = patterns[i];\n      var variance = OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);\n      if (variance < bestVariance) {\n        bestVariance = variance;\n        bestMatch = i;\n      }\n    }\n    if (bestMatch >= 0) {\n      return bestMatch;\n    } else {\n      throw new NotFoundException();\n    }\n  };\n  // These two values are critical for determining how permissive the decoding will be.\n  // We've arrived at these values through a lot of trial and error. Setting them any higher\n  // lets false positives creep in quickly.\n  AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;\n  AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n  /**\r\n   * Start/end guard pattern.\r\n   */\n  AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([1, 1, 1]);\n  /**\r\n   * Pattern marking the middle of a UPC/EAN pattern, separating the two halves.\r\n   */\n  AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);\n  /**\r\n   * end guard pattern.\r\n   */\n  AbstractUPCEANReader.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);\n  /**\r\n   * \"Odd\", or \"L\" patterns used to encode UPC/EAN digits.\r\n   */\n  AbstractUPCEANReader.L_PATTERNS = [Int32Array.from([3, 2, 1, 1]), Int32Array.from([2, 2, 2, 1]), Int32Array.from([2, 1, 2, 2]), Int32Array.from([1, 4, 1, 1]), Int32Array.from([1, 1, 3, 2]), Int32Array.from([1, 2, 3, 1]), Int32Array.from([1, 1, 1, 4]), Int32Array.from([1, 3, 1, 2]), Int32Array.from([1, 2, 1, 3]), Int32Array.from([3, 1, 1, 2])];\n  return AbstractUPCEANReader;\n}(OneDReader);\nexport default AbstractUPCEANReader;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}