{"ast":null,"code":"/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/*namespace com.google.zxing.qrcode {*/\nimport BarcodeFormat from '../BarcodeFormat';\nimport BitMatrix from '../common/BitMatrix';\nimport DecodeHintType from '../DecodeHintType';\nimport NotFoundException from '../NotFoundException';\nimport Result from '../Result';\nimport ResultMetadataType from '../ResultMetadataType';\n// import DetectorResult from '../common/DetectorResult';\nimport Decoder from './decoder/Decoder';\nimport QRCodeDecoderMetaData from './decoder/QRCodeDecoderMetaData';\nimport Detector from './detector/Detector';\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\r\n * This implementation can detect and decode QR Codes in an image.\r\n *\r\n * @author Sean Owen\r\n */\nvar QRCodeReader = /** @class */function () {\n  function QRCodeReader() {\n    this.decoder = new Decoder();\n  }\n  QRCodeReader.prototype.getDecoder = function () {\n    return this.decoder;\n  };\n  /**\r\n   * Locates and decodes a QR code in an image.\r\n   *\r\n   * @return a representing: string the content encoded by the QR code\r\n   * @throws NotFoundException if a QR code cannot be found\r\n   * @throws FormatException if a QR code cannot be decoded\r\n   * @throws ChecksumException if error correction fails\r\n   */\n  /*@Override*/\n  // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {\n  //   return this.decode(image, null)\n  // }\n  /*@Override*/\n  QRCodeReader.prototype.decode = function (image, hints) {\n    var decoderResult;\n    var points;\n    if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType.PURE_BARCODE)) {\n      var bits = QRCodeReader.extractPureBits(image.getBlackMatrix());\n      decoderResult = this.decoder.decodeBitMatrix(bits, hints);\n      points = QRCodeReader.NO_POINTS;\n    } else {\n      var detectorResult = new Detector(image.getBlackMatrix()).detect(hints);\n      decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);\n      points = detectorResult.getPoints();\n    }\n    // If the code was mirrored: swap the bottom-left and the top-right points.\n    if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {\n      decoderResult.getOther().applyMirroredCorrection(points);\n    }\n    var result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat.QR_CODE, undefined);\n    var byteSegments = decoderResult.getByteSegments();\n    if (byteSegments !== null) {\n      result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);\n    }\n    var ecLevel = decoderResult.getECLevel();\n    if (ecLevel !== null) {\n      result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);\n    }\n    if (decoderResult.hasStructuredAppend()) {\n      result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());\n      result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());\n    }\n    return result;\n  };\n  /*@Override*/\n  QRCodeReader.prototype.reset = function () {\n    // do nothing\n  };\n  /**\r\n   * This method detects a code in a \"pure\" image -- that is, pure monochrome image\r\n   * which contains only an unrotated, unskewed, image of a code, with some white border\r\n   * around it. This is a specialized method that works exceptionally fast in this special\r\n   * case.\r\n   *\r\n   * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)\r\n   */\n  QRCodeReader.extractPureBits = function (image) {\n    var leftTopBlack = image.getTopLeftOnBit();\n    var rightBottomBlack = image.getBottomRightOnBit();\n    if (leftTopBlack === null || rightBottomBlack === null) {\n      throw new NotFoundException();\n    }\n    var moduleSize = this.moduleSize(leftTopBlack, image);\n    var top = leftTopBlack[1];\n    var bottom = rightBottomBlack[1];\n    var left = leftTopBlack[0];\n    var right = rightBottomBlack[0];\n    // Sanity check!\n    if (left >= right || top >= bottom) {\n      throw new NotFoundException();\n    }\n    if (bottom - top !== right - left) {\n      // Special case, where bottom-right module wasn't black so we found something else in the last row\n      // Assume it's a square, so use height as the width\n      right = left + (bottom - top);\n      if (right >= image.getWidth()) {\n        // Abort if that would not make sense -- off image\n        throw new NotFoundException();\n      }\n    }\n    var matrixWidth = Math.round((right - left + 1) / moduleSize);\n    var matrixHeight = Math.round((bottom - top + 1) / moduleSize);\n    if (matrixWidth <= 0 || matrixHeight <= 0) {\n      throw new NotFoundException();\n    }\n    if (matrixHeight !== matrixWidth) {\n      // Only possibly decode square regions\n      throw new NotFoundException();\n    }\n    // Push in the \"border\" by half the module width so that we start\n    // sampling in the middle of the module. Just in case the image is a\n    // little off, this will help recover.\n    var nudge = /*(int) */Math.floor(moduleSize / 2.0);\n    top += nudge;\n    left += nudge;\n    // But careful that this does not sample off the edge\n    // \"right\" is the farthest-right valid pixel location -- right+1 is not necessarily\n    // This is positive by how much the inner x loop below would be too large\n    var nudgedTooFarRight = left + /*(int) */Math.floor((matrixWidth - 1) * moduleSize) - right;\n    if (nudgedTooFarRight > 0) {\n      if (nudgedTooFarRight > nudge) {\n        // Neither way fits; abort\n        throw new NotFoundException();\n      }\n      left -= nudgedTooFarRight;\n    }\n    // See logic above\n    var nudgedTooFarDown = top + /*(int) */Math.floor((matrixHeight - 1) * moduleSize) - bottom;\n    if (nudgedTooFarDown > 0) {\n      if (nudgedTooFarDown > nudge) {\n        // Neither way fits; abort\n        throw new NotFoundException();\n      }\n      top -= nudgedTooFarDown;\n    }\n    // Now just read off the bits\n    var bits = new BitMatrix(matrixWidth, matrixHeight);\n    for (var y = 0; y < matrixHeight; y++) {\n      var iOffset = top + /*(int) */Math.floor(y * moduleSize);\n      for (var x = 0; x < matrixWidth; x++) {\n        if (image.get(left + /*(int) */Math.floor(x * moduleSize), iOffset)) {\n          bits.set(x, y);\n        }\n      }\n    }\n    return bits;\n  };\n  QRCodeReader.moduleSize = function (leftTopBlack, image) {\n    var height = image.getHeight();\n    var width = image.getWidth();\n    var x = leftTopBlack[0];\n    var y = leftTopBlack[1];\n    var inBlack = true;\n    var transitions = 0;\n    while (x < width && y < height) {\n      if (inBlack !== image.get(x, y)) {\n        if (++transitions === 5) {\n          break;\n        }\n        inBlack = !inBlack;\n      }\n      x++;\n      y++;\n    }\n    if (x === width || y === height) {\n      throw new NotFoundException();\n    }\n    return (x - leftTopBlack[0]) / 7.0;\n  };\n  QRCodeReader.NO_POINTS = new Array();\n  return QRCodeReader;\n}();\nexport default QRCodeReader;","map":{"version":3,"names":["BarcodeFormat","BitMatrix","DecodeHintType","NotFoundException","Result","ResultMetadataType","Decoder","QRCodeDecoderMetaData","Detector","QRCodeReader","decoder","prototype","getDecoder","decode","image","hints","decoderResult","points","undefined","get","PURE_BARCODE","bits","extractPureBits","getBlackMatrix","decodeBitMatrix","NO_POINTS","detectorResult","detect","getBits","getPoints","getOther","applyMirroredCorrection","result","getText","getRawBytes","QR_CODE","byteSegments","getByteSegments","putMetadata","BYTE_SEGMENTS","ecLevel","getECLevel","ERROR_CORRECTION_LEVEL","hasStructuredAppend","STRUCTURED_APPEND_SEQUENCE","getStructuredAppendSequenceNumber","STRUCTURED_APPEND_PARITY","getStructuredAppendParity","reset","leftTopBlack","getTopLeftOnBit","rightBottomBlack","getBottomRightOnBit","moduleSize","top","bottom","left","right","getWidth","matrixWidth","Math","round","matrixHeight","nudge","floor","nudgedTooFarRight","nudgedTooFarDown","y","iOffset","x","set","height","getHeight","width","inBlack","transitions","Array"],"sources":["D:/Git/GME-Angular2/node_modules/@zxing/library/esm/core/qrcode/QRCodeReader.js"],"sourcesContent":["/*\r\n * Copyright 2007 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/*namespace com.google.zxing.qrcode {*/\r\nimport BarcodeFormat from '../BarcodeFormat';\r\nimport BitMatrix from '../common/BitMatrix';\r\nimport DecodeHintType from '../DecodeHintType';\r\nimport NotFoundException from '../NotFoundException';\r\nimport Result from '../Result';\r\nimport ResultMetadataType from '../ResultMetadataType';\r\n// import DetectorResult from '../common/DetectorResult';\r\nimport Decoder from './decoder/Decoder';\r\nimport QRCodeDecoderMetaData from './decoder/QRCodeDecoderMetaData';\r\nimport Detector from './detector/Detector';\r\n/*import java.util.List;*/\r\n/*import java.util.Map;*/\r\n/**\r\n * This implementation can detect and decode QR Codes in an image.\r\n *\r\n * @author Sean Owen\r\n */\r\nvar QRCodeReader = /** @class */ (function () {\r\n    function QRCodeReader() {\r\n        this.decoder = new Decoder();\r\n    }\r\n    QRCodeReader.prototype.getDecoder = function () {\r\n        return this.decoder;\r\n    };\r\n    /**\r\n     * Locates and decodes a QR code in an image.\r\n     *\r\n     * @return a representing: string the content encoded by the QR code\r\n     * @throws NotFoundException if a QR code cannot be found\r\n     * @throws FormatException if a QR code cannot be decoded\r\n     * @throws ChecksumException if error correction fails\r\n     */\r\n    /*@Override*/\r\n    // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {\r\n    //   return this.decode(image, null)\r\n    // }\r\n    /*@Override*/\r\n    QRCodeReader.prototype.decode = function (image, hints) {\r\n        var decoderResult;\r\n        var points;\r\n        if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType.PURE_BARCODE)) {\r\n            var bits = QRCodeReader.extractPureBits(image.getBlackMatrix());\r\n            decoderResult = this.decoder.decodeBitMatrix(bits, hints);\r\n            points = QRCodeReader.NO_POINTS;\r\n        }\r\n        else {\r\n            var detectorResult = new Detector(image.getBlackMatrix()).detect(hints);\r\n            decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);\r\n            points = detectorResult.getPoints();\r\n        }\r\n        // If the code was mirrored: swap the bottom-left and the top-right points.\r\n        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {\r\n            decoderResult.getOther().applyMirroredCorrection(points);\r\n        }\r\n        var result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat.QR_CODE, undefined);\r\n        var byteSegments = decoderResult.getByteSegments();\r\n        if (byteSegments !== null) {\r\n            result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);\r\n        }\r\n        var ecLevel = decoderResult.getECLevel();\r\n        if (ecLevel !== null) {\r\n            result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);\r\n        }\r\n        if (decoderResult.hasStructuredAppend()) {\r\n            result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());\r\n            result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());\r\n        }\r\n        return result;\r\n    };\r\n    /*@Override*/\r\n    QRCodeReader.prototype.reset = function () {\r\n        // do nothing\r\n    };\r\n    /**\r\n     * This method detects a code in a \"pure\" image -- that is, pure monochrome image\r\n     * which contains only an unrotated, unskewed, image of a code, with some white border\r\n     * around it. This is a specialized method that works exceptionally fast in this special\r\n     * case.\r\n     *\r\n     * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)\r\n     */\r\n    QRCodeReader.extractPureBits = function (image) {\r\n        var leftTopBlack = image.getTopLeftOnBit();\r\n        var rightBottomBlack = image.getBottomRightOnBit();\r\n        if (leftTopBlack === null || rightBottomBlack === null) {\r\n            throw new NotFoundException();\r\n        }\r\n        var moduleSize = this.moduleSize(leftTopBlack, image);\r\n        var top = leftTopBlack[1];\r\n        var bottom = rightBottomBlack[1];\r\n        var left = leftTopBlack[0];\r\n        var right = rightBottomBlack[0];\r\n        // Sanity check!\r\n        if (left >= right || top >= bottom) {\r\n            throw new NotFoundException();\r\n        }\r\n        if (bottom - top !== right - left) {\r\n            // Special case, where bottom-right module wasn't black so we found something else in the last row\r\n            // Assume it's a square, so use height as the width\r\n            right = left + (bottom - top);\r\n            if (right >= image.getWidth()) {\r\n                // Abort if that would not make sense -- off image\r\n                throw new NotFoundException();\r\n            }\r\n        }\r\n        var matrixWidth = Math.round((right - left + 1) / moduleSize);\r\n        var matrixHeight = Math.round((bottom - top + 1) / moduleSize);\r\n        if (matrixWidth <= 0 || matrixHeight <= 0) {\r\n            throw new NotFoundException();\r\n        }\r\n        if (matrixHeight !== matrixWidth) {\r\n            // Only possibly decode square regions\r\n            throw new NotFoundException();\r\n        }\r\n        // Push in the \"border\" by half the module width so that we start\r\n        // sampling in the middle of the module. Just in case the image is a\r\n        // little off, this will help recover.\r\n        var nudge = /*(int) */ Math.floor(moduleSize / 2.0);\r\n        top += nudge;\r\n        left += nudge;\r\n        // But careful that this does not sample off the edge\r\n        // \"right\" is the farthest-right valid pixel location -- right+1 is not necessarily\r\n        // This is positive by how much the inner x loop below would be too large\r\n        var nudgedTooFarRight = left + /*(int) */ Math.floor((matrixWidth - 1) * moduleSize) - right;\r\n        if (nudgedTooFarRight > 0) {\r\n            if (nudgedTooFarRight > nudge) {\r\n                // Neither way fits; abort\r\n                throw new NotFoundException();\r\n            }\r\n            left -= nudgedTooFarRight;\r\n        }\r\n        // See logic above\r\n        var nudgedTooFarDown = top + /*(int) */ Math.floor((matrixHeight - 1) * moduleSize) - bottom;\r\n        if (nudgedTooFarDown > 0) {\r\n            if (nudgedTooFarDown > nudge) {\r\n                // Neither way fits; abort\r\n                throw new NotFoundException();\r\n            }\r\n            top -= nudgedTooFarDown;\r\n        }\r\n        // Now just read off the bits\r\n        var bits = new BitMatrix(matrixWidth, matrixHeight);\r\n        for (var y = 0; y < matrixHeight; y++) {\r\n            var iOffset = top + /*(int) */ Math.floor(y * moduleSize);\r\n            for (var x = 0; x < matrixWidth; x++) {\r\n                if (image.get(left + /*(int) */ Math.floor(x * moduleSize), iOffset)) {\r\n                    bits.set(x, y);\r\n                }\r\n            }\r\n        }\r\n        return bits;\r\n    };\r\n    QRCodeReader.moduleSize = function (leftTopBlack, image) {\r\n        var height = image.getHeight();\r\n        var width = image.getWidth();\r\n        var x = leftTopBlack[0];\r\n        var y = leftTopBlack[1];\r\n        var inBlack = true;\r\n        var transitions = 0;\r\n        while (x < width && y < height) {\r\n            if (inBlack !== image.get(x, y)) {\r\n                if (++transitions === 5) {\r\n                    break;\r\n                }\r\n                inBlack = !inBlack;\r\n            }\r\n            x++;\r\n            y++;\r\n        }\r\n        if (x === width || y === height) {\r\n            throw new NotFoundException();\r\n        }\r\n        return (x - leftTopBlack[0]) / 7.0;\r\n    };\r\n    QRCodeReader.NO_POINTS = new Array();\r\n    return QRCodeReader;\r\n}());\r\nexport default QRCodeReader;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}