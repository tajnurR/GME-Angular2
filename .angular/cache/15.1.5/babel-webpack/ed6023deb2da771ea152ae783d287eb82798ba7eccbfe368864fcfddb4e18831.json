{"ast":null,"code":"/*\r\n * Copyright 2008 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport BarcodeFormat from '../BarcodeFormat';\nimport DecodeHintType from '../DecodeHintType';\nimport Result from '../Result';\nimport ResultMetadataType from '../ResultMetadataType';\nimport ResultPoint from '../ResultPoint';\nimport UPCEANExtensionSupport from './UPCEANExtensionSupport';\nimport AbstractUPCEANReader from './AbstractUPCEANReader';\nimport NotFoundException from '../NotFoundException';\nimport FormatException from '../FormatException';\nimport ChecksumException from '../ChecksumException';\n/**\r\n * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\r\n * of one-dimensional barcodes.</p>\r\n *\r\n * @author dswitkin@google.com (Daniel Switkin)\r\n * @author Sean Owen\r\n * @author alasdair@google.com (Alasdair Mackintosh)\r\n */\nvar UPCEANReader = /** @class */function (_super) {\n  __extends(UPCEANReader, _super);\n  function UPCEANReader() {\n    var _this = _super.call(this) || this;\n    _this.decodeRowStringBuffer = '';\n    UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map(function (arr) {\n      return Int32Array.from(arr);\n    });\n    for (var i = 10; i < 20; i++) {\n      var widths = UPCEANReader.L_PATTERNS[i - 10];\n      var reversedWidths = new Int32Array(widths.length);\n      for (var j = 0; j < widths.length; j++) {\n        reversedWidths[j] = widths[widths.length - j - 1];\n      }\n      UPCEANReader.L_AND_G_PATTERNS[i] = reversedWidths;\n    }\n    return _this;\n  }\n  UPCEANReader.prototype.decodeRow = function (rowNumber, row, hints) {\n    var startGuardRange = UPCEANReader.findStartGuardPattern(row);\n    var resultPointCallback = hints == null ? null : hints.get(DecodeHintType.NEED_RESULT_POINT_CALLBACK);\n    if (resultPointCallback != null) {\n      var resultPoint_1 = new ResultPoint((startGuardRange[0] + startGuardRange[1]) / 2.0, rowNumber);\n      resultPointCallback.foundPossibleResultPoint(resultPoint_1);\n    }\n    var budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);\n    var endStart = budello.rowOffset;\n    var result = budello.resultString;\n    if (resultPointCallback != null) {\n      var resultPoint_2 = new ResultPoint(endStart, rowNumber);\n      resultPointCallback.foundPossibleResultPoint(resultPoint_2);\n    }\n    var endRange = UPCEANReader.decodeEnd(row, endStart);\n    if (resultPointCallback != null) {\n      var resultPoint_3 = new ResultPoint((endRange[0] + endRange[1]) / 2.0, rowNumber);\n      resultPointCallback.foundPossibleResultPoint(resultPoint_3);\n    }\n    // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The\n    // spec might want more whitespace, but in practice this is the maximum we can count on.\n    var end = endRange[1];\n    var quietEnd = end + (end - endRange[0]);\n    if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {\n      throw new NotFoundException();\n    }\n    var resultString = result.toString();\n    // UPC/EAN should never be less than 8 chars anyway\n    if (resultString.length < 8) {\n      throw new FormatException();\n    }\n    if (!UPCEANReader.checkChecksum(resultString)) {\n      throw new ChecksumException();\n    }\n    var left = (startGuardRange[1] + startGuardRange[0]) / 2.0;\n    var right = (endRange[1] + endRange[0]) / 2.0;\n    var format = this.getBarcodeFormat();\n    var resultPoint = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];\n    var decodeResult = new Result(resultString, null, 0, resultPoint, format, new Date().getTime());\n    var extensionLength = 0;\n    try {\n      var extensionResult = UPCEANExtensionSupport.decodeRow(rowNumber, row, endRange[1]);\n      decodeResult.putMetadata(ResultMetadataType.UPC_EAN_EXTENSION, extensionResult.getText());\n      decodeResult.putAllMetadata(extensionResult.getResultMetadata());\n      decodeResult.addResultPoints(extensionResult.getResultPoints());\n      extensionLength = extensionResult.getText().length;\n    } catch (err) {}\n    var allowedExtensions = hints == null ? null : hints.get(DecodeHintType.ALLOWED_EAN_EXTENSIONS);\n    if (allowedExtensions != null) {\n      var valid = false;\n      for (var length_1 in allowedExtensions) {\n        if (extensionLength.toString() === length_1) {\n          // check me\n          valid = true;\n          break;\n        }\n      }\n      if (!valid) {\n        throw new NotFoundException();\n      }\n    }\n    if (format === BarcodeFormat.EAN_13 || format === BarcodeFormat.UPC_A) {\n      // let countryID = eanManSupport.lookupContryIdentifier(resultString); todo\n      // if (countryID != null) {\n      //     decodeResult.putMetadata(ResultMetadataType.POSSIBLE_COUNTRY, countryID);\n      // }\n    }\n    return decodeResult;\n  };\n  UPCEANReader.checkChecksum = function (s) {\n    return UPCEANReader.checkStandardUPCEANChecksum(s);\n  };\n  UPCEANReader.checkStandardUPCEANChecksum = function (s) {\n    var length = s.length;\n    if (length === 0) return false;\n    var check = parseInt(s.charAt(length - 1), 10);\n    return UPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n  };\n  UPCEANReader.getStandardUPCEANChecksum = function (s) {\n    var length = s.length;\n    var sum = 0;\n    for (var i = length - 1; i >= 0; i -= 2) {\n      var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n      if (digit < 0 || digit > 9) {\n        throw new FormatException();\n      }\n      sum += digit;\n    }\n    sum *= 3;\n    for (var i = length - 2; i >= 0; i -= 2) {\n      var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n      if (digit < 0 || digit > 9) {\n        throw new FormatException();\n      }\n      sum += digit;\n    }\n    return (1000 - sum) % 10;\n  };\n  UPCEANReader.decodeEnd = function (row, endStart) {\n    return UPCEANReader.findGuardPattern(row, endStart, false, UPCEANReader.START_END_PATTERN, new Int32Array(UPCEANReader.START_END_PATTERN.length).fill(0));\n  };\n  return UPCEANReader;\n}(AbstractUPCEANReader);\nexport default UPCEANReader;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}