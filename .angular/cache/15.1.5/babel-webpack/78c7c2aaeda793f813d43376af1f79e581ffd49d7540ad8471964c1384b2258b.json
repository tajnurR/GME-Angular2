{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport InvertedLuminanceSource from '../core/InvertedLuminanceSource';\nimport LuminanceSource from '../core/LuminanceSource';\nimport IllegalArgumentException from '../core/IllegalArgumentException';\n/**\r\n * @deprecated Moving to @zxing/browser\r\n */\nvar HTMLCanvasElementLuminanceSource = /** @class */function (_super) {\n  __extends(HTMLCanvasElementLuminanceSource, _super);\n  function HTMLCanvasElementLuminanceSource(canvas) {\n    var _this = _super.call(this, canvas.width, canvas.height) || this;\n    _this.canvas = canvas;\n    _this.tempCanvasElement = null;\n    _this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);\n    return _this;\n  }\n  HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData = function (canvas) {\n    var imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);\n    return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);\n  };\n  HTMLCanvasElementLuminanceSource.toGrayscaleBuffer = function (imageBuffer, width, height) {\n    var grayscaleBuffer = new Uint8ClampedArray(width * height);\n    for (var i = 0, j = 0, length_1 = imageBuffer.length; i < length_1; i += 4, j++) {\n      var gray = void 0;\n      var alpha = imageBuffer[i + 3];\n      // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent\n      // black (0 alpha, and then 0 RGB). They are often used, of course as the \"white\" area in a\n      // barcode image. Force any such pixel to be white:\n      if (alpha === 0) {\n        gray = 0xFF;\n      } else {\n        var pixelR = imageBuffer[i];\n        var pixelG = imageBuffer[i + 1];\n        var pixelB = imageBuffer[i + 2];\n        // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),\n        // (306*R) >> 10 is approximately equal to R*0.299, and so on.\n        // 0x200 >> 10 is 0.5, it implements rounding.\n        gray = 306 * pixelR + 601 * pixelG + 117 * pixelB + 0x200 >> 10;\n      }\n      grayscaleBuffer[j] = gray;\n    }\n    return grayscaleBuffer;\n  };\n  HTMLCanvasElementLuminanceSource.prototype.getRow = function (y /*int*/, row) {\n    if (y < 0 || y >= this.getHeight()) {\n      throw new IllegalArgumentException('Requested row is outside the image: ' + y);\n    }\n    var width = this.getWidth();\n    var start = y * width;\n    if (row === null) {\n      row = this.buffer.slice(start, start + width);\n    } else {\n      if (row.length < width) {\n        row = new Uint8ClampedArray(width);\n      }\n      // The underlying raster of image consists of bytes with the luminance values\n      // TODO: can avoid set/slice?\n      row.set(this.buffer.slice(start, start + width));\n    }\n    return row;\n  };\n  HTMLCanvasElementLuminanceSource.prototype.getMatrix = function () {\n    return this.buffer;\n  };\n  HTMLCanvasElementLuminanceSource.prototype.isCropSupported = function () {\n    return true;\n  };\n  HTMLCanvasElementLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n    _super.prototype.crop.call(this, left, top, width, height);\n    return this;\n  };\n  /**\r\n   * This is always true, since the image is a gray-scale image.\r\n   *\r\n   * @return true\r\n   */\n  HTMLCanvasElementLuminanceSource.prototype.isRotateSupported = function () {\n    return true;\n  };\n  HTMLCanvasElementLuminanceSource.prototype.rotateCounterClockwise = function () {\n    this.rotate(-90);\n    return this;\n  };\n  HTMLCanvasElementLuminanceSource.prototype.rotateCounterClockwise45 = function () {\n    this.rotate(-45);\n    return this;\n  };\n  HTMLCanvasElementLuminanceSource.prototype.getTempCanvasElement = function () {\n    if (null === this.tempCanvasElement) {\n      var tempCanvasElement = this.canvas.ownerDocument.createElement('canvas');\n      tempCanvasElement.width = this.canvas.width;\n      tempCanvasElement.height = this.canvas.height;\n      this.tempCanvasElement = tempCanvasElement;\n    }\n    return this.tempCanvasElement;\n  };\n  HTMLCanvasElementLuminanceSource.prototype.rotate = function (angle) {\n    var tempCanvasElement = this.getTempCanvasElement();\n    var tempContext = tempCanvasElement.getContext('2d');\n    var angleRadians = angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS;\n    // Calculate and set new dimensions for temp canvas\n    var width = this.canvas.width;\n    var height = this.canvas.height;\n    var newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);\n    var newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);\n    tempCanvasElement.width = newWidth;\n    tempCanvasElement.height = newHeight;\n    // Draw at center of temp canvas to prevent clipping of image data\n    tempContext.translate(newWidth / 2, newHeight / 2);\n    tempContext.rotate(angleRadians);\n    tempContext.drawImage(this.canvas, width / -2, height / -2);\n    this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);\n    return this;\n  };\n  HTMLCanvasElementLuminanceSource.prototype.invert = function () {\n    return new InvertedLuminanceSource(this);\n  };\n  HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;\n  return HTMLCanvasElementLuminanceSource;\n}(LuminanceSource);\nexport { HTMLCanvasElementLuminanceSource };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}