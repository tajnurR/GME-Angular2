{"ast":null,"code":"/*\r\n * Copyright 2013 ZXing authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n// package com.google.zxing.pdf417.decoder;\n// import java.util.Formatter;\nimport Formatter from '../../util/Formatter';\nimport BoundingBox from './BoundingBox';\n/**\r\n * @author Guenther Grau\r\n */\nvar DetectionResultColumn = /** @class */function () {\n  function DetectionResultColumn(boundingBox) {\n    this.boundingBox = new BoundingBox(boundingBox);\n    // this.codewords = new Codeword[boundingBox.getMaxY() - boundingBox.getMinY() + 1];\n    this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);\n  }\n  /*final*/\n  DetectionResultColumn.prototype.getCodewordNearby = function (imageRow) {\n    var codeword = this.getCodeword(imageRow);\n    if (codeword != null) {\n      return codeword;\n    }\n    for (var i = 1; i < DetectionResultColumn.MAX_NEARBY_DISTANCE; i++) {\n      var nearImageRow = this.imageRowToCodewordIndex(imageRow) - i;\n      if (nearImageRow >= 0) {\n        codeword = this.codewords[nearImageRow];\n        if (codeword != null) {\n          return codeword;\n        }\n      }\n      nearImageRow = this.imageRowToCodewordIndex(imageRow) + i;\n      if (nearImageRow < this.codewords.length) {\n        codeword = this.codewords[nearImageRow];\n        if (codeword != null) {\n          return codeword;\n        }\n      }\n    }\n    return null;\n  };\n  /*final int*/\n  DetectionResultColumn.prototype.imageRowToCodewordIndex = function (imageRow) {\n    return imageRow - this.boundingBox.getMinY();\n  };\n  /*final void*/\n  DetectionResultColumn.prototype.setCodeword = function (imageRow, codeword) {\n    this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;\n  };\n  /*final*/\n  DetectionResultColumn.prototype.getCodeword = function (imageRow) {\n    return this.codewords[this.imageRowToCodewordIndex(imageRow)];\n  };\n  /*final*/\n  DetectionResultColumn.prototype.getBoundingBox = function () {\n    return this.boundingBox;\n  };\n  /*final*/\n  DetectionResultColumn.prototype.getCodewords = function () {\n    return this.codewords;\n  };\n  // @Override\n  DetectionResultColumn.prototype.toString = function () {\n    var e_1, _a;\n    var formatter = new Formatter();\n    var row = 0;\n    try {\n      for (var _b = __values(this.codewords), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var codeword = _c.value;\n        if (codeword == null) {\n          formatter.format('%3d:    |   %n', row++);\n          continue;\n        }\n        formatter.format('%3d: %3d|%3d%n', row++, codeword.getRowNumber(), codeword.getValue());\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return formatter.toString();\n  };\n  DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;\n  return DetectionResultColumn;\n}();\nexport default DetectionResultColumn;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}