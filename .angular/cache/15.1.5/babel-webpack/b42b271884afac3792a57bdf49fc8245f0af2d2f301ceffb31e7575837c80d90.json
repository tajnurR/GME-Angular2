{"ast":null,"code":"/*\r\n * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.\r\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n *\r\n * This code is free software; you can redistribute it and/or modify it\r\n * under the terms of the GNU General Public License version 2 only, as\r\n * published by the Free Software Foundation.  Oracle designates this\r\n * particular file as subject to the \"Classpath\" exception as provided\r\n * by Oracle in the LICENSE file that accompanied this code.\r\n *\r\n * This code is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n * version 2 for more details (a copy is included in the LICENSE file that\r\n * accompanied this code).\r\n *\r\n * You should have received a copy of the GNU General Public License version\r\n * 2 along with this work; if not, write to the Free Software Foundation,\r\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n *\r\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n * or visit www.oracle.com if you need additional information or have any\r\n * questions.\r\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n// package java.io;\n// import java.util.Arrays;\nimport Arrays from './Arrays';\nimport OutputStream from './OutputStream';\nimport Integer from './Integer';\nimport IllegalArgumentException from '../IllegalArgumentException';\nimport OutOfMemoryError from '../OutOfMemoryError';\nimport System from './System';\nimport IndexOutOfBoundsException from '../IndexOutOfBoundsException';\n/**\r\n * This class implements an output stream in which the data is\r\n * written into a byte array. The buffer automatically grows as data\r\n * is written to it.\r\n * The data can be retrieved using <code>toByteArray()</code> and\r\n * <code>toString()</code>.\r\n * <p>\r\n * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\r\n * this class can be called after the stream has been closed without\r\n * generating an <tt>IOException</tt>.\r\n *\r\n * @author  Arthur van Hoff\r\n * @since   JDK1.0\r\n */\nvar ByteArrayOutputStream = /** @class */function (_super) {\n  __extends(ByteArrayOutputStream, _super);\n  /**\r\n   * Creates a new byte array output stream. The buffer capacity is\r\n   * initially 32 bytes, though its size increases if necessary.\r\n   */\n  // public constructor() {\n  //     this(32);\n  // }\n  /**\r\n   * Creates a new byte array output stream, with a buffer capacity of\r\n   * the specified size, in bytes.\r\n   *\r\n   * @param   size   the initial size.\r\n   * @exception  IllegalArgumentException if size is negative.\r\n   */\n  function ByteArrayOutputStream(size) {\n    if (size === void 0) {\n      size = 32;\n    }\n    var _this = _super.call(this) || this;\n    /**\r\n     * The number of valid bytes in the buffer.\r\n     */\n    _this.count = 0;\n    if (size < 0) {\n      throw new IllegalArgumentException('Negative initial size: ' + size);\n    }\n    _this.buf = new Uint8Array(size);\n    return _this;\n  }\n  /**\r\n   * Increases the capacity if necessary to ensure that it can hold\r\n   * at least the number of elements specified by the minimum\r\n   * capacity argument.\r\n   *\r\n   * @param minCapacity the desired minimum capacity\r\n   * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is\r\n   * interpreted as a request for the unsatisfiably large capacity\r\n   * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.\r\n   */\n  ByteArrayOutputStream.prototype.ensureCapacity = function (minCapacity) {\n    // overflow-conscious code\n    if (minCapacity - this.buf.length > 0) this.grow(minCapacity);\n  };\n  /**\r\n   * Increases the capacity to ensure that it can hold at least the\r\n   * number of elements specified by the minimum capacity argument.\r\n   *\r\n   * @param minCapacity the desired minimum capacity\r\n   */\n  ByteArrayOutputStream.prototype.grow = function (minCapacity) {\n    // overflow-conscious code\n    var oldCapacity = this.buf.length;\n    var newCapacity = oldCapacity << 1;\n    if (newCapacity - minCapacity < 0) newCapacity = minCapacity;\n    if (newCapacity < 0) {\n      if (minCapacity < 0)\n        // overflow\n        throw new OutOfMemoryError();\n      newCapacity = Integer.MAX_VALUE;\n    }\n    this.buf = Arrays.copyOfUint8Array(this.buf, newCapacity);\n  };\n  /**\r\n   * Writes the specified byte to this byte array output stream.\r\n   *\r\n   * @param   b   the byte to be written.\r\n   */\n  ByteArrayOutputStream.prototype.write = function (b) {\n    this.ensureCapacity(this.count + 1);\n    this.buf[this.count] = /*(byte)*/b;\n    this.count += 1;\n  };\n  /**\r\n   * Writes <code>len</code> bytes from the specified byte array\r\n   * starting at offset <code>off</code> to this byte array output stream.\r\n   *\r\n   * @param   b     the data.\r\n   * @param   off   the start offset in the data.\r\n   * @param   len   the number of bytes to write.\r\n   */\n  ByteArrayOutputStream.prototype.writeBytesOffset = function (b, off, len) {\n    if (off < 0 || off > b.length || len < 0 || off + len - b.length > 0) {\n      throw new IndexOutOfBoundsException();\n    }\n    this.ensureCapacity(this.count + len);\n    System.arraycopy(b, off, this.buf, this.count, len);\n    this.count += len;\n  };\n  /**\r\n   * Writes the complete contents of this byte array output stream to\r\n   * the specified output stream argument, as if by calling the output\r\n   * stream's write method using <code>out.write(buf, 0, count)</code>.\r\n   *\r\n   * @param      out   the output stream to which to write the data.\r\n   * @exception  IOException  if an I/O error occurs.\r\n   */\n  ByteArrayOutputStream.prototype.writeTo = function (out) {\n    out.writeBytesOffset(this.buf, 0, this.count);\n  };\n  /**\r\n   * Resets the <code>count</code> field of this byte array output\r\n   * stream to zero, so that all currently accumulated output in the\r\n   * output stream is discarded. The output stream can be used again,\r\n   * reusing the already allocated buffer space.\r\n   *\r\n   * @see     java.io.ByteArrayInputStream#count\r\n   */\n  ByteArrayOutputStream.prototype.reset = function () {\n    this.count = 0;\n  };\n  /**\r\n   * Creates a newly allocated byte array. Its size is the current\r\n   * size of this output stream and the valid contents of the buffer\r\n   * have been copied into it.\r\n   *\r\n   * @return  the current contents of this output stream, as a byte array.\r\n   * @see     java.io.ByteArrayOutputStream#size()\r\n   */\n  ByteArrayOutputStream.prototype.toByteArray = function () {\n    return Arrays.copyOfUint8Array(this.buf, this.count);\n  };\n  /**\r\n   * Returns the current size of the buffer.\r\n   *\r\n   * @return  the value of the <code>count</code> field, which is the number\r\n   *          of valid bytes in this output stream.\r\n   * @see     java.io.ByteArrayOutputStream#count\r\n   */\n  ByteArrayOutputStream.prototype.size = function () {\n    return this.count;\n  };\n  ByteArrayOutputStream.prototype.toString = function (param) {\n    if (!param) {\n      return this.toString_void();\n    }\n    if (typeof param === 'string') {\n      return this.toString_string(param);\n    }\n    return this.toString_number(param);\n  };\n  /**\r\n   * Converts the buffer's contents into a string decoding bytes using the\r\n   * platform's default character set. The length of the new <tt>String</tt>\r\n   * is a function of the character set, and hence may not be equal to the\r\n   * size of the buffer.\r\n   *\r\n   * <p> This method always replaces malformed-input and unmappable-character\r\n   * sequences with the default replacement string for the platform's\r\n   * default character set. The {@linkplain java.nio.charset.CharsetDecoder}\r\n   * class should be used when more control over the decoding process is\r\n   * required.\r\n   *\r\n   * @return String decoded from the buffer's contents.\r\n   * @since  JDK1.1\r\n   */\n  ByteArrayOutputStream.prototype.toString_void = function () {\n    return new String(this.buf /*, 0, this.count*/).toString();\n  };\n  /**\r\n   * Converts the buffer's contents into a string by decoding the bytes using\r\n   * the specified {@link java.nio.charset.Charset charsetName}. The length of\r\n   * the new <tt>String</tt> is a function of the charset, and hence may not be\r\n   * equal to the length of the byte array.\r\n   *\r\n   * <p> This method always replaces malformed-input and unmappable-character\r\n   * sequences with this charset's default replacement string. The {@link\r\n   * java.nio.charset.CharsetDecoder} class should be used when more control\r\n   * over the decoding process is required.\r\n   *\r\n   * @param  charsetName  the name of a supported\r\n   *              {@linkplain java.nio.charset.Charset </code>charset<code>}\r\n   * @return String decoded from the buffer's contents.\r\n   * @exception  UnsupportedEncodingException\r\n   *             If the named charset is not supported\r\n   * @since   JDK1.1\r\n   */\n  ByteArrayOutputStream.prototype.toString_string = function (charsetName) {\n    return new String(this.buf /*, 0, this.count, charsetName*/).toString();\n  };\n  /**\r\n   * Creates a newly allocated string. Its size is the current size of\r\n   * the output stream and the valid contents of the buffer have been\r\n   * copied into it. Each character <i>c</i> in the resulting string is\r\n   * constructed from the corresponding element <i>b</i> in the byte\r\n   * array such that:\r\n   * <blockquote><pre>\r\n   *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))\r\n   * </pre></blockquote>\r\n   *\r\n   * @deprecated This method does not properly convert bytes into characters.\r\n   * As of JDK&nbsp;1.1, the preferred way to do this is via the\r\n   * <code>toString(String enc)</code> method, which takes an encoding-name\r\n   * argument, or the <code>toString()</code> method, which uses the\r\n   * platform's default character encoding.\r\n   *\r\n   * @param      hibyte    the high byte of each resulting Unicode character.\r\n   * @return     the current contents of the output stream, as a string.\r\n   * @see        java.io.ByteArrayOutputStream#size()\r\n   * @see        java.io.ByteArrayOutputStream#toString(String)\r\n   * @see        java.io.ByteArrayOutputStream#toString()\r\n   */\n  // @Deprecated\n  ByteArrayOutputStream.prototype.toString_number = function (hibyte) {\n    return new String(this.buf /*, hibyte, 0, this.count*/).toString();\n  };\n  /**\r\n   * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\r\n   * this class can be called after the stream has been closed without\r\n   * generating an <tt>IOException</tt>.\r\n   * <p>\r\n   *\r\n   * @throws IOException\r\n   */\n  ByteArrayOutputStream.prototype.close = function () {};\n  return ByteArrayOutputStream;\n}(OutputStream);\nexport default ByteArrayOutputStream;","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Arrays","OutputStream","Integer","IllegalArgumentException","OutOfMemoryError","System","IndexOutOfBoundsException","ByteArrayOutputStream","_super","size","_this","call","count","buf","Uint8Array","ensureCapacity","minCapacity","length","grow","oldCapacity","newCapacity","MAX_VALUE","copyOfUint8Array","write","writeBytesOffset","off","len","arraycopy","writeTo","out","reset","toByteArray","toString","param","toString_void","toString_string","toString_number","String","charsetName","hibyte","close"],"sources":["E:/angular/GME-Angular2/node_modules/@zxing/library/esm/core/util/ByteArrayOutputStream.js"],"sourcesContent":["/*\r\n * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.\r\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n *\r\n * This code is free software; you can redistribute it and/or modify it\r\n * under the terms of the GNU General Public License version 2 only, as\r\n * published by the Free Software Foundation.  Oracle designates this\r\n * particular file as subject to the \"Classpath\" exception as provided\r\n * by Oracle in the LICENSE file that accompanied this code.\r\n *\r\n * This code is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n * version 2 for more details (a copy is included in the LICENSE file that\r\n * accompanied this code).\r\n *\r\n * You should have received a copy of the GNU General Public License version\r\n * 2 along with this work; if not, write to the Free Software Foundation,\r\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n *\r\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n * or visit www.oracle.com if you need additional information or have any\r\n * questions.\r\n */\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// package java.io;\r\n// import java.util.Arrays;\r\nimport Arrays from './Arrays';\r\nimport OutputStream from './OutputStream';\r\nimport Integer from './Integer';\r\nimport IllegalArgumentException from '../IllegalArgumentException';\r\nimport OutOfMemoryError from '../OutOfMemoryError';\r\nimport System from './System';\r\nimport IndexOutOfBoundsException from '../IndexOutOfBoundsException';\r\n/**\r\n * This class implements an output stream in which the data is\r\n * written into a byte array. The buffer automatically grows as data\r\n * is written to it.\r\n * The data can be retrieved using <code>toByteArray()</code> and\r\n * <code>toString()</code>.\r\n * <p>\r\n * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\r\n * this class can be called after the stream has been closed without\r\n * generating an <tt>IOException</tt>.\r\n *\r\n * @author  Arthur van Hoff\r\n * @since   JDK1.0\r\n */\r\nvar ByteArrayOutputStream = /** @class */ (function (_super) {\r\n    __extends(ByteArrayOutputStream, _super);\r\n    /**\r\n     * Creates a new byte array output stream. The buffer capacity is\r\n     * initially 32 bytes, though its size increases if necessary.\r\n     */\r\n    // public constructor() {\r\n    //     this(32);\r\n    // }\r\n    /**\r\n     * Creates a new byte array output stream, with a buffer capacity of\r\n     * the specified size, in bytes.\r\n     *\r\n     * @param   size   the initial size.\r\n     * @exception  IllegalArgumentException if size is negative.\r\n     */\r\n    function ByteArrayOutputStream(size) {\r\n        if (size === void 0) { size = 32; }\r\n        var _this = _super.call(this) || this;\r\n        /**\r\n         * The number of valid bytes in the buffer.\r\n         */\r\n        _this.count = 0;\r\n        if (size < 0) {\r\n            throw new IllegalArgumentException('Negative initial size: '\r\n                + size);\r\n        }\r\n        _this.buf = new Uint8Array(size);\r\n        return _this;\r\n    }\r\n    /**\r\n     * Increases the capacity if necessary to ensure that it can hold\r\n     * at least the number of elements specified by the minimum\r\n     * capacity argument.\r\n     *\r\n     * @param minCapacity the desired minimum capacity\r\n     * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is\r\n     * interpreted as a request for the unsatisfiably large capacity\r\n     * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.\r\n     */\r\n    ByteArrayOutputStream.prototype.ensureCapacity = function (minCapacity) {\r\n        // overflow-conscious code\r\n        if (minCapacity - this.buf.length > 0)\r\n            this.grow(minCapacity);\r\n    };\r\n    /**\r\n     * Increases the capacity to ensure that it can hold at least the\r\n     * number of elements specified by the minimum capacity argument.\r\n     *\r\n     * @param minCapacity the desired minimum capacity\r\n     */\r\n    ByteArrayOutputStream.prototype.grow = function (minCapacity) {\r\n        // overflow-conscious code\r\n        var oldCapacity = this.buf.length;\r\n        var newCapacity = oldCapacity << 1;\r\n        if (newCapacity - minCapacity < 0)\r\n            newCapacity = minCapacity;\r\n        if (newCapacity < 0) {\r\n            if (minCapacity < 0) // overflow\r\n                throw new OutOfMemoryError();\r\n            newCapacity = Integer.MAX_VALUE;\r\n        }\r\n        this.buf = Arrays.copyOfUint8Array(this.buf, newCapacity);\r\n    };\r\n    /**\r\n     * Writes the specified byte to this byte array output stream.\r\n     *\r\n     * @param   b   the byte to be written.\r\n     */\r\n    ByteArrayOutputStream.prototype.write = function (b) {\r\n        this.ensureCapacity(this.count + 1);\r\n        this.buf[this.count] = /*(byte)*/ b;\r\n        this.count += 1;\r\n    };\r\n    /**\r\n     * Writes <code>len</code> bytes from the specified byte array\r\n     * starting at offset <code>off</code> to this byte array output stream.\r\n     *\r\n     * @param   b     the data.\r\n     * @param   off   the start offset in the data.\r\n     * @param   len   the number of bytes to write.\r\n     */\r\n    ByteArrayOutputStream.prototype.writeBytesOffset = function (b, off, len) {\r\n        if ((off < 0) || (off > b.length) || (len < 0) ||\r\n            ((off + len) - b.length > 0)) {\r\n            throw new IndexOutOfBoundsException();\r\n        }\r\n        this.ensureCapacity(this.count + len);\r\n        System.arraycopy(b, off, this.buf, this.count, len);\r\n        this.count += len;\r\n    };\r\n    /**\r\n     * Writes the complete contents of this byte array output stream to\r\n     * the specified output stream argument, as if by calling the output\r\n     * stream's write method using <code>out.write(buf, 0, count)</code>.\r\n     *\r\n     * @param      out   the output stream to which to write the data.\r\n     * @exception  IOException  if an I/O error occurs.\r\n     */\r\n    ByteArrayOutputStream.prototype.writeTo = function (out) {\r\n        out.writeBytesOffset(this.buf, 0, this.count);\r\n    };\r\n    /**\r\n     * Resets the <code>count</code> field of this byte array output\r\n     * stream to zero, so that all currently accumulated output in the\r\n     * output stream is discarded. The output stream can be used again,\r\n     * reusing the already allocated buffer space.\r\n     *\r\n     * @see     java.io.ByteArrayInputStream#count\r\n     */\r\n    ByteArrayOutputStream.prototype.reset = function () {\r\n        this.count = 0;\r\n    };\r\n    /**\r\n     * Creates a newly allocated byte array. Its size is the current\r\n     * size of this output stream and the valid contents of the buffer\r\n     * have been copied into it.\r\n     *\r\n     * @return  the current contents of this output stream, as a byte array.\r\n     * @see     java.io.ByteArrayOutputStream#size()\r\n     */\r\n    ByteArrayOutputStream.prototype.toByteArray = function () {\r\n        return Arrays.copyOfUint8Array(this.buf, this.count);\r\n    };\r\n    /**\r\n     * Returns the current size of the buffer.\r\n     *\r\n     * @return  the value of the <code>count</code> field, which is the number\r\n     *          of valid bytes in this output stream.\r\n     * @see     java.io.ByteArrayOutputStream#count\r\n     */\r\n    ByteArrayOutputStream.prototype.size = function () {\r\n        return this.count;\r\n    };\r\n    ByteArrayOutputStream.prototype.toString = function (param) {\r\n        if (!param) {\r\n            return this.toString_void();\r\n        }\r\n        if (typeof param === 'string') {\r\n            return this.toString_string(param);\r\n        }\r\n        return this.toString_number(param);\r\n    };\r\n    /**\r\n     * Converts the buffer's contents into a string decoding bytes using the\r\n     * platform's default character set. The length of the new <tt>String</tt>\r\n     * is a function of the character set, and hence may not be equal to the\r\n     * size of the buffer.\r\n     *\r\n     * <p> This method always replaces malformed-input and unmappable-character\r\n     * sequences with the default replacement string for the platform's\r\n     * default character set. The {@linkplain java.nio.charset.CharsetDecoder}\r\n     * class should be used when more control over the decoding process is\r\n     * required.\r\n     *\r\n     * @return String decoded from the buffer's contents.\r\n     * @since  JDK1.1\r\n     */\r\n    ByteArrayOutputStream.prototype.toString_void = function () {\r\n        return new String(this.buf /*, 0, this.count*/).toString();\r\n    };\r\n    /**\r\n     * Converts the buffer's contents into a string by decoding the bytes using\r\n     * the specified {@link java.nio.charset.Charset charsetName}. The length of\r\n     * the new <tt>String</tt> is a function of the charset, and hence may not be\r\n     * equal to the length of the byte array.\r\n     *\r\n     * <p> This method always replaces malformed-input and unmappable-character\r\n     * sequences with this charset's default replacement string. The {@link\r\n     * java.nio.charset.CharsetDecoder} class should be used when more control\r\n     * over the decoding process is required.\r\n     *\r\n     * @param  charsetName  the name of a supported\r\n     *              {@linkplain java.nio.charset.Charset </code>charset<code>}\r\n     * @return String decoded from the buffer's contents.\r\n     * @exception  UnsupportedEncodingException\r\n     *             If the named charset is not supported\r\n     * @since   JDK1.1\r\n     */\r\n    ByteArrayOutputStream.prototype.toString_string = function (charsetName) {\r\n        return new String(this.buf /*, 0, this.count, charsetName*/).toString();\r\n    };\r\n    /**\r\n     * Creates a newly allocated string. Its size is the current size of\r\n     * the output stream and the valid contents of the buffer have been\r\n     * copied into it. Each character <i>c</i> in the resulting string is\r\n     * constructed from the corresponding element <i>b</i> in the byte\r\n     * array such that:\r\n     * <blockquote><pre>\r\n     *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))\r\n     * </pre></blockquote>\r\n     *\r\n     * @deprecated This method does not properly convert bytes into characters.\r\n     * As of JDK&nbsp;1.1, the preferred way to do this is via the\r\n     * <code>toString(String enc)</code> method, which takes an encoding-name\r\n     * argument, or the <code>toString()</code> method, which uses the\r\n     * platform's default character encoding.\r\n     *\r\n     * @param      hibyte    the high byte of each resulting Unicode character.\r\n     * @return     the current contents of the output stream, as a string.\r\n     * @see        java.io.ByteArrayOutputStream#size()\r\n     * @see        java.io.ByteArrayOutputStream#toString(String)\r\n     * @see        java.io.ByteArrayOutputStream#toString()\r\n     */\r\n    // @Deprecated\r\n    ByteArrayOutputStream.prototype.toString_number = function (hibyte) {\r\n        return new String(this.buf /*, hibyte, 0, this.count*/).toString();\r\n    };\r\n    /**\r\n     * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\r\n     * this class can be called after the stream has been closed without\r\n     * generating an <tt>IOException</tt>.\r\n     * <p>\r\n     *\r\n     * @throws IOException\r\n     */\r\n    ByteArrayOutputStream.prototype.close = function () {\r\n    };\r\n    return ByteArrayOutputStream;\r\n}(OutputStream));\r\nexport default ByteArrayOutputStream;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}